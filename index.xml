<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>fe-news</title><id></id><updated>2022-04-06T03:56:52+00:00</updated><category term="technology"/><category term="web"/><category term="frontend"/><icon>https://avatars.githubusercontent.com/u/6589568?s=200&v=4</icon><logo>https://avatars.githubusercontent.com/u/6589568?s=200&v=4</logo><entry><title>2022-03</title><id>https://github.com/naver/fe-news/blob/master/issues/2022-03.md</id><updated>2022-04-06T03:56:52+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2022-03.md" rel="alternate"/><published>2022-03-02T04:28:14+00:00</published><content type="html">&lt;h1&gt;2022-03 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://2021.stateofjs.com/ko-KR/"&gt;State of JS 2021&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 1년간 Front-end 영역에서의 변화와 앞으로의 전망을 살펴볼 수 있는 &lt;em&gt;State of JS 2021&lt;/em&gt; 결과가 발표되었다.&lt;/p&gt;
&lt;p&gt;기술에 대한 전 세계의 개발자들의 선호도와 만족도를 정리된 자료를 통해 쉽게 알아볼 수 있다.&lt;/p&gt;
&lt;p&gt;TL;DR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프레임워크: Angular의 충격적 순위와 Vue.js의 하락세&lt;/li&gt;
&lt;li&gt;빌드 도구: Webpack의 지속적 하락세와 Vite, esbuild, swc로의 세대교체&lt;/li&gt;
&lt;li&gt;Back-end: Gastby는 순위의 제일 마지막에 랭킹&lt;/li&gt;
&lt;li&gt;모바일 &amp;amp; 데스크톱: Tauri의 등장&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 빠르게 전체 설문 결과에 대한 인사이트를 훑어 보고 싶다면, 다음 동영상을 참고하라.
&lt;a href="https://www.youtube.com/watch?v=1L2hrG-7i2Y"&gt;The Shocking State of JavaScript // The Code Report&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/dragosnedelcu/the-harsh-reality-for-js-developers-master-the-fundamentals-or-you-will-be-just-a-coder-21ke"&gt;The Harsh Reality for JS Developers: If You Don't Study The Fundamentals You Will Be Just Another “Coder”&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;자신이 15시간 내내 작성한 코드에 대한 코드 리뷰 과정에서 모두가 나의 의견과 답변을 기다리는 상황에서, 작성한 코드를 설명할 적절한 단어를 찾지 못하거나 또는 매일 다루는 라이브러리/언어(React Hooks, TypeScript 등)들이 실제로 어떻게 동작하는지 이해하지 못하고 있다면, 오늘날의 소프트웨어 개발자로써 쓰라린 다음의 현실에 직면하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;quot;기술의 빠른 발전에 대비해, 우리는 시간과의 싸움에서 지고 있다&amp;quot;라는 사실이다.&lt;/p&gt;
&lt;p&gt;글의 저자는 4년 동안, 기술적 스킬 향상을 위한 최선의 방법들을 찾기 위한 과정들을 통해
JavaScript 개발자로서 중/고급 레벨에 더 빨리 도달하는 방법에 대한 주요 정보(5단계)를 공유한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://podcasts.apple.com/us/podcast/how-a-%24725m-vc-judges-your-engineering-team-w/id1537003676?i=1000550873045"&gt;How a $725M VC Judges Your Engineering Team w/ Redpoint Ventures' Jason Warner&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;전 GitHub CTO였던 &lt;a href="https://www.linkedin.com/in/jcw148/"&gt;Jason Warner&lt;/a&gt;(현 Redpoint 벤처 캐피털 매니저)의 팟캐스트 인터뷰(팟캐스트 15:20 분경)에서 그는 Full-stack 개발이 유행하고 있지만, 미래에는 개발되는 제품의 복잡성 증가에 따라 프로그래밍의 미래에서 Full-stack 엔지니어의 감소가 일어날 것이며, back-end 영역에서는 전문성을 지향하는  방향으로의 변화와 이동이 이뤄질 것으로 예측했다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/"&gt;Include diagrams in your Markdown files with Mermaid&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;아래는 Markdown Mermaid syntax로 만든 다이어그램&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-mermaid"&gt;  graph TD;
      A--&amp;gt;B;
      A--&amp;gt;C;
      B--&amp;gt;D;
      C--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 Github에서 markdown 파일에서 다이어그램을 렌더링 할 수 있다.&lt;/p&gt;
&lt;p&gt;어떤 방식으로 다이어그램을 만들고 렌더링 하는지도 파이프라인을 통해 설명해 주고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://youtu.be/Wm_xI7KntDs"&gt;The Story of React&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;2013년 React가 초기에 발표되었을 때 시장에서의 반응은 썩 좋진 않았다. 하지만 지금은 React의 시대라 해도 과언이 아닐 정도로 가장 인기 있고 영향력 있는 프로젝트가 되었다.&lt;/p&gt;
&lt;p&gt;이 영상은 jQuery, Backbone, Angular 시대를 걸쳐 React 시대로 어떻게 왔는지의 역사를 유머 있게 이야기하고 있다. 10분의 시청 시간 동안 React의 관점에서 Front-end의 역사를 가볍게 느껴볼 수 있을 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/facebook/jest/pull/11529#issuecomment-1027152470"&gt;Nobody at Facebook has worked on Jest for years&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Meta(Facebook)의 인기 있는 테스트 프레임워크인 Jest의 주요 기여자인 &lt;a href="https://github.com/SimenB"&gt;Simen Bekkhus&lt;/a&gt;(&lt;a href="https://github.com/facebook/jest/graphs/contributors"&gt;프로젝트 최다 커밋 기여자&lt;/a&gt;)는 프로젝트의 한 이슈를 통해 수년간 Meta 소속 인원들이 수년간 개발에 참여하지 않고 있다는 코멘트를 등록했다.&lt;/p&gt;
&lt;p&gt;Simen은 추가 &lt;a href="https://github.com/facebook/jest/pull/11529#issuecomment-1027405616"&gt;코멘트&lt;/a&gt;를 통해 불필요한 오해(위의 코멘트에 대한 의도)가 생기는 것을 방지하기 위해, 자신은 Meta로부터 Jest 프로젝트 기여에 대한 활동을 하면서 어떠한 비용(보상에 대한 기회는 제공되었으나)도 지급받지 않았으며, 이는 보수 지급을 받게 되면 프로젝트 참여가 업무적 성격으로 변하는 것에 대한 개인적 거부감으로 인해, 개인적 선택에 따라 보상에 대한 기회를 거부했다는 내용도 함께 공유했다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://javascript.plainenglish.io/efficiently-merging-arrays-in-javascript-32993788a8b2"&gt;How to Efficiently Merge Arrays in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript에서 배열을 합치는 방법은 &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; 메서드를 활용하거나 &lt;code&gt;spread&lt;/code&gt; 오퍼레이터를 사용할 수 있다.
각각의 방법들이 배열 엘리먼트에 숫자와 타입(원시 타입 혹은 객체)에 따라 벤치마크가 어떻게 나오는지 그 결과를 확인해보자.
(위 문서에 없는 &lt;code&gt;[...array1, ...array2]&lt;/code&gt; 케이스가 궁금하다면 &lt;a href="https://github.com/ecofic/article-efficiently-merging-arrays-in-javascript"&gt;예제 코드&lt;/a&gt;를 직접 수정해서 확인해 보자.)&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.plasmic.app/posts/how-react-server-components-work/#what-are-react-server-components"&gt;How React server components work: an in-depth guide&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 빠르게 읽고 싶다면 &lt;a href="https://junghan92.medium.com/%EB%B2%88%EC%97%AD-how-react-server-components-work-an-in-depth-guide-aaf90ebd3c45"&gt;번역글&lt;/a&gt;을 참고하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://monorepo.tools/"&gt;monorepo.tools&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Monorepos에 대해 알아야 하는 모든 정보들을 정리해 놓았다. Monorepo가 무엇인지부터, polyrepo 구조와의 비교 등 Monorepo에 대해 더 잘 이해할 수 있는 모든 리소스(동영상, 튜토리얼, ebook 등) 들에 대한 링크를 제공한다.&lt;/p&gt;
&lt;p&gt;또한 생태계에서 찾아볼 수 있는 7개 도구들에 대한 비교 테이블도 제공하기 때문에 각 도구들의 장단점을 한눈에 비교해 볼 수 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/vinodotdev/node-to-rust/blob/master/from-javascript-to-rust.pdf"&gt;From JavaScript to Rust ebook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;저자인 &lt;a href="https://twitter.com/jsoverson"&gt;Jarrod Overson&lt;/a&gt;가 21년 12월  1일 부터 24일간 매일 자신의 &lt;a href="https://vino.dev/blog/"&gt;개발 블로그&lt;/a&gt; 를 통해 연재를 시작한 &amp;quot;24 days from node.js to Rust&amp;quot; 시리즈 글이 기대했던 것보다 많은 이들의 관심을 불러일으키자 이를 다수의 기여자들의 도움을 통해 ebook 형태로 만들고 공개했다.&lt;/p&gt;
&lt;p&gt;책의 제목에서 유추할 수 있듯, 이 책은 JavaScript(node.js) 개발자들의 관점에서 Rust를 학습할 수 있도록 도와준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://varun.ca/three-js-particles"&gt;Three ways to create 3D particle effects&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://www.stefanjudis.com/blog/reporterror-a-method-to-report-to-global-event-handlers/"&gt;New in JavaScript: reportError – a method to report to global event handlers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Front-end에서 오류 모니터링은 주로 전역 에러 이벤트 핸들러를 통해 이뤄진다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 또는 window.addEventListener(&amp;quot;error&amp;quot;, function(){})
window.onerror = function (message, source, lineno, colno, error) {
	console.log(&amp;quot;Global error: &amp;quot; + error.message + &amp;quot;, lineno: &amp;quot; + lineno);

	return true;
};

function triggerError() {
	throw new Error('Oh no!');
}

triggerError();

// 출력: Global error: Oh no!, lineno: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 몇 단계 더 깊은 레벨의 call stack에서의 오류 처리는 복잡해지며, 상황에 따라 오류 객체가 오류 핸들러로 전달되지 않는 문제가 있다.&lt;/p&gt;
&lt;p&gt;전역 메서드인 reportError()를 사용하면 call stack 실행의 중단 없이 오류를 전역 오류 핸들러로 전달할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const fns = [
 () =&amp;gt; { console.log(&amp;quot;I'm first!&amp;quot;); },
 () =&amp;gt; { throw new Error(&amp;quot;Oh no!&amp;quot;); },
 () =&amp;gt; { console.log(&amp;quot;I'm third!&amp;quot;); },
];

  
// Iterate over the functions
for (const fn of fns) {
	// (1) 에러 이후, 반복문 수행이 중단된다.
	fn();  

	try {
		fn();
	} catch(error) {
		// (2) try...catch로 감싸면, 반복문이 중단되지 않지만, 전역 오류 핸들러로 오류가 버블링 되지 않는다.
		console.error(error);

		// (3) reportError()를 통해 오류가 버블링 되도록 할 수 있다.
		reportError(error);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://bruno-simon.com"&gt;어느 개발자의 Resume&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Three.js를 활용하여 만든 개발자의 이력서 페이지이다.
브라우저 타이틀바에 차량의 움직임까지 표현한 완성도 높은 개인 사이트이다. 이 사이트를 통해 WebGL의 가능성을 살펴보기 바란다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/pixijs/pixijs"&gt;Pixi.JS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;하드웨어 가속을 이용한 고성능의 2D WebGL 렌더링 라이브러리.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/arturbien/React95"&gt;React95&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React Windows95 컴포넌트. 예전부터 운영체제 UI를 웹에서 구현하는 프로젝트가 종종 있었지만 이 프로젝트는 완성도가 좀 더 높아 보인다. &lt;a href="https://storybook.react95.io/?path=/story/anchor--default"&gt;스토리북&lt;/a&gt;에서 다양한 컴포넌트들을 직접 확인해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/github/hotkey"&gt;Hotkey 2.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hotkey는 깃헙에서 개발한 라이브러리로 단축키를 사용하고자 하는 요소에 &lt;code&gt;data-hotkey&lt;/code&gt; 속성을 추가하면 간편하게 단축키를 등록할 수 있다. 간단한 사용법은 다음 코드를 참고하자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;a href=&amp;quot;/page/2&amp;quot; data-hotkey=&amp;quot;j&amp;quot;&amp;gt;Next&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;/help&amp;quot; data-hotkey=&amp;quot;Control+h&amp;quot;&amp;gt;Help&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;/rails/rails&amp;quot; data-hotkey=&amp;quot;g c&amp;quot;&amp;gt;Code&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;/search&amp;quot; data-hotkey=&amp;quot;s,/&amp;quot;&amp;gt;Search&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import {install} from '@github/hotkey'

// Install all the hotkeys on the page
for (const el of document.querySelectorAll('[data-hotkey]')) {
  install(el)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/imbrn/v8n"&gt;v8n&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;v8n은 메서드 체이닝을 사용해 직관적으로 유효성 검사를 구현할 수 있는 라이브러리다. 다음과 같이 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;v8n()
  .string()
  .minLength(5)
  .first(&amp;quot;H&amp;quot;)
  .last(&amp;quot;o&amp;quot;)
  .test(&amp;quot;Hello&amp;quot;); // true
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>2021-11</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-11.md</id><updated>2021-11-03T04:51:29+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-11.md" rel="alternate"/><published>2021-10-26T16:24:11+00:00</published><content type="html">&lt;h1&gt;2021-11 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://cmdcolin.github.io/2021-10-30-spooky.html"&gt;A spooky error when you have a string bigger than 512MB in Chrome&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 브라우저에서 처리할 수 있는 최대 문자열은 크기는 얼마일까?&lt;/p&gt;
&lt;p&gt;결론부터 말하자면 512MB 이상의 문자열을 처리하지 못한다. 최신 버전인 95(Canary 97 포함)에서 제대로 처리하지 못하며, 이는 같은 chromium 계열인 Edge와 Opera도 마찬가지다. Firefox와 Safari에선 정상 동작한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const len = 536_870_888; // +1을 하면?
const buf = new Uint8Array(len);
for (let i = 0; i &amp;lt; len; i++) {
  buf[i] = &amp;quot;a&amp;quot;.charCodeAt(0);
}
const str = new TextDecoder().decode(buf);
console.log(str.length);  // 536870888 출력

// 간단한 방법으로는 아래와 같이 테스트 해볼수도 있다.
&amp;quot;a&amp;quot;.repeat(536_870_888 + 1).length  // Uncaught RangeError: Invalid string length
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://tech.kakao.com/2021/09/29/mocking-fe/"&gt;Mocking으로 생산성까지 챙기는 FE 개발&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Front-end 개발자가 쉽게 겪게 되는 백엔드 개발 의존성을 해결하기 위해 Mocking을 적극적으로 활용하는 방법을 제시한다.&lt;br /&gt;
&lt;code&gt;MSW.js&lt;/code&gt; 를 이용하여 Mocking을 하고, 백엔드가 준비되지 않은 경우에도 Front-end 개발을 진행할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://reactiver.dev/review-react-derived-state/"&gt;React Derived State 다시 보기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;의 &lt;code&gt;Derived State&lt;/code&gt;에 대해서 알아보고, &lt;code&gt;Derived State&lt;/code&gt;를 사용하다 생긴 문제를 확인하고,&lt;br /&gt;
개선 방법인 &lt;code&gt;FULLY CONTROLLED COMPONENT&lt;/code&gt;, &lt;code&gt;FULLY UNCONTROLLED COMPONENT + KEY&lt;/code&gt;를 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://alexsidorenko.com/blog/react-render-cheat-sheet/"&gt;A Visual Guide to React Rendering - Cheat Sheet&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React에서 불필요한 Re-rendering이 발생할 수 있는 케이스들을 모아 놓은 Cheet Sheet이다.&lt;br /&gt;
각 케이스별로 상황을 보여주고, 해결책을 제시해 준다.&lt;br /&gt;
놓치기 쉬운 부분이니 초보 React 개발자라면 꼭 읽어보길 추천한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@wongue_shin/JS%EC%9D%98-%EA%B0%9D%EC%B2%B4%EB%8A%94-hash-table%EC%9D%B4-%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4"&gt;JS의 객체는 hash table이 아닙니다!&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;V8 엔진&lt;/code&gt;을 사용하는 경우 JS의 객체가 &lt;code&gt;Hash Table&lt;/code&gt;이 아닌 것을 공부한 시간 흐름에 따라 정리한 글이다.&lt;br /&gt;
이 글을 통해 &lt;code&gt;JS Object&lt;/code&gt;는 어떤 구조로 되어 있는지, &lt;code&gt;Array&lt;/code&gt;의 상태와 퍼포먼스를 유리하게 동작하게 하는 방법, 동적 타이핑 언어의 특징 등을 알 수 있고&lt;br /&gt;
결론적으로 왜 &lt;code&gt;Hash Table&lt;/code&gt;로 구현되지 않은 이유까지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://techblog.woowahan.com/5900/"&gt;크롬 익스텐션에서 데이터를 어떻게 다룰 것인가? (피트스탑과제 – 크롬 익스텐션 개발기)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;복잡한 여러 폼에 대해 입력을 자동화 툴을 크롬 익스텐션을 만드는 과정에서,&lt;br /&gt;
데이터를 저장소를 어떤 것을 선택하였는지 또 저장 코드의 위치에 따라
다르게 동작하는 부분을 소개해 준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://wormwlrm.github.io/2021/10/11/Why-User-Agent-string-is-so-complex.html"&gt;브라우저의 사용자 에이전트는 왜 이렇게 복잡하게 생겼을까?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;브라우저의 사용자 에이전트가 복잡한 역사적인 이야기를 잘 정리한 글이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결론을 우선 한 마디로 요약하자면, 호환성을 유지하기 위해서 입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;인터넷 익스플로러(IE)가 넷스케이프 브라우저의 UA를 흉내냄으로써, 처음으로 UA가 더럽혀지기 시작했다.&lt;/li&gt;
&lt;li&gt;모질라 재단이 넷스케이프 브라우저의 렌더 엔진을 오픈소스 프로젝트로 공개한 후부터는 브라우저 렌더 엔진 정보도 UA에 추가되기 시작했다.&lt;/li&gt;
&lt;li&gt;브라우저 전쟁 이후 다양한 브라우저가 생겼는데, 호환성을 유지하기 위해 기존 브라우저 UA에 스트링을 계속 덧붙이다보니 지금과 같은 끔찍한 형태가 되어버렸다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;글을 읽으면 더 자세한 이야기를 읽을 수 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.ditdot.hr/en/4-tips-better-asynchronous-javascript-code"&gt;4 Essential Tips for Better Asynchronous Code in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;새로운 프로그래밍 테크닉을 배우는 것은 단순히 코드가 '동작'되는 것에서 '좋은 코드'로의 발전을 의미하며,&lt;br /&gt;
더 나은 비동기 코드를 작성하는 본문에서 소개하는 4개의 팁은 항상 유용할 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=PBrEq9Wd6_U"&gt;Candy Crush in React&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;를 이용해 &lt;code&gt;Candy Crush&lt;/code&gt; 게임을 만들어보는 튜토리얼 영상이다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://code.visualstudio.com/blogs/2021/10/20/vscode-dev"&gt;vscode.dev(!)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-integrated-development-environment"&gt;stackoverflow의 2021 통계&lt;/a&gt;에 따르면 &lt;code&gt;VS Code&lt;/code&gt;는 가장 많은 개발자들이 선택하는 IDE이다.
이런 &lt;code&gt;VS Code&lt;/code&gt;의 웹 버전이 공개되었다.&lt;br /&gt;
&lt;code&gt;VS Code&lt;/code&gt;를 설치할 수 없는 환경(iPad, Chromebook)에서도 실행이 가능하다.&lt;br /&gt;
&lt;code&gt;github&lt;/code&gt;의 경우 clone 없이 &lt;code&gt;https://vscode.dev/github.com/microsoft/vscode&lt;/code&gt; 직접 접근도 가능하다.
&lt;code&gt;Live Share&lt;/code&gt;의 경우에도 설치 없이 협업을 할 수 있다.&lt;br /&gt;
또한 GitHub 프로젝트의 경우, 도메인을 &lt;code&gt;.com&lt;/code&gt; → &lt;code&gt;.dev&lt;/code&gt;로 변경하면 손쉽게 온라인 VSCode로 프로젝트를 열어볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex. https://github.com/facebook/react → https://github.dev/facebook/react&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/alangpierce/sucrase"&gt;Sucrase&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Babel과 같은 트랜스파일러는 레거시 브라우저에서의 실행을 위해 모든 코드를 변환하지만, Sucrase는 개발자들 대다수가 개발 환경에서 모던 브라우저를 사용하고 있다고 가정해 JavaScript 코드는 변환하지 않고, 꼭 트랜스파일이 필요한 JSX나 TypeScript에 집중해 빠르게 빌드를 수행하는 도구다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://sucrase.io/"&gt;Try it out&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음은 36만 라인의 코드에 대한 벤치마크 결과로, Babel 보다 20배 빠른 성능을 보여준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;            Time            Speed
Sucrase     1.64 seconds    220221 lines per second
swc         2.13 seconds    169502 lines per second
esbuild     3.02 seconds    119738 lines per second
TypeScript  24.18 seconds   14937 lines per second
Babel       27.22 seconds   13270 lines per second
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/joshnuss/react-hooks-in-svelte"&gt;React Hooks in Svelte&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Svelte 버전으로 포팅된 React Hooks 예제들 모음&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.metachris.com/2021/04/starting-a-typescript-project-in-2021/"&gt;TypeScript Boilerplate for 2021&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2021년 시점에서 빠르게 TypeScript 기반 프로젝트를 시작할 수 있는 boilerplate로, TS4, esbuild(optional), Jest, TypeDoc 등을 사용한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://violetboralee.medium.com/vscode%EC%97%90%EC%84%9C-bracket-pair-colorizer-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B3%A0-%EB%82%B4%EC%9E%A5-%EA%B8%B0%EB%8A%A5-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-e75558a87990"&gt;VSCode에서 Bracket Pair Colorizer 삭제하고 내장 기능 사용하기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;괄호(Bracket)의 쌍을 맞추어 주는 &lt;code&gt;VS Code&lt;/code&gt;의 도구로 &lt;code&gt;Bracket Pair Colorizer&lt;/code&gt; 플러그인이 있지만,&lt;br /&gt;
성능 이슈로 자체적으로 동일한 기능을 하는 옵션을 제공한다고 한다. 이 글을 따라가면 쉽게 설정을 변경할 수 있다.&lt;/p&gt;
</content></entry><entry><title>2022-02</title><id>https://github.com/naver/fe-news/blob/master/issues/2022-02.md</id><updated>2022-02-04T03:24:37+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2022-02.md" rel="alternate"/><published>2022-02-03T01:17:19+00:00</published><content type="html">&lt;h1&gt;2022-02 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://javascript.plainenglish.io/what-do-you-need-to-know-about-new-era-of-internet-web-3-0-as-a-frontend-developer-55e51f2cd03f"&gt;What You Need to Know About the New Era of Internet Web 3.0 As a Frontend Developer&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Web 3.0은 무엇인가? 온라인에서 수많은 정의를 찾아볼 수 있겠지만, 무엇도 정확하고 단순하게 설명되지 않을 것이다. 왜냐하면 그 자체에 대한 정의가 명확하지 않기 때문이다. 일반적으로 Web 3.0은 메타버스, 블록체인, 암호화폐, NFT 등과 연관된다.&lt;/p&gt;
&lt;p&gt;Front-end 개발자가 꼭 알아야 할까? 그렇지 않을 수도 있지만, Web 1.0 → 2.0으로의 진화에 따라 Front-end 기술 영역의 정의가 명확해진 것처럼, Web 3.0은 또 다른 변환점을 가져올 수도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;아직은 시기 상조일 수 있지만, 왜 온라인에서 이토록 Web 3.0에 대한 많은 이야기가 오가는지 관심을 두는 것은 장기적 관점에서 도움이 될 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] Web 3.0에 대해 좀 더 알고 싶다면 추가적으로 다음 링크들을 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=f9XRH7bjV8M"&gt;Defining the Web3 Stack - Nader Dabit - (Next.js Conf 2021)&lt;/a&gt; (기술스택 위주 소개)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stibee.com/api/v1.0/emails/share/xJZlbV0k-4beUjVVNmJTR8CLYeRACQ=="&gt;실리콘밸리는 웹 3.0 논쟁 중이래요!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://p5js.org/ko/"&gt;p5.js&lt;/a&gt;로 만든 &lt;a href="https://twitter.com/dabit3/status/1427807893458497544"&gt;JavaScript 아트 작품들이 3백만 달러에 판매&lt;/a&gt;한 사례&lt;/li&gt;
&lt;li&gt;&lt;a href="https://moxie.org/2022/01/07/web3-first-impressions.html"&gt;My first impressions of web3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://channy.creation.net/blog/1509"&gt;블록체인판 Web3 열풍 속 현실적 반론&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://lucumr.pocoo.org/2022/1/10/dependency-risk-and-funding/"&gt;Dependency Risk and Funding&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;한글 번역: &lt;a href="https://blog.outsider.ne.kr/1577"&gt;의존성 위험성과 펀딩&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;'22/1월 초, 유명한 오픈소스 프로젝트들인 &lt;a href="https://github.com/Marak/colors.js"&gt;colors.js&lt;/a&gt;와 &lt;a href="https://github.com/Marak/faker.js"&gt;faker.js&lt;/a&gt;(&lt;a href="./2020-12.md#fakerjs"&gt;FE News '20/12월 소식을 통해 소개&lt;/a&gt;)를 개발했던 Marak은 각각 신규 릴리스를 하면서 colors.js  &lt;code&gt;v1.4.1&lt;/code&gt;에 무한 루프 코드를 추가하고, faker.js &lt;a href="https://www.npmjs.com/package/faker/v/6.6.6"&gt;&lt;code&gt;v6.6.6&lt;/code&gt;&lt;/a&gt;은 비어있는 모듈을 반환하면서 더불어 저장소의 코드를 모두 지워버리는 일련의 사건이 발생했었다.&lt;/p&gt;
&lt;p&gt;이러한 결정의 주요 원인으로는 많은 이들이 사용하는 인기있는 오픈소스이더라도 유지에 따르는 비용을
그 누구도 쉽게 지불하지 않는 오픈소스 생태계의 숨겨진 불균형(생산자/기여자에 비해 소비자가 압도적인)에 따른
문제이기도 하다.&lt;/p&gt;
&lt;p&gt;인기 있는 패키지들은 NPM 생태계의 이곳저곳을 지탱하고 있지만, 그만큼 취약한 것도 사실이다. 이를 단순한 해프닝으로 볼 수도 있지만, 지속 가능한 생태계를 위해 필요한 것이 무엇인지 우리 모두 진지하게 생각할 필요가 있지 않을까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] faker.js를 사용하고 있었다면. fork 프로젝트인 &lt;a href="https://github.com/faker-js/faker"&gt;Faker&lt;/a&gt; 또는 유사한 &lt;a href="https://github.com/ngneat/falso"&gt;falso&lt;/a&gt; 프로젝트 사용을 고려해 보기 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://blog.angular.io/discontinued-long-term-support-for-angularjs-cc066b82e65a"&gt;Discontinued Long Term Support for AngularJS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;AngularJS LTS 지원이 기 예고되었던 것과 같이 ’21/12/31일을 기점으로 중단되었다. 이로써 JavaScript 생태계에 프레임워크라는 새로운 시대를 열었던 AngularJS는 그 역할을 다하고 마침표를 찍게 되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://devblog.croquis.com/ko/2022-01-13-1-frontend-state-management/"&gt;프론트엔드 상태 관리에 대한 여정&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;카카오 스타일(구 지그재그) 개발팀에서 React 상태 관리를 위해 Jotai를 선택하게 된 배경을 다루는
첫 번째 시리즈 글로, 상태 관리를 위해 &lt;a href="https://github.com/MithrilJS/mithril.js/"&gt;Mithril&lt;/a&gt;, &lt;a href="https://github.com/mobxjs/mobx"&gt;MobX&lt;/a&gt;, &lt;a href="https://ko.reactjs.org/docs/hooks-reference.html#usereducer"&gt;useReducer&lt;/a&gt; 등을 사용했지만 최종적으로 왜 &lt;a href="https://github.com/pmndrs/jotai"&gt;Jotai&lt;/a&gt;에
이르게 되었는지를 소개한다.&lt;/p&gt;
&lt;p&gt;Jotai를 선택하게 된 이유는 다음과 같다고 밝히고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;큰 state를 정의하는 대신, 개별 상태(atom)를 정의해서 조합해서 사용한다는 것&lt;/li&gt;
&lt;li&gt;개념이 단순하고 코드 크기가 작다는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://dev.to/mbarzeev/from-jest-to-vitest-migration-and-benchmark-23pl"&gt;From Jest to Vitest - Migration and Benchmark&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://github.com/vitest-dev/vitest"&gt;Vitest&lt;/a&gt;는 &lt;a href="https://vitejs.dev/"&gt;Vite&lt;/a&gt; 기반의 테스트 프레임워크다. 현재 개발 중인 상태로, stable 단계에 도달하진 않은 상태다. Vite의 개발 환경과 설정을 그대로 사용하며, Jest 호환 API와 빌트인 Chai, 멀티 스레딩 등이 지원된다.&lt;/p&gt;
&lt;p&gt;Jest와 비교 시 얼마나 빠를까? 글의 저자는 Jest로 작성된 37개 테스트(4개 파일로 구성)를 대상으로 Jest → Vitest로의 전환 과정과 함께 벤치마크 결과를 소개한다.&lt;/p&gt;
&lt;p&gt;벤치마크 결과는 다음과 같다.&lt;/p&gt;
&lt;p&gt;Framework	| Initial run	| Watch run
:--: | :--: | :--:
Jest	| 6.50s	| 5.5s
Vitest	| 5.30s	| 1.25s&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ui.toast.com/weekly-pick/ko_20220111"&gt;스토리북으로 인터랙션 테스트하기&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Storybook 6.4에 추가된 &lt;a href="https://storybook.js.org/blog/interactive-stories-beta/"&gt;Interactive stories&lt;/a&gt;를 사용해 컴포넌트 인터랙션을 자동으로 재생하고, E2E 도구와 결합한 Storybook으로 자동화된 테스트를 작성하는 방법을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://storybook.js.org/blog/541-components-from-styled-components-to-emotion/"&gt;How we migrated 541 components from Styled Components to Emotion with zero bugs&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Storybook 개발팀에서 5개의 코드 베이스에서 Styled Components로 작성된 541개 컴포넌트들의 UI 스타일을 해치지 않으면서 Emotion으로 마이그레이션한 경험을 소개하는 글이다.&lt;/p&gt;
&lt;p&gt;Storybook 팀은 Storybook과 &lt;a href="https://github.com/chromaui"&gt;Chromatic&lt;/a&gt; 프로젝트를 개발하고 있으며, 여러 이유로 인해 각각 다른 스타일 라이브러리를 사용하고 있었다고 한다. Storybook은 Emotion을, 그리고 Chromatic은 Styled Components가 사용되었다.&lt;/p&gt;
&lt;p&gt;그러나 디자인 시스템에 기반해 새로운 기능이 추가될 때마다 각각 2개의 프로젝트에 동일하게 적용하는 것은 작업을 느리게 만들었고 이를 해결하기 위해 단일화된 라이브러리 사용을 위해 마이그레이션 작업이 시작되었다고 한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/scopsy/how-we-reduced-our-nodejs-monorepo-build-time-by-70-3oma"&gt;How we reduced our nodejs monorepo build time by 70%&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;24개의 라이브러리와 앱을 관리하는 Yarn workspaces와 Lerna로 구성된 monorepo 환경에서 패키지 관리자인 &lt;a href="https://pnpm.io/"&gt;pNpm&lt;/a&gt;과 Monorepo 빌드 관리 도구인 &lt;a href="https://github.com/nrwl/nx"&gt;Nx&lt;/a&gt;를 사용해, 빌드 시간을 기존보다 70% 감소시킨 경험을 소개한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;패키지 관리자와 Monorepo 빌드 관리 도구에 대한 벤치마크가 궁금하다면 다음을 추가로 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pnpm.io/benchmarks"&gt;Benchmarks of JavaScript Package Managers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vsavkin/large-monorepo"&gt;Nx vx Turborepo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://risingstars.js.org/2021/en"&gt;2021's JavaScript Rising Stars&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2021년 1년간 증가한 Github 별 숫자에 의한 순위를 보여주는 사이트이다. 2021년 한 해 동안의 JavaScript 개발자의 관심사를 살펴볼 수 있다.&lt;/p&gt;
&lt;p&gt;2016년부터 정보가 있으니 연도별도 살펴보는 것도 재미있을 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/getify/monio/blob/master/MONADS.md"&gt;MONADS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You Don't Know JS라는 유명한 책의 저자 Kyle이 함수형 프로그래밍의 Monad를 소개한 쓴 글이다.
JavaScript로 예시 코드가 짜여있어 Front-end 개발자라면 좀 더 친숙하게 읽을 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=z3odPLDCyLo"&gt;DEVS ANSWER: Kent C. Dodds&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Front-end 개발과 React 생태계에서 어느 정도의 시간을 보낸 사람들이라면, &lt;a href="https://kentcdodds.com/"&gt;Kent C. Dodds&lt;/a&gt;의 명성에 대해서는 한 번쯤은 들어봤을 것이다.&lt;/p&gt;
&lt;p&gt;이 영상은 기술적인 내용보다는 '최신 기술 습득을 위한 좋은 방법', '개발자에게 가장 중요한 점' 등에 대한 질문들을 통한 답변을 통해 Kent C. Dodds의 생각을 엿볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ridicorp.com/story/react-refactoring-ridibooks-web/"&gt;React 리팩토링, 10년 넘은 리디북스 웹도 OK&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;오래되고 낡은 기술 스택으로 이루어진 대규모의 프로젝트를 요즘의 기술 스택으로 리팩토링하는 작업은 고민해야 할 점이 정말 많다.
이 글은 위와 같은 상황에서 어떤 고민을 했고 어떤 방식으로 이것을 해결했는지, 여러 측면에서 리팩토링 노하우를 제시하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@teo/Javascript%EC%97%90%EC%84%9C%EB%8F%84-SOLID-%EC%9B%90%EC%B9%99%EC%9D%B4-%ED%86%B5%ED%95%A0%EA%B9%8C"&gt;JavaScript에서도 SOLID 원칙이 통할까?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;객체지향 소프트웨어 설계 원칙에 있어 SOLID는 유지 보수가 쉽고 확장이 용이한 시스템을 만들고자 할 때 고민해 봐야 하는 원칙 중에 하나이다.
태생이 객체지향을 기반으로 되어 있기 때문에 JavaScript에 적용하기 애매모호한 부분들에 대해 의도에 중점을 두어 코드와 함께 설명한다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dev.to/northwillov/10-popular-javascript-methods-implemented-from-scratch-1ohk"&gt;10 Popular JavaScript methods implemented from scratch&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript에서 자주 사용되는 10개의 메서드들을 직접 처음부터 구현하는 방법을 소개하며, 이를 통해 각각의 메서드들이 내부에서 어떻게 동작하는지를 조금 더 깊게 이해할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;일례로 &lt;code&gt;Array.prototype.map()&lt;/code&gt;은 다음과 같이 구현할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const fakeMap = function (callback) {
  const newArray = [];

  // 'this' refers to the array
  for (let i = 0; i &amp;lt; this.length; i++) {
    newArray[i] = callback(this[i], i);
  }

  return newArray;
};
Array.prototype.fakeMap = fakeMap;

[1, 2, 3].fakeMap((n) =&amp;gt; n + 1); // output [2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://dev.to/craigmorten/how-to-code-live-browser-refresh-in-deno-309o"&gt;Create Your Own Live Browser Refresh In Deno&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이제 개발 환경에서 HMR과 같이 코드 변경을 감지하고 변화를 반영하기 위해 자동으로 새로 고침해 주는 기능은 기본적이 되었다. 혹시 이 과정에 대해 궁금했던 적이 있었는가?&lt;/p&gt;
&lt;p&gt;이 튜토리얼은 Deno에서 브라우저가 자동으로 새로 고침되는 기본적인 환경 개발을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://2ality.com/2022/01/structured-clone.html"&gt;structuredClone(): deeply copying objects in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript에서 객체를 복사하는 가장 일반적인 방법은 spread 연산자를 사용하는 것이다. 그러나 spread 연산자는 최상위 레벨은 복사하지만, 속성 값들은 공유되는 얕은(shallow) 복사를 수행한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const obj = {id: 'e1fd960b', values: ['a', 'b']};
const clone1 = {...obj};

clone1.id = 'yes';
clone1.values.push('x');

obj.id; // 'e1fd960b'
obj.values; // ['a', 'b', 'x']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ECMAScript의 공식 명세에 포함되어 있지 않지만(포함에 대한 &lt;a href="https://github.com/tc39/ecma262/issues/2555"&gt;논의는 진행&lt;/a&gt;),
대다수의 플랫폼(Chrome 98, Safari 137 (TP), Firefox 94, Node.js 17, Deno 1.14)들이 지원하는 전역 메서드인 &lt;code&gt;structuredClone()&lt;/code&gt;을 사용하면 객체의 깊은(deep) 복사가 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const obj = {id: 'e1fd960b', values: ['a', 'b']};
const clone2 = structuredClone(obj);  // 깊은 obj 객체의 복사
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/playlist?list=PLM88opVjBuU7xSRoHhs3hZBz3JmHHBMMN"&gt;Make an OS with ReactJS &amp;amp; Next.js&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;데스크톱 환경을 React와 Next.js를 사용해 브라우저에서 구현한 &lt;a href="https://github.com/DustinBrett/daedalOS"&gt;daedalOS&lt;/a&gt; 프로젝트 개발을 라이브 코딩으로 하나씩 완성해 가는 과정을 확인해 볼 수 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/gitbrent/PptxGenJS"&gt;PptxGenJS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;MS PowerPoint, Apple Keynote와 호환되는 OOXML(Open Office XML) 포맷의 프레젠테이션을
만들 수 있는 라이브러리다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import pptxgen from &amp;quot;pptxgenjs&amp;quot;;

// 1. Create a new Presentation
let pres = new pptxgen();

// 2. Add a Slide
let slide = pres.addSlide();

// 3. Add one or more objects (Tables, Shapes, Images, Text and Media) to the Slide
let textboxText = &amp;quot;Hello World from PptxGenJS!&amp;quot;;
let textboxOpts = { x: 1, y: 1, color: &amp;quot;363636&amp;quot; };
slide.addText(textboxText, textboxOpts);

// 4. Save the Presentation
pres.writeFile();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://component.gallery/"&gt;The Component Gallery&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;컴포넌트 기반의 사용자 인터페이스 개발시 참고할 수 있는 다양한 컴포넌트들과 디자인 시스템들을 모아놓은 곳이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://layout.bradwoods.io/"&gt;CSS Layout Generator&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;간단하게 페이지 레이아웃 구성을 만들 수 있도록 도와주는 온라인 도구&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/pubkey/rxdb"&gt;RxDB&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;RxDB(Reactive Database)는 다양한 형태의 애플리케이션을 위한 NoSQL 데이터베이스로, 여기서 'Reactive'란 현재 상태를 질의할 수 있을 뿐만 아니라 모든 상태 변화에 대한 구독도 가능하다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://chrome.google.com/webstore/detail/responsive-viewer/inmopeiepgfljkpkidclfgbgbmfcennb/related"&gt;Responsive Viewer&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;크롬 개발 툴에도 뷰 사이즈를 조정할 수 있지만 이 크롬 익스텐션을 사용하면 여러 개의 반응형 화면을 한꺼번에 볼 수 있다.
자신이 만든 서비스가 다양한 환경에서 어떻게 보이는지 보고 싶다면 이 크롬 익스텐션을  이용해 보길 바란다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://princejs.com/"&gt;PrinceJS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Prince_of_Persia"&gt;페르시아 왕자&lt;/a&gt;라는 PC 게임 초창기(90대 초)에 인기를 떨쳤던 게임을 JavaScript로 구현했다. PC 게임 추억과 함께 JavaScript의 전파력을 함께 느껴보기 바란다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 원 게임 개발자인 조던 매크너가 페르시아 왕자를 포함, 자신이 개발했던 게임들에 대한 개발일지를 일기 형식으로 기록한 책을 발간하기도 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://book.naver.com/bookdb/book_detail.naver?bid=7362406"&gt;페르시아의 왕자 조던 메크너의 게임 개발일지 1985~1993&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/antonmedv/fx"&gt;fx&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;CLI에서 JSON 객체를 손쉽게 다룰 수 있는 도구&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/futurepress/epub.js"&gt;Epub.js&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;전자책 포맷인 &lt;a href="http://www.idpf.org/epub/30/spec/epub30-overview.html"&gt;ePub 문서&lt;/a&gt;를 브라우저에서 렌더링 할 수 있게 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://futurepress.github.io/epubjs-reader/"&gt;샘플 문서: Moby-Dick&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content></entry><entry><title>2021-01</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-01.md</id><updated>2021-01-06T07:14:13+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-01.md" rel="alternate"/><published>2021-01-01T09:43:55+00:00</published><content type="html">&lt;h1&gt;2021-01 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;2020년과 이후 JavaScript의 동향 - 라이브러리와 프레임워크&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://d2.naver.com/helloworld/7226235"&gt;1편&lt;/a&gt;, &lt;a href="https://d2.naver.com/helloworld/6951656"&gt;2편&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;React, Angular, Vue.js 그리고 Svelte의 최근 동향을 다루는 글로, 다양한 프레임워크들의 기술적 변화와 차이점 들을 다루고 있어 여러 프레임워크들의 동향을 한눈에 파악할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지난 &amp;quot;라이브러리와 프레임워크 동향&amp;quot; 시리즈: &lt;a href="https://d2.naver.com/helloworld/7229119"&gt;2017&lt;/a&gt;, &lt;a href="https://d2.naver.com/helloworld/3259111"&gt;2018&lt;/a&gt;, 2019(&lt;a href="https://d2.naver.com/helloworld/7700312"&gt;1편&lt;/a&gt;, &lt;a href="https://d2.naver.com/helloworld/2108442"&gt;2편&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html"&gt;React Server Component&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React Server Component에 대한 영상이 React 공식 블로그에 공개되었다.
현재는 아직 연구 중인 단계이지만 그 가능성에 대해 많은 설명을 하고 있다.
클라이언트 번들 사이즈를 줄이고 backend 자원에 직접 접근할 수 있는 React Server Component에 대한 글과 영상이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;발표 이후 &lt;a href="https://news.ycombinator.com/item?id=25497065"&gt;해커뉴스&lt;/a&gt;에서도 질문이 끝이지 않고 있다. Dan Abramov에게 궁금증이 있다면 여러분도 지금 답을 얻을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] React 코어 개발팀의 Dan Abromov 트윗에서는 Server Component에 대한 주요 내용에 대한 요약을 확인해 볼 수 있다.&lt;br /&gt;
https://twitter.com/dan_abramov/status/1342261577475633154&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Deview 2020&lt;/h2&gt;
&lt;p&gt;Deview 2020 &lt;a href="https://d2.naver.com/news/5751902"&gt;발표 영상&lt;/a&gt;이 공개되었다.&lt;/p&gt;
&lt;p&gt;그 중 웹 세션 발표 중 국내와 해외에서 각기 다른 이유로 BFF (Backend for Frontend) 아키텍쳐로의 전환 경험을 다루고 있어 소개한다.&lt;/p&gt;
&lt;h3&gt;GraphQL&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://deview.kr/2020/sessions/337"&gt;GraphQL이 가져온 에어비앤비 프론트앤드 기술의 변천사(부제: REST환경에서 GraphQL 기반 UI 설계하기)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에어비엔비에 GrahphQL을 도입하면서 BFF 아키텍쳐 구조를 만들어간 경험을 공유한 발표이다.&lt;/li&gt;
&lt;li&gt;GraphQL 운영 경험에 대한 구체적인 경험이 궁금하시다면 &lt;a href="https://deview.kr/2020/sessions/347"&gt;GraphQL API 까짓거 운영해보지 뭐&lt;/a&gt; 발표를 보시는 것도 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3&gt;Server-Side Rendering&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://deview.kr/2020/sessions/403"&gt;어서와, SSR은 처음이지? (네이버 블로그 Node.js 기반의 Server-Side Rendering 적용기)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네이버 블로그에 SSR을 도입하면서 BFF 아키텍처 구조를 만들어간 경험을 공유한 발표이다.&lt;/li&gt;
&lt;li&gt;SSR을 구축하기 위한 구체적인 경험이 궁금하시다면 &lt;a href="https://deview.kr/2020/sessions/351"&gt;리액트 개발이 이렇게 쉬웠나? (feat. Next.js)&lt;/a&gt; 발표를 보시는 것도 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 외에도 Deview 2020에서 FrontEnd 경험을 다룬 다양한 세션이 있으니 살펴보기 바란다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;strong&gt;Deview 2020 FrontEnd 세션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/378"&gt;묻고 한 벌로 가! (네이버 플레이스 한 벌의 코드로 모바일 웹/모바일 앱/PC 웹 서비스 확장 개발기)&lt;/a&gt;&lt;br /&gt;
React로 만들어진 네이버 플레이스 서비스를 지도앱과 Angular 기반의 서비스에 통합시켰던 경험을 소개한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/361"&gt;WebXR API를 이용한 웹 AR 개발, 그 한계와 대안&lt;/a&gt;&lt;br /&gt;
현 시점에서 WebXR API를 적용하는 장점과 한계점들을 살펴보고 이를 대체할 수 있는 다른 방법들을 설명한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/392"&gt;깃헙 4.4K 스타 billboard.js 메인테이너가 들려주는 오픈소스 개발기(부제: 톨먼이형!, 오픈소스 개발은 왜 이래?)&lt;/a&gt;&lt;br /&gt;
네이버 오픈소스 차트 라이브러리인 billboard.js 프로젝트의 개발과 운영 경험을 통해 지속 가능한 오픈소스 메인테이너스를 위한 경험을 소개한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/358"&gt;Deno 를 통해 알아보는 Javascript 세상 이야기&lt;/a&gt;&lt;br /&gt;
Deno 에 대하여 알아보며 JavaScript 에서 TypeScript, Node.js에서 Deno 까지 JavScript 세상에서의 불편함을 해결 하고자 했던 기술을 소개한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/346"&gt;성능개선 뛰어들기 (고전적 SSR 성능개선)&lt;/a&gt;&lt;br /&gt;
네이버의 스마트어라운드 성능개선 방향과 그 여정을 소개한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/400"&gt;egjs 오픈 서커스 오신것을 환영합니다&lt;/a&gt;&lt;br /&gt;
복잡한 기능을 구현하기 위해서 오픈소스를 찾는 과정과 오픈소스를 활용하면서 겪을수 있는 실제 사례를 재밌게 배울 수 있는 발표이다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2020/sessions/336"&gt;Recoil: 왕위를 계승하는 중입니다&lt;/a&gt;&lt;br /&gt;
Recoil이 Redux의 굳건한 왕좌를 위협할 것이라고 생각하는 근거에 대해서 얘기하고 단계별로 준비된 4가지 예제를 통해 Recoil의 단순하지만 강력한 기능을 간략하게 배워가는 발표이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Chrome Dev Summit 2020 영상 발표&lt;/h2&gt;
&lt;p&gt;Chrome Dev Summit 2020 세션 &lt;a href="https://www.youtube.com/playlist?list=PLNYkxOF6rcIDzLmWaDwfHVZJl1Q5RFgOR"&gt;발표 영상&lt;/a&gt;이 공개되었다.
CSS 엔진의 low-level api 인 &lt;a href="https://houdini.how/"&gt;Houdini&lt;/a&gt;의 발표부터 PWA, &lt;a href="https://stories.google/"&gt;Web Story&lt;/a&gt;, Performance까지 구글웹플랫폼의 진보된 경험을 보실 수 있다.&lt;br /&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://wit.nts-corp.com/2020/12/28/6240"&gt;새로운 웹페이지 성능 측정 지표 CLS(Cumulative Layout Shift)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;chrome 86 업데이트에서 개발자도구 – Performance 패널 – Experience 섹션에 Cumulative Layout Shift (CLS) 라는 새로운 성능 측정 지표가 생겼다.
Web Vital의 새로운 지표인 CLS에 대해 정리한 글이다.&lt;br /&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jbee.io/react/thinking-about-global-state/"&gt;전역상태 관리에 대한 단상 (stale-while-revalidate)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;전역 상태 관리로 Redux를 즐겨 쓰던 개발자가 더 이상 Redux를 사용하지 않게된 이유와 회고가 담긴 글이다.
React Query, SWR, Apollo와 같은 라이브러리가 추구하는 것과 같이 API 캐싱을 통해 컴포넌트의 응집도와 편의성을 높이는 방법에 대한 고민을 설명하고 있다.&lt;br /&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/ryansolid/the-react-hooks-announcement-in-retrospect-2-years-later-18lm"&gt;The React Hooks Announcement In Retrospect: 2 Years Later&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React Hooks이 소개된 이후 2년이라는 시간이 지났다. 이 글은 그 기간동안 개발자의 경험을 시간 순으로 서술하고 있다.&lt;br /&gt;
2021년에도 끝나지 않은 논쟁에 대한 여러분들 의견은 어떤가요?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.jetbrains.com/lp/javascript-25/"&gt;25 years of JavaScript History&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;IDE로 유명한 JetBrains에서 JavaScript 25주년을 맞이한 JavaScript 역사에서 주목할만한 타임라인 페이지를 공개하였습니다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://youtu.be/n1mdAPFq2Os"&gt;React / GraphQL Course - Build a social media app (MERNG Stack)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MongoDB + Express + React + Node.js + GraphQL 스택으로 만들어 보는 소셜 미디어 앱 튜토리얼이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://youtu.be/XD5sZWxwJUk"&gt;Build your own CANDY CRUSH using JavaScript, HTML and CSS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript, HTML, CSS를 이용하여 드래그 앤 드랍을 구현하고 이를 이용하여 우리에게 유명한 CANDY CRUSH 라는 웹게임을 만들어 보는 영상이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://youtu.be/ZVznzY7EjuY"&gt;NodeJS ZOOM Clone&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;원격 근무에는 빠질수 없는 ZOOM 어플리케이션을 클론해보는 영상이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://estimator.dev/"&gt;estimator.dev&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ES2015을 지원하는 브라우저 비율이 90%를 넘고 있다. 이 사이트는 &lt;code&gt;Modern JavaScript 최적화&lt;/code&gt;를 진행한다면 얼마 만큼의 성능 향상을 기대할 수 있을지를 평가 할수 있는 툴이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://microsoft.github.io/monaco-editor/"&gt;Monaco Editor&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VS Code의 웹 버전. NPM으로 설치해 브라우저에서 VS Code를 이용할 수 있다. 모바일 브라우저는 지원하지 않는다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
</content></entry><entry><title>2021-03</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-03.md</id><updated>2021-03-03T08:18:15+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-03.md" rel="alternate"/><published>2021-02-26T04:02:41+00:00</published><content type="html">&lt;h1&gt;2021-03 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://eyes.nasa.gov/apps/mars2020/"&gt;NASA: PRE-LANDING SIMULATION&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;얼마 전 미국 탐사 로봇이 화성에 착륙했고, NASA는 실시간 착륙 시뮬레이션을 웹에 공개했다.
WebGL 기술이 사용된 이 시뮬레이션에 대해 WebGL의 간판 라이브러리 three.js 개발자가 남긴 트윗이 인상적이다.&lt;/p&gt;
&lt;p&gt;발전된 웹 기술이 이와 같은 다양한 영역에서 사용되는 것은 굉장히 고무적인 일이다.&lt;/p&gt;
&lt;p&gt;(참고로 &lt;a href="https://github.com/nasa?language=javascript"&gt;#이곳&lt;/a&gt;에서 NASA가 JavaScript를 사용하고있는 오픈소스 프로젝트들을 확인해볼 수 있다.)&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://eytanmanor.medium.com/an-architectural-overview-for-web-rtc-a-protocol-for-implementing-video-conferencing-e2a914628d0e"&gt;An architectural overview for WebRTC — A protocol for implementing video conferencing&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;COVID-19 시대에서는 화상 회의 도구들은 이제 필수가 되었다. 웹에서 화상 회의 도구를 개발하기 위해선 WebRTC(Web Real-Time Communication)을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;글의 저자는 단일 명령어 실행만으로 화상으로 코드 작성을 실시간으로 공유할 수 있는 CLI 도구인 &lt;a href="https://github.com/DAB0mB/git-streamer"&gt;Git Streamer&lt;/a&gt; 개발과정을 통해 학습된 화상회의 도구 개발의 기본적 개요/개념들을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://arunmichaeldsouza.com/blog/web-platform&amp;#x27;s-hidden-gems---shape-detection-api"&gt;Web platform's hidden gems - Shape Detection API&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;오늘날 스마트폰은 다양한 영역과 일상생활에서 사용되고 있다. 대표적인 활용 영역들 중 하나는 결제를 위해 QR 코드나 바코드를 읽어내는 페이 등의 시스템이 그러하다.&lt;/p&gt;
&lt;p&gt;웹에서 이러한 시스템을 구현하려면 어떻게 해야 할까? 많은 이들에게 잘 알려지지 않은 &lt;a href="https://github.com/WICG/shape-detection-api"&gt;ShapeDetection API&lt;/a&gt;은 웹에서 QR/바코드, 얼굴인식 그리고 문자인식(OCR)이 가능한 애플리케이션 개발을 가능하게 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://web.dev/shape-detection/"&gt;The Shape Detection API: a picture is worth a thousand words, faces, and barcodes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/karimelghamry/generators-in-javascript-how-to-use-them-372d"&gt;Generators in Javascript: How to use them&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Generator는 일반 함수와 유사하나, 이전 실행이 종료된 지점의 상탯값을 저장하고 요청에 따라  종료된 시점부터 실행을 다시 지속할 수 있도록 만들 수 있는 함수다.&lt;/p&gt;
&lt;p&gt;ES6 명세에 포함되어 있으며, 등장한지 많은 시간이 흘렀다. 그러나 실사용 사례는 아직까지 그에 비례하지 않는 것 같다. 이 글을 통해 다시 한번 기본적 이해와 함께 어떤 경우에 유용하게 사용하면 좋을지 확인해 보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://ko.javascript.info/generators"&gt;JAVASCRIPT.INFO: 제너레이터&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/privatenumber/minification-benchmarks"&gt;JS minification benchmarks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;현재 JavaScript minifier 도구는 과거의 UglifyJS가 defacto 도구로 사용되었던 것과는 다르게 다양한 도구들이 개발되고 있다.&lt;/p&gt;
&lt;p&gt;어떤 것이 가장 빠르게 실행될까? 유명한 프로젝트들의 빌드 파일을 대상으로 수행한 벤치마크 결과를 확인해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/02/things-you-can-do-with-css-today/"&gt;Things You Can Do With CSS Today&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS는 최근 몇 년 동안 정말 빠르게 발전하고 있다. 그만큼 우리가 놓친 유용한 기능들도 많을 것이다.&lt;/p&gt;
&lt;p&gt;이 글에서는 최신 CSS 기술들로 할 수 있는 Masonry layout, &lt;code&gt;:is&lt;/code&gt; selector, CSS function, Aspect ratio 등의 활용적인 기능들에 대해 설명하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/coderslang/series/11099"&gt;Test your JavaScript skills Series' Articles&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript 인터뷰에 자주 등장하는, 헷갈리기 쉬운 문제를 16가지 예제와 함께 정리해 놓은 아티클이다. 차례차례로 읽어본다면 JavaScript에 대한 자신의 기본기를 부담 없이 확인해 보고 향상시킬 수 있을 것이다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://felixgerschau.com/javascript-memory-management/"&gt;JavaScript's Memory Management Explained&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://felixgerschau.com/static/b452488bd7eeac0405c48f164da6280d/29007/stack-heap-pointers.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;JavaScript 코드를 작성하면서 사용하게 되는 변수, 함수, 객체 등은 어디에 어떻게 저장되고 사용될까? 그리고 더 이상 필요 없게 되었을 때 어떻게 GC(Garbage Collection)가 이뤄지게 될까?&lt;/p&gt;
&lt;p&gt;이 글은 JavaScript 메모리 관리에 대한 궁금증을 쉽게 해결해 줄 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://js.plainenglish.io/lets-create-a-chrome-extension-to-add-new-features-to-medium-3da288af710e"&gt;Let’s Create a Chrome Extension To Add New Features To Medium&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹 서비스를 이용 중에 어떤 기능이 추가되면 좋겠다는 생각을 해본 경험이 있는가? Chrome 브라우저를 사용한다면 extension을 개발함으로써 이 문제를 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Chrome extension이 어떻게 동작하는지에 대한 간단한 설명과 실제로 Medium에서 사용할 수 있는 extension에 새로운 기능을 추가하는 예제를 보여주고 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/walmartlabs/json-to-simple-graphql-schema"&gt;json-to-simple-graphql-schema&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON에 동일한 필드를 갖는 2개의 타입이 존재하는 경우:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;id&amp;quot;: &amp;quot;some-id-0&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;A fun object&amp;quot;,
  &amp;quot;color&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;color-id-1&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;Test color&amp;quot;
  },
  &amp;quot;favoriteColor&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;color-id-1&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;Test color&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;앱을 통해 실행되면, 다음의 스키마가 생성된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-graphql"&gt;
type FavoriteColor {
  id: String
  name: String
}

type Color {
  id: String
  name: String
}

type AutogeneratedMainType {
  id: String
  name: String
  favoriteColor: FavoriteColor
  color: Color
}

# Types with identical fields:
# FavoriteColor Color
It called out the two types with identical fields.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON 형태의 데이터를 graphql schema로 변환해 주는 도구이다.&lt;/p&gt;
&lt;p&gt;JSON 기반으로 API 통신하는 프로젝트에 graphql을 적용하는 상황이라면 이 도구가 굉장히 유용하게 쓰일 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.speedtyper.dev/"&gt;&amp;lt;SpeedTyper /&amp;gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;개발자들을 위한 코드 타이핑 학습(게임) 도구로, 실제 오픈소스 프로젝트들의 코드들을 사용한다. 속도와 정확성을 기준으로 다른 이들과 경쟁하거나 코드 타이핑 스킬을 스스로 학습해 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://parallel.js.org/"&gt;Parallel.js&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Parallel.js는 Node.js와 브라우저 환경에서 간단하게 병렬 작업을 수행할 수 있게 만들어 주는 작은 용량(1.49KB - gzipped)의 라이브러리로, Node.js 환경에서는 child processes, 그리고 웹 환경에서는 웹 워커를 사용한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://runjs.app/"&gt;RunJS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Javascript 코드를 작성하고 실행시킬 수 있는 데스크톱 애플리케이션이다.&lt;/p&gt;
&lt;p&gt;기본적으로 typescript를 지원하고 npm 패키지들을 설치해서 사용할 수 있다.
프로토타이핑이나 테스트 등 간단한 작업에 사용하기 알맞아 보인다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.remotion.dev/"&gt;Remotion&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Remotion은 리액트를 사용하여 비디오와 모션 그래픽을 제작할 수 있는 라이브러리다. CSS, Canvas, SVG, WebGL 같은 웹 기술을 사용해 비디오를 만들 수 있다.&lt;/p&gt;
</content></entry><entry><title>2020-06</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-06.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-06.md" rel="alternate"/><published>2020-06-03T01:32:28+00:00</published><content type="html">&lt;h1&gt;2020-06 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://recoiljs.org/"&gt;Recoil: State Management library for React&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;지난 5월 14일 온라인으로 열린 ReactEurope 콘퍼런스에서 페이스북은 새로운 상태 관리자 라이브러리인 Recoil을 공개했다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;발표영상: &lt;a href="https://www.youtube.com/watch?v=_ISAA_Jt9kI"&gt;Recoil: State Management for Today's React&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recoil은 기존 상태 관리자들만으로 해결하기 어려웠던 다음의 문제들을 해결하기 위해 개발되었다고 그 이유를 밝히고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flexible shared state&lt;/li&gt;
&lt;li&gt;Derived data and queries&lt;/li&gt;
&lt;li&gt;App-wide state observation&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;다음의 Egghead에서 제공되는 총 6분 내외의 짧은 온라인 튜토리얼을 통해 기본적인 Recoil의 사용방법을 빠르게 배울 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://egghead.io/playlists/up-and-running-with-recoil-a-new-state-management-library-for-react-78b8"&gt;Up and running with Recoil - a new state management library for React&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2020/04/dark-mode-react-apps-styled-components/"&gt;Implementing Dark Mode In React Apps Using styled-components&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;많은 웹사이트가 다크 모드를 지원하는 추세다.
다크 모드는 사용자의 눈의 피로를 줄여줄 뿐만 아니라 사용자 디바이스의 전력 소모를 줄이는 데에도 도움을 줄 수 있다.
이 글에서는 CSS-in-JS 라이브러리 중 하나인 styled-components를 이용하여 간단하게 React 환경에서 Dark Mode를 구현하는 방법을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://gyujincho.github.io/2018-06-19/AST-for-JS-devlopers"&gt;자바스크립트 개발자를 위한 AST(번역)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;AST(Abstract Syntax Tree)가 무엇인지, 또, 자바스크립트 코드가 어떻게 AST로 변환이 되는지 설명하는 글이다.
AST가 어떻게 활용될 수 있는지 Babel, Prettier 등을 간단하게 예로 들어 보여준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://mariosfakiolas.com/blog/become-a-better-godfather-for-your-react-components/"&gt;Become a better godfather for your React components&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React Component를 디버깅하다 보면 한 번쯤은 React Developer Tools에서 Anonymous Component를 마주한 적이 있을 것이다. 이는 React 디버깅 시 작지 않은 방해 요소다. 이 글에서는 어떻게 하면 Anonymous Component를 피할 수 있는지 간단한 예시와 함께 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://genie-youn.github.io/journal/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C_AbortController%EB%A5%BC_%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC_%EB%B9%84%EB%8F%99%EA%B8%B0_%EC%9E%91%EC%97%85_%EC%A4%91%EB%8B%A8%ED%95%98%EA%B8%B0.html"&gt;자바스크립트에서 AbortController 를 활용하여 비동기 작업 중단하기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;자바스크립트에서 비동기 작업을 도중에 중단하기란 보통 어려운 일이 아니다. 이 글에서는 브라우저의 AbortController API를 이용하여 자바스크립트 비동기 작업을 도중에 중단하는 방법에 대해 예제 코드와 함께 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/lighthouse-whats-new-6.0/"&gt;What's New in Lighthouse 6.0&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Chrome DevTools의 웹 사이트 진단 도구인 Lighthouse가 6.0 버전을 릴리스하였다. Chrome 84 버전부터 탑재 된다고 한다. 이 글에서는 6.0 버전에서 어떤 것들이 바뀌었는지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://uxdesign.cc/text-fields-forms-design-ui-components-series-2b32b2beebd0"&gt;Text fields &amp;amp; Forms design — UI components series&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;FE 개발자들이 빈번하게 개발하는 form. 우리는 그동안 익숙함에 늘 관성적으로 form을 개발하고 있지는 않았는가?&lt;/p&gt;
&lt;p&gt;이 글에서는 form에서 각종 요소들이 어떻게 정렬되는지, 어떻게 위치하고 있는지 등에 따라 장단점을 알려준다. 또한 더 나은 사용자 경험을 위한 form을 만들기 위해 어떤 방법들이 있는지 좋은 사례와 나쁜 사례를 비교하며 자세하게 설명해 준다.&lt;/p&gt;
&lt;p&gt;FE-news를 통해 지난 3월에 공유한 &lt;a href="https://github.com/naver/fe-news/blob/master/issues/2020-03.md#design-better-forms"&gt;Design Better Forms&lt;/a&gt;를 함께 읽어보면 사용자가 이용하기 편리한 form을 만드는데 큰 도움이 될 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/live/"&gt;web.dev - LIVE&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;구글 웹 플랫폼 팀에서 3일(6/30 ~ 7/2) 동안 온라인 이벤트를 진행할 예정이다.&lt;/p&gt;
&lt;p&gt;빌드 도구부터 CSS, 이미지 압축, 크롬 개발자 도구를 활용한 문제점 발견과 해결 방법, PWA를 안드로이드 앱으로 배포하기 등등 웹 개발에 유익한 다양한 모던 웹 기술과 테크닉 세션들이 예정되어 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://keleshev.com/standard-io-under-the-hood"&gt;Standard IO Under the Hood&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;우리가 &lt;code&gt;console.log()&lt;/code&gt;를 사용할 때 실제로는 어떤 과정을 거쳐 호출이 실행될까?&lt;/p&gt;
&lt;p&gt;C++로 작성된 JavaScript 런타임 V8의 코드를 통해 전체 실행 과정에 대한 설명을 확인할 수 있다. C++에 대한 경험이 없다면 이해하기 어려울 수도 있지만, 우리가 매일 작성하는 JavaScript 코드가 어떻게 실행되는가에 대한 호기심을 충족시켜 줄 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://stackoverflow.com/questions/34385243/why-is-immutability-so-important-or-needed-in-javascript/43318963#43318963"&gt;Why is immutability so important (or needed) in JavaScript?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;불변성(Immutability)은 JavaScript에서 필수적이라기보다는 패션 트렌드에 가깝고, React를 사용하는 경우 상태 관리에서 일부 &lt;a href="https://github.com/facebook/react/issues/11527"&gt;혼란스러운 설계&lt;/a&gt;에 대한 깔끔한 해결 방법을 제공할 수 있지만 대부분의 다른 상황에서는 도입에 따른 복잡성이 충분한 가치를 더해주지 못한다는 의견을 밝히고 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;A Visual Guide To React Mental Models&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/"&gt;Part 1&lt;/a&gt;, &lt;a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/"&gt;Part 2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React의 각 특징적 요소들과 동작 방식을 시각적 이미지로 설명한 ‘React Mental Model’ 가이드다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mental Model 이란 우리가 ‘인터넷’을 머릿속으로 떠올렸을 때 그 거대한 네트워크가 어떻게 동작하는지 아주 세세히 알지 못하지만 대략적 동작 방식을 이해하고 관련된 문제를 해결, 개선할 수 있는 사고 과정이라 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;가이드는 React의 기본적 개념과 동작 방식 등을 빠르고 쉽게 훑어볼 수 있도록 시각적 이미지를 활용해, React를 처음 접하는 이들과 전체 흐름을 이해하고자 하는 이들에게 큰 도움을 준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://flaviocopes.com/deno/"&gt;Deno Handbook&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 5월 14일 1.0 버전이 릴리스된 새로운 TypeScript 런타임 Deno에 대한 핸드북을 제공한다. 간결한 소개와 함께 Node.js와의 비교를 통한 차이점, 예제 코드를 통한 사용방법 등을 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=f2mMOiCSj5c"&gt;Deconstructing React || Tejas Kumar&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React API들을 Vanilla JS를 이용해 간단하게 만들어 보며 이해하기 쉽게 설명한다. Virtual DOM(render), Hooks, Suspense에 대해 다룬다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://manojvivek.github.io/responsively-app/"&gt;Responsively&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;반응형 사이트 개발 시, 다양한 크기의 디바이스에서 렌더링 되는 화면을 한 번에 보고 개발할 수 있도록 도와주는 도구로 Electron으로 개발되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://appy-dev.netlify.app/"&gt;Appy Dev&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;수년간의 큐레이션을 통해 수집된 다양한 웹 개발 도구, 유틸리티, 리소스 들의 링크 디렉터리를 제공하며, 리스트에서 확인할 수 있는 몇몇 도구들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://keyframes.app/"&gt;Keyframes&lt;/a&gt;: CSS 애니메이션과 shadow 등의 개발을 도와주는 시각적 도구&lt;/li&gt;
&lt;li&gt;&lt;a href="https://picular.co/"&gt;Picular&lt;/a&gt;: 사용자 입력 키워드를 구글 이미지 검색으로 검색한 결괏값 이미지들에서 사용된 주요 색상 값들을 추출해 제공하는 도구&lt;/li&gt;
&lt;li&gt;&lt;a href="https://htmlhead.dev/"&gt;HEAD&lt;/a&gt;: HTML5 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 요소에 대한 사용 가이드&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://github.com/nikersify/pico"&gt;pico&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;client side에서 스크린숏을 찍는 라이브러리이다. viewport에 맞춰 cross origin image, web fonts 등 headless browser를 이용해서는 얻을 수 없는 정보들을 포함하여 보다 정확하게 스크린숏 찍는 것을 목표로 한다고 한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/framer/motion"&gt;motion&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서 단지 props로 객체를 전달하는 것으로, animation과 gesture를 쉽게 사용할 수 있도록 도와주는 라이브러리이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/bvaughn/react-error-boundary"&gt;react-error-boundary&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React 개발을 하다 보면 간혹 DOM과 sync가 안 맞는 등의 이유로 렌더링 중 에러를 뱉으며 흰 화면이 나타나는 경우를 겪을 수 있다.
이런 예외적인 상황을 대처하기 위해 React v16에서 ErrorBoundary API가 소개되었는데,
이 라이브러리를 이용하면 ErrorBoundary를 좀 더 쉽게 사용할 수 있다.&lt;/p&gt;
</content></entry><entry><title>2021-06</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-06.md</id><updated>2021-06-02T02:20:32+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-06.md" rel="alternate"/><published>2021-05-24T05:11:11+00:00</published><content type="html">&lt;h1&gt;2021-06 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://designsystemsrepo.com/"&gt;Design Systems Repo&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;최근 들어 디자인 시스템에 대한 관심이 많아지고 있고, 그에 비례해 다양한 디자인 시스템들이 공개되고 있다. 그러나 잘 만들어진 디자인 시스템을 검색하고 찾아보는 것은 쉽지 않다.&lt;/p&gt;
&lt;p&gt;Design System Repo에서는 여러분들이 영감받을 수 있는 큐레이션 된 다양한 디자인 시스템 목록과 스타일 가이드, 패턴 라이브러리 그리고 관련 문서와 컨퍼런스 등, 디자인 시스템과 관련된 방대한 리소스 들을 찾아볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.mgaudet.ca/technical/2021/5/4/implementing-private-fields-for-javascript"&gt;Implementing Private Fields For JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Firefox JavaScript 엔진인 &lt;a href="https://spidermonkey.dev/"&gt;SpiderMonkey&lt;/a&gt; 팀에서 일하고 있는 저자는 새로운 JavaScript 언어의 기능을 구현할 때 제정된 명세의 구현 과정에서의 현실적 어려움(언어 규격을 벗어나는 등의)을 다루는 글이다.&lt;/p&gt;
&lt;p&gt;저자는 class field proposal을 통해 제안된 &lt;a href="https://github.com/tc39/proposal-class-fields#private-fields"&gt;Private fields&lt;/a&gt; 예를 통해 명세와 구현의 현실적 차이를 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/leaningtech/a-javascript-optimizing-compiler-3fd3f49bd071"&gt;A JavaScript optimizing compiler&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript 코드를 최적화된 JavaScript로 컴파일 하는 실험적 시도에 관한 흥미로운 글로, 대상 JavaScript 코드를 LLVM 중간 표현식(Intermediate Representation)으로 변환한 후, 최적화된 IR(중간 표현식)을 통해 다시 JavaScript 코드를 생성하는 접근 방식을 취한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최적화에 대한 결과는 아래 링크를 통해 직접 벤치마크를 수행해 볼 수 있다.&lt;!-- raw HTML omitted --&gt;
https://carlopi.github.io/js-opt-benchmark/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://leerob.io/blog/react-state-management"&gt;Past, Present, and Future of React State Management&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2013년 등장한 React는 UI의 상태를 표현하는 함수라는 패러다임 전환을 가져왔고, React는 컴포넌트가 어떻게 보이게 될지를 상태에 기반해 처리한다. 이처럼 React는 '상태'라는 아이디어에 기반해 만들어졌다 할 수 있다.&lt;/p&gt;
&lt;p&gt;글의 저자는 과거와 오늘날에 이르기까지 등장했던  다양한 상태 관리자들과 기본적 개념들과 어떤 문제들을 해결하고자 했는지를 포괄적으로 다루고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://events.google.com/io/program/content?4=topic_web&amp;amp;lng=ko"&gt;Google I/O 2021: Web 영역&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;구글의 연례 개발자 행사인 Google I/O 2021이 지난 5월 18일 ~ 20일, 3일간 진행되었고, 다채로운 내용들이 발표되었다.
Front-end 영역 관점에서, 웹 영역 세션들을 통해 구글이 어떤 기술 영역에 집중하고 있는지를 가늠해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/jung-han/%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%A7%80%ED%91%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-83df3dc96fb9"&gt;라이트하우스 성능 지표 살펴보기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹 품질 측정을 위한 도구로는 여러 도구가 있겠지만, 그중 가장 유명한 것은 단연 구글에서 제공하는 Lighthouse 일 것이다.&lt;/p&gt;
&lt;p&gt;Lighthouse를 이용하면 어렵지 않게 웹 품질을 측정하고 확인할 수 있는데, 이때 측정 결과는 여러 지표들의 점수로서 나타나게 된다. 각 지표의 점수가 높을수록 좋다는 것은 직관적으로 알 수 있지만, 각 지표의 정확한 의미를 알기는 조금 어려울 수 있다.&lt;/p&gt;
&lt;p&gt;본 글에서는 Lighthouse의 각 지표들의 의미를 그림과 함께 알기 쉽게 설명하여 이해를 돕는다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://abseil.io/resources/swe-book"&gt;Software Engineering at Google&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;O'Reilly에서 출간한 Software Engineering at Google 책이 PDF 파일로 무료 공개되었다.&lt;/p&gt;
&lt;p&gt;소프트웨어 엔지니어링이란 무엇인가라는 근본적인 내용부터 시작하여 팀으로 일하기, 지식 공유하기 등 전반적인 소프트웨어 엔지니어링에 대해 다룬다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/technogise/journey-of-improving-react-app-performance-by-10x-9195d4b483d4"&gt;Journey of Improving React App Performance by 10x&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React Application의 성능을 향상시켰던 방법을 알려준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;render&lt;/code&gt;에서 inline 함수 제거&lt;/li&gt;
&lt;li&gt;상태가 변경되는 경우만, Redux Store 업데이트&lt;/li&gt;
&lt;li&gt;조건부 렌더링 적용&lt;/li&gt;
&lt;li&gt;불필요한 &lt;code&gt;await&lt;/code&gt;을 제거하고 적용 가능하면 &lt;code&gt;Promise.all()&lt;/code&gt; 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"&gt;The future of Internet Explorer on Windows 10 is in Microsoft Edge&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MS에서 Windows 데스크톱의 IE 지원을 2022년 6월 15일부로 종료하겠다고 공식 발표하였다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years"&gt;Modern Javascript: Everything you missed over the last 10 years (ECMAScript 2020)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ECMAScript는 매년 새 버전을 발표하며 빠르게 변화하고 있어 최신 기술 스펙을 놓치기에 십상이다. 최근 10년 동안의 새로 발표된 내용들을 한곳에 모아 보기 쉽게 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://web.dev/learn/css/"&gt;Learn CSS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;구글의 &lt;a href="https://web.dev/"&gt;web.dev&lt;/a&gt; 팀에서 공개한 튜토리얼로, CSS의 기본적인 내용들을 이해하기 쉽게 항목들을 세분화하고 CSS를 효과적으로 사용하는 방법을 설명한다. 박스 모델, 셀렉터, 크기 단위, 플렉스 박스, 가상 요소/클래스 등 거의 모든 CSS 스펙들을 다루며, 각각의 항목들은 관련 podcast와 인터랙티브 데모가 제공된다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/"&gt;Building A Rich Text Editor (WYSIWYG)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;커스텀 가능한 리치 텍스트 편집기를 만들 수 있는 JavaScript 라이브러리 &lt;a href="https://github.com/ianstormtaylor/slate"&gt;Slate&lt;/a&gt;를 사용해 위지윅(WYSIWYG) 편집기를 구현하는 방법을 상세히 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/how-to-create-actions-for-selected-text-with-the-selection-api/"&gt;How to Create Actions for Selected Text With the Selection API&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;텍스트 에디터에서 문장 선택 시, 선택 영역 위에 메뉴가 나타나는 것을 본 적이 있을 것이다. 웹에서는 어떻게 이것을 구현할 수 있을까? 다소 생소할 수 있는 API인 Selection API를 이용하여 이를 웹에서 구현하는 방법을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://codingfantasy.com/"&gt;Coding Fantasy: Learn Flexbox by Playing a Coding Game&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;flexbox를 이용하면 레이아웃 작업을 비교적 쉽게 진행할 수 있다. 게임을 통해 flexbox 개념을 학습할 수 있도록 돕는다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/05/get-started-whac-a-mole-react-game/"&gt;Get Started With React By Building A Whac-A-Mole Game&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React를 이용해 두더지 잡기(Whac-A-Mole) 게임을 만들어본다. React의 기초부터 하나씩 구현을 진행한다. 기초 개념들도 함께 설명해 주기 때문에 React 입문자도 따라 해보기 좋다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/NotionX/react-notion-x"&gt;React Notion X&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;인기를 끌고 있는 메모 애플리케이션인 Notion의 콘텐츠를 React로 렌더링 할 수 있게 하는 TypeScript로 작성된 도구다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;# 1) Notion 콘텐츠를 얻어온다.
import { NotionAPI } from 'notion-client'

const notion = new NotionAPI()
const recordMap = await notion.getPage('067dd719a912471ea9a3ac10710e7fdf')

# 2) 얻어온 콘텐츠를 React를 통해 렌더링한다.
import React from 'react'
import { NotionRenderer } from 'react-notion-x'

export default ({ recordMap }) =&amp;gt; (
  &amp;lt;NotionRenderer recordMap={recordMap} fullPage={true} darkMode={false} /&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예를 들어, 다음의 Notion 콘텐츠를&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://www.notion.so/Notion-Kit-Test-Suite-067dd719a912471ea9a3ac10710e7fdf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;React 애플리케이션에서 로딩해 다음과 같이 웹사이트를 만들 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://react-notion-x-demo.transitivebullsh.it/&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://github.com/mechaniac/Map-of-Javascript"&gt;Map of JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript와 HTML, DOM 그리고 JavaScript에서의 데이터구조와 알고리즘을 각각 한장의 Map 이미지 형태로 확인해 볼수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://wwit.design/"&gt;WWIT&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;최신 iOS 앱들의 UI 디자인 패턴들의 스크린숏 모음을 제공하는 &lt;a href="https://mobbin.design/"&gt;Mobbin&lt;/a&gt;에 영감을 받은 &lt;code&gt;WWIT(What Was IT)&lt;/code&gt;은 한국에서 개발된 iOS 모바일 디자인 패턴들에 대한 스크린숏을 모아서 볼 수 있도록 제공한다.&lt;/p&gt;
&lt;p&gt;iOS 앱들이라 하더라도 많은 경우 상세 화면들은 웹뷰를 통해 구현되는 경우가 많아, Front-end 관점에서도 UI/UX에 대한 영감을 얻을 수 있어 참고할만하다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.screensizes.app/"&gt;Screen Sizes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;다양한 Apple 기기들에 대한 세밀한 디스플레이 정보를 한눈에 확인해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://csshell.dev/"&gt;CSS Hell&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;일반적인 CSS 오류들에 대한 모음과 수정 방법을 제공한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.stackblitz.com/posts/introducing-webcontainers/"&gt;Introducing WebContainers: Run Node.js natively in your browser&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Node.js 환경을 브라우저에서 실행할 수 있게 되었다. 심지어 로컬 환경보다 빌드 및 패키지 설치가 빠르며, 브라우저 샌드박스 안에서 실행되므로 안전하다고 한다.&lt;/p&gt;
&lt;p&gt;public beta 버전이긴 하나, &lt;a href="https://stackblitz.com/"&gt;이곳&lt;/a&gt;에서 직접 사용해 볼 수 있다.&lt;/p&gt;
</content></entry><entry><title>2020-04</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-04.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-04.md" rel="alternate"/><published>2020-03-27T07:20:13+00:00</published><content type="html">&lt;h1&gt;2020-04 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dev.to/gregfletcher/top-front-end-development-youtube-channels-4ihg"&gt;Top Front-End Development YouTube Channels&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;YouTube에는 다양한 FE 기술 콘텐츠들이 넘쳐나지만 그들 중 보석을 가려 내는 것은 쉽지 않다. 수준 높은 콘텐츠를 찾고 있다면 링크에서 소개하는 채널들은 큰 도움이 될 것이다.&lt;/p&gt;
&lt;p&gt;JavaScript로 파서, 가상머신 등 로우 레벨 영역 구현을 소개하는  '&lt;a href="https://www.youtube.com/channel/UC56l7uZA209tlPTVOJiJ8Tw"&gt;Low Level JavaScript&lt;/a&gt;', 다양한 CSS 레이아웃들의 기술적 내용들을 다루는 '&lt;a href="https://www.youtube.com/channel/UC7TizprGknbDalbHplROtag"&gt;LayoutLand&lt;/a&gt;' 등의 채널들을 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://uxdesign.cc/10-rules-of-thumb-in-ui-design-aa5f91885444"&gt;10 Rules Of Thumb In UI Design&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;UI에서 따르면 좋을 가이드 10가지를 제시하고 있다.  최전방에서 UI를 개발하는 FE 개발자가 숙지하고 있으면 좋은 내용들이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://brunch.co.kr/@cliche-cliche/32"&gt;뉴모피즘은 새로운 UI 트렌드가 될 수 있을까?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;시대에 따라 UI 트렌드는 변한다. 2000년대 후반에는 현실의 사물성을 그대로 표현하는 '스큐어모피즘'(Skeuomorphism)이 유행했다. 그 이후 iOS 7을 기점으로 플랫 한 디자인이 대세가 되었고, 현재는 플랫 한 디자인에 그림자를 더한 구글의 머티리얼 디자인이 UI 트렌드를 주도하고 있다. 이다음엔 어떤 UI 트렌드가 시장을 지배할까?&lt;/p&gt;
&lt;p&gt;'뉴모피즘'(&lt;a href="https://uxdesign.cc/neumorphism-in-user-interfaces-b47cef3bf3a6"&gt;Neumorphism&lt;/a&gt;)이라고 불리는 새로운 디자인 스타일이 대두되고 있는 요즘, 이것이 구체적으로 어떤 스타일이고 앞으로 UI 트렌드를 이끌어 나갈 수 있을지 가능성과 한계에 대해 위 글에서 확인해보자.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://levelup.gitconnected.com/@janvidar"&gt;Functional Programming for JavaScript Developers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;자바스크립트 개발자를 위한 함수형 프로그래밍에 대한 시리즈 글을 확인할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;오래전에 공개된 글이긴 하지만, 다음의 시리즈도 함수형 프로그래밍 사고적 방법으로의 접근에 도움을 얻을 수 있다.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536#.j86p4zvzs"&gt;So You Want to be a Functional Programmer&lt;/a&gt; (&lt;a href="https://fedevelopers.github.io/tech.description/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%8B%B6%EB%8B%A4%EA%B3%A0-(Part-1)/"&gt;한글 번역&lt;/a&gt;)&lt;!-- raw HTML omitted --&gt;
(*원문은 총 6개 시리즈 글로 작성되었지만, 한글 번역은 5회까지 진행되었다.)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://medium.com/better-programming/10-productivity-tools-for-front-end-developers-4021cdef6fcb"&gt;Front-End Dev Tools For increased Productivity&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;FE 개발자들이 UI/UX 작업을 보다 빠르고 효율적으로 진행할 수 있게 도와줄 수 있는 10여 개의 온라인 도구들을 소개한다.
 &lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/javascript-in-plain-english/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e"&gt;An abbreviated history of JavaScript package managers&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 글은 패키지 매니저인 npm, Yarn 그리고 pnpm의 등장 배경과 함께 어떤 문제들을 해결했는지에 대해 시간적 흐름에 따라 발전되온 패키지 매니저들의 간략한 역사를 다루고 있다.&lt;/p&gt;
&lt;p&gt;가령 npm은 v1에서 Dependency hell을 해결하기 위해 등장했고, 이후 v3에서는 Flattened dependency 관리로 깊어지는 서브 디렉터리 문제 해결을 위함 이었다는 내용들을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d"&gt;5 Questions Every Unit Test Must Answer&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;대부분의 개발자들은 단위 테스트를 작성해야 하는 사실은 잘 알고 있지만, 많은 경우 단위 테스트의 필수 요소들은 무엇인지 잘 알지 못한다는 점이다. 해당 글에서는 저자 자신의 실제 경험을 기반으로 실패하지 않는 좋은 테스트를 작성하기 위해 스스로 질문해 봐야 하는 다음의 5가지 항목들을 소개한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What are you testing?&lt;/li&gt;
&lt;li&gt;What should it do?&lt;/li&gt;
&lt;li&gt;What is the actual output?&lt;/li&gt;
&lt;li&gt;What is the expected output?&lt;/li&gt;
&lt;li&gt;How can the test be reproduced?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet"&gt;React+TypeScript Cheatsheets&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript와 React를 사용한 프로젝트 개발에서 참고할 수 있는 실행 가이드(Cheat Sheet)를 제공한다. 총 4개로 분류된 가이드를 제공해 각자 필요성에 따른 접근이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/blob/master/README.md#basic-cheatsheet-table-of-contents"&gt;Basic&lt;/a&gt;: React 개발자의 TS 적용을 위한 기본 가이드&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/blob/master/ADVANCED.md"&gt;Advanced&lt;/a&gt;: 고급 사용과 재사용 가능한 코드 작성 가이드&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/blob/master/MIGRATING.md"&gt;Migrating&lt;/a&gt;: Plain JS, Flow 코드들의 TS 마이그레이션 가이드&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/blob/master/HOC.md"&gt;HOC&lt;/a&gt;: 고차함수(High Order Component) 작성 가이드&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://twitter.com/deno_land/status/1244707313006624772"&gt;Deno 1.0 will be released May 13, 2020&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Node.js를 개발했던 Ryan Dahl이 2018년 새롭게 시작했던 TypeScript 런타임 엔진인 &lt;a href="https://github.com/denoland/deno"&gt;Deno&lt;/a&gt; 1.0 버전의 공개가 5월 13일 릴리스될 예정이라고 트윗을 통해 밝혔다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://lab.github.com/"&gt;GitHub Learning Lab&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;GitHub는 지난 2018년 4월 GitHub의 사용방법들을 배울 수 있는 온라인 교육 도구인 &lt;a href="https://github.blog/2018-04-19-introducing-github-learning-lab/"&gt;GitHub Learning Lab을 발표&lt;/a&gt;했었다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=9S0p8YMQzsM"&gt;GitHub Learning Lab 소개영상&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;현재는 GitHub 사용방법에 국한하지 않고 도구와 언어(Python, Node, Java, Ruby, TensorFlow 등),  DevOps 등의 다양한 코스가 추가되었고 모두 무료로 학습할 수 있다.&lt;/p&gt;
&lt;p&gt;다른 온라인 교육 서비스들 보다 좋은 점은 바로 GitHub 플랫폼에 기반해 교육이 진행된다는 점으로, 선택한 코스는 자신의 GitHub 저장소로 clone 되고 이후 과정은 자동으로 등록되는 이슈와 PR 등을 통해 진행된다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/better-programming/react-router-v6-in-two-minutes-a7a2963e2340"&gt;React Router v6 in Three Minutes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React Router의 차기 메이저 버전인 v6의 새로운 변화들을 소개한다. 가장 큰 변화로는 번들 크기가 이전 버전(v5)에 비해 ~70% 용량이 감소되었고, 새로운 Hooks 및 컴포넌트들의 변화에 대한 내용을 소개한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;현재 시점에서의 v6 최신 버전은 지난 2월 공개된 &lt;a href="https://github.com/ReactTraining/react-router/releases/tag/v6.0.0-alpha.2"&gt;v6.0.0-alpha.2&lt;/a&gt; 이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://www.bram.us/2020/01/10/smooth-scrolling-sticky-scrollspy-navigation/"&gt;Smooth Scrolling Sticky ScrollSpy Navigation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;사이드 바 내비게이션을 통해 페이지 내 원하는 지점으로 부드러운 페이지 스크롤을 통해 이동하는 페이지 구성 방법을 소개한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;완성된 데모: https://codepen.io/bramus/pen/ExaEqMJ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/ahmadawais/corona-cli"&gt;corona-cli&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;COVID-19 전 세계 확산에 따라, 관련 도구들이 개발되어 공개되고 있다. 이들 중, &lt;code&gt;corona-cli&lt;/code&gt;는 프롬프트 환경(CLI)에서 간단하게 전 세계 국가들의 현재 지표 값을 확인할 수 있게 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;$ npm i -g corona-cli ## 또는 설치없이 한번만 실행하고 싶다면 'npx corona-cli'
$ corona # 전세계 통계 출력
$ corona &amp;lt;국가명&amp;gt; # 한국의 상황은 'corona korea'를 실행
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;관련된 다음의 프로젝트들도 함께 참고해 보면 좋다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/pomber/covid19"&gt;covid19&lt;/a&gt;
매일 3차례 GitHub Action을 통해 업데이트되는 COVID-19 시계열 JSON 포맷 데이터
https://pomber.github.io/covid19/timeseries.json&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/soroushchehresa/awesome-coronavirus"&gt;Awesome Coronavirus&lt;/a&gt;
기술, 도구 등의 유용한 리소스들을 모아서 제공하는 &amp;quot;Awesome&amp;quot; 큐레이션의 형태와 같이 COVID-19 관련 개발 리소스들의 목록을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/vsls-contrib/codetour"&gt;CodeTour&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CodeTour는 VS Code 익스텐션으로, 사용자의 코드 베이스를 기반으로 한 인터랙티브 도움말 가이드를 작성하거나 또는 재생할 수 있게 한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://github.com/matteobruni/tsparticles"&gt;tsParticles&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;간단하게 particle을 만들 수 있게 해 많은 많은 사용들로부터 인기를 얻었던 &lt;a href="https://github.com/VincentGarreau/particles.js"&gt;Particle.js&lt;/a&gt;(2017년 마지막 업데 데이트 후로 개발 중단 상태) 프로젝트의 TS 포팅 버전이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/saadpasta/react-blog-github"&gt;React Blog&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;GitHub에 이슈를 등록하면 개인 블로그의 글로 전환하여 주는 도구로 GitHub 이슈에서 사용되는 리액션 Emoji도 사용 가능하다.&lt;/p&gt;
&lt;p&gt;사용방법은 react-blog-github 프로젝트를 clone 한 후, 개인 access 토큰과 GihubApp을 생성하고 간단한 설정 정보를 담는 파일을 만들면 모든 환경설정이 완료된다.&lt;/p&gt;
&lt;p&gt;이후, 자신의 프로젝트에 이슈를 생성하고 'blog' 레이블을 다는 것으로 블로그에 새로운 글이 포스팅된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Live demo: &lt;a href="https://github.com/saadpasta/react-blog-github/issues?q=is%3Aissue+is%3Aopen+label%3Ablog"&gt;GitHub Issue&lt;/a&gt; → &lt;a href="https://saadpasta.github.io/react-blog-github/"&gt;발행글&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/engine262/engine262"&gt;engine262&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript로 작성된 JavaScript(ECMA-262) 엔진으로 개발자들이 새로운 기능을 신속하게 프로토타입화하고 탐색할 수 있는 샌드박스를 갖도록 하는 도구다.&lt;/p&gt;
&lt;p&gt;이와 유사하지만, 각기 다른 목적으로 개발되고 있는 유사한 JavaScript 인터프리터들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/facebook/prepack&lt;/li&gt;
&lt;li&gt;https://github.com/mozilla/narcissus&lt;/li&gt;
&lt;li&gt;https://github.com/NeilFraser/JS-Interpreter&lt;/li&gt;
&lt;li&gt;https://github.com/metaes/metaes&lt;/li&gt;
&lt;li&gt;https://github.com/Siubaak/sval&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://github.com/anephenix/sarus"&gt;Sarus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WebSocket은 비정상적 종료에 따른 어떠한 응답도 받을 수 없다는 문제점을 해결하기 위한 JavaScript WebSocket 라이브러리다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://redux-toolkit.js.org/"&gt;Redux Toolkit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Redux Toolkit(이전 프로젝트명 &amp;quot;Redux Starter Kit&amp;quot;)은 모범사례가 적용된 표준적인 Redux 로직 작성 제공을 목표로 하며, Redux 사용 시 겪게 되는 다음의 보편적인 문제들을 해결하기 위해 개발되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redux 스토어 설정의 복잡성&lt;/li&gt;
&lt;li&gt;Redux가 유용한 작업을 수행하도록 만들기 위해 수많은 패키지를 추가해야 하는 문제&lt;/li&gt;
&lt;li&gt;Redux에는 너무 많은 boilerplate 코드가 필요한 문제&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;# 가장 간편한 사용방법은 CRA로 프로젝트 생성 시 Redux+JS 템플릿을 사용하는 것이다.
npx create-react-app my-app --template redux
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>2020-05</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-05.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-05.md" rel="alternate"/><published>2020-05-06T08:11:29+00:00</published><content type="html">&lt;h1&gt;2020-05 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.freecodecamp.org/news/javascript-new-features-es2020/"&gt;10 New JavaScript Features in ES2020 That You Should Know&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;올해 TC39 committee가 승인한 새로운 ES2020 기능들을 간단한 예제와 함께 살펴볼 수 있는 글이다. Dynamic Import, Optional Chaining, Nullish Coalescing 등 웹 개발을 더 편리하게 만들어주는 기능들이 추가되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.kenneth-truyers.net/2018/11/01/best-practices-good-pr/"&gt;Best practices for good PR's&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;팀 단위로 협업을 하다 보면, 우리는 서로 PR을 올리고 리뷰를 하게 된다. PR을 단편적인 업무 공유와 단순 버그 수정 용도가 아닌, 코드 품질을 높이고 모두가 성장할 수 있는 과정으로 만들려면 리뷰어도 작성자도 노력을 기울여야 한다. 이 글에서는 어떻게 좋은 PR을 작성할 수 있는지, 그리고 또 어떻게 좋은 리뷰를 작성할 수 있는지에 대한 기본적인 가이드라인을 제시하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/canal-tech/how-video-streaming-works-on-the-web-an-introduction-7919739f7e1"&gt;How video streaming works on the web: An introduction&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Youtube와 Netflix를 필두로 한 동영상 재생 서비스 시장은 계속해서 커져나가고 있다. 웹에서의 동영상 재생 기술이 어떻게 변화되어 왔고, 현재에 이르러서는 어떤 기술을 쓰는지 확인할 수 있는 내용을 담고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.logrocket.com/whats-new-in-typescript-3-8/"&gt;What’s new in TypeScript 3.8&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;새롭게 릴리즈된 타입스크립트 3.8에서는 새롭게 추가된 ES2020의 문법들을 지원하고 있다. 이뿐만 아니라 &lt;code&gt;asynqc&lt;/code&gt;에 묶이지 않고 최상위 단에서 쓸 수 있는 Top-level Await 기능도 새로이 추가되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://meetup.toast.com/posts/131"&gt;웹 기술로 구현하는 Adaptive HTTP Streaming&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이제 웹에서의 비디오 재생은 완전한 파일을 내려받은 PD(Progressive Downloand) 방식에서 벗어나 실시간으로 사용자가 영상을 송출하고 시청하는 라이브 스트리밍에 기술의 초점이 맞춰지고 있다. 사람들은 영상을 와이파이로 보기도 하고, 고속 인터넷 선이 연결된 컴퓨터로 보기도 한다. 다들 저마다의 네트워크 속도가 다르기 때문에 원활한 영상 시청을 위해선 적절한 해상도의 영상을 내려받아야 한다. 이 글은 어떻게 네트워크 속도에 따른 원활한 영상 시청 경험을 사용자에게 제공하는지 설명하고 있다. 평소 모바일 라이브로 스포츠 경기를 보거나 Twitch 같은 스트리밍 서비스를 이용하는 사람들에겐 재밌는 글이 될 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://sveltesociety.dev/"&gt;Svelte Society Day 2020&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=0rnG-OlzGSs"&gt;전체 동영상 발표보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/sw-yx/ace62a7f6b880a3c87660ac6e663bd9a"&gt;발표 리소스 자료&lt;/a&gt; (슬라이드, 코드 저장소 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;4/26일 진행된 Svelte 온라인 밋업으로, Svelte 개발자인 Rich Harris를 포함해 총 10여 개의 주제로 한 발표를 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://womenofreact.com/"&gt;Women of React&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=K8MF3aDg-bM"&gt;동영상 발표보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/ashc0des/women-of-react-2020-recap-51jf"&gt;컨퍼런스 요약&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;4/25일 진행된 React 여성 개발자들이 주축으로 진행한 온라인 컨퍼런스로 총 11개의 세션으로 구성되어 있으며, 다양한 React tip부터, 테스팅, React 기술 인터뷰 준비 그리고 주요 여성 개발자들 간의 Q&amp;amp;A와 토론 등의 알찬 내용으로 꾸며져 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/"&gt;Now You See Me: How To Defer, Lazy-Load And Act With IntersectionObserver&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;사용자가 현재 보고 있는 화면 영역을 파악하는 것은 이미지 레이지 로딩을 통한 성능 개선은 물론 무한 스크롤이나 PIP(Picture in Picture) 같은 UX 개발에도 큰 도움을 줄 수 있다. 이 글에서는 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"&gt;Intersection Observer API&lt;/a&gt;가 무엇인지 자세히 설명하고, 이를 어떻게 적용하고 활용할 수 있는지에 대한 샘플 코드를 담고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.lambdatest.com/blog/how-smashtest-is-changing-the-way-you-write-selenium-tests/"&gt;How Smashtest is changing the way you write selenium tests&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-live-share-with-visual-studio-code"&gt;Visual Studio Code Live Share&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;개발자들이 구조 설계 회의를 거칠 때 손과 그림만으로 설명하는 것은 때로 부족할 수 있다. VS코드의 Live Share 익스텐션을 사용하면, 하나의 화면에서 모든 사람들이 동시에 코드를 편집하며 의견을 주고받을 수 있다. 코드를 편집하면 그 사람의 이름이 화면에 뜨며, 실시간으로 동일한 파일의 코드를 수정할 수 있다. 요즘처럼 재택근무가 빈번히 이루어지는 시국에 더할 나위 없이 유용한 익스텐션이 아닐 수 없다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/liriliri/eruda"&gt;Eruda&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;모바일 브라우저에서 사용 가능한 개발자 콘솔 도구다.
디버깅 대상 페이지에 스크립트를 로딩한 후, 초기화하는 것으로 간단하게 개발 도구를 활용할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/ritwickdey/vscode-live-server"&gt;Live Server&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;한 번의 클릭으로 실행되는 VS Code 플러그인 웹서버. Live reload가 기본적으로 지원되며, 개발 작업을 웹서버에서 확인이 필요한 경우 요긴하게 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;플러그인 설치 후, VS Code 우측 하단 상태 바에 추가되는 &lt;code&gt;Go Live&lt;/code&gt; 버튼을 클릭하는 것으로 서버를 즉시 시작하고 종료할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/ritwickdey/vscode-live-server/raw/master/images/Screenshot/vscode-live-server-animated-demo.gif" alt="" /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ui.toast.com/weekly-pick/ko_20200320/"&gt;새로운 마크다운 파서가 필요한 이유: Toast UI Editor&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;UI Editor를 만들면서 맞이한 문제점을 기술하고, 그 문제를 해결하는 방법을 설명한 글이다.
Tree-Sitter, LSP와 같이 IDE에서 도입한 솔루션을 검토하고 이를 바탕으로 새로운 마크다운 파서를 개발한 내용인데, 에디터 만드는 사람에게는 꽤나 도전적이고 재미있는 글로 다가올 것이다.&lt;/p&gt;
</content></entry><entry><title>2021-05</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-05.md</id><updated>2021-04-30T07:15:55+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-05.md" rel="alternate"/><published>2021-04-26T18:49:57+00:00</published><content type="html">&lt;h1&gt;2021-05 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://pustelto.com//blog/css-vs-css-in-js-perf/"&gt;Real-world CSS vs. CSS-in-JS performance comparison&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS-in-JS는 Front-end 개발 영역에 확고한 한자리를 차지해 나가고 있어 보이며, 특히나 React 영역에서 더 두드러져 보인다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;매해 조사되는 &amp;quot;&lt;a href="https://2020.stateofcss.com/en-US/technologies/css-in-js/"&gt;State of CSS 2020&lt;/a&gt;&amp;quot; 설문조사에서는 대표적인 CSS-in-JS 도구인 &lt;a href="https://styled-components.com/"&gt;Styled Components&lt;/a&gt;를 들어본 적이 없다고 답변한 이는 14.3%에 불과해 CSS-in-JS는 이제 널리 알려진 개발 방식이라 말할 수 있어 보인다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 글은 주요 CSS-in-JS 라이브러리들에 대한 현실 세계(real-world) 애플리케이션에서의 성능 비교를 소개한다. 그러나 CSS-in-JS는 어떤 식으로든 로딩 성능(JS 파일 크기가 작은 것이 더 나은 성능을 기대)에 영향을 미칠 수밖에 없기 때문에, 로딩 성능에 민감하다면 CSS-in-JS는 여러분의 선택지가 아닐 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.baseclass.io/guides/string-handling-modern-js"&gt;Working With Strings in Modern JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이 가이드는 JavaScript에서 문자열을 다루기 위해 필요한 모든 내용을 담고 있으며, 문자열의 생성, 조작 그리고 비교 방법에 대한 모든 내용을 다루고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.sentry.io/2021/04/12/slow-and-steady-converting-sentrys-entire-frontend-to-typescript"&gt;Slow and Steady: Converting Sentry’s Entire Frontend to TypeScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;오류 로깅 플랫폼/도구인 Sentry가 모든 코드 베이스를 JavaScript에서 TypeScript로 전환한 경험을 소개하는 글로, 12명 이상의 엔지니어링 팀이 참여해 1.1k 여개의 파일들에서 95k 라인에 대한 코드들에 대한 작업이 진행되었다고 한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://storybook.js.org/blog/how-to-actually-test-uis/"&gt;How to actually test UIs&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;UI를 테스트하는 것은 쉽지 않은 일이다. 매 릴리스마다 새롭고 많은 기능들로 인해 UI와 상태는 비례해서 증가하고, 모든 테스트 도구들은 &amp;quot;쉽고, 빠르고, 잘 흐트러지지 않는&amp;quot; 테스트를 만들 수 있다고 말하지만 현실은 그렇지 않다.&lt;/p&gt;
&lt;p&gt;Storybook  커뮤니티 내의 10개 팀들이 사용하는 UI 테스트 테크닉을 통해 어떻게 실용적인 테스트 전략을 만들 수 있는지를 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://apechkurov.medium.com/v8-deep-dives-random-thoughts-on-math-random-fb155075e9e5"&gt;[V8 Deep Dives] Random Thoughts on Math.random()&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;V8에서 &lt;code&gt;Math.random&lt;/code&gt;을 ECMA specification부터 &lt;code&gt;torque&lt;/code&gt;, &lt;code&gt;C++&lt;/code&gt;로 되어있는 구현 로직을 따라가 본다.
이를 통해 왜 &lt;code&gt;Math.random&lt;/code&gt;이 보안상  사용하면 안 되는지 확인해 준다.&lt;/p&gt;
&lt;p&gt;V8에 대해서 관심이 생겼다면 아래 글들을 추가로 읽어볼 것을 추천한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc"&gt;[V8 Deep Dives] Understanding Array Internal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://itnext.io/v8-deep-dives-understanding-map-internals-45eb94a183df"&gt;[V8 Deep Dives] Understanding Map Internals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://medium.com/naver-place-dev/javascript-closure%EB%8A%94-private-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%9A%A9%EB%8F%84%EC%9D%B8%EA%B0%80-d5868489c421"&gt;Javascript Closure는 Private 변수 만드는 용도인가?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Javascript Closure에 대해서 어떻게 접근하면 좋을지에 대한 좋은 방향을 제시해 준다.
페이스북 &lt;code&gt;React Korea&lt;/code&gt;그룹의 댓글에 좋은 의견이 있어 링크를 첨부한다.
https://www.facebook.com/groups/react.ko/permalink/2834835133443307/&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://so-so.dev/react/form-handling/"&gt;입력을 다루는 다양한 방법&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서는 Form의 수가 많아질수록 코드와 상태 관리가 복잡해지고 어려우며, 성능 문제를 겪을 수 있다.
이 문제를 해결하기 위해 &lt;code&gt;useImperativeHandle&lt;/code&gt; , &lt;code&gt;Uncontrolled Component&lt;/code&gt;을 설명하고, 이런 부분이 고려되어 있는 &lt;code&gt;react-hook-form&lt;/code&gt;을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.bitsrc.io/webpacks-hot-module-replacement-feature-explained-43c13b169986"&gt;Webpack’s Hot Module Replacement Feature Explained&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Webpack에서 HMR이 왜 생겼는지, HMR이 어떤 방식으로 일어나는지 간단하게 설명하고, 설정하는 방법을 알려준다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=CY0HE277IBM"&gt;JavaScript Game For Beginners: Sprite Animation&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;실제 게임 개발에서 많이 사용하는 Image Sprites 기법을 JavaScript canvas로 구현한 과정을 담은 영상이다.
해당 유튜브 채널에 Javascript로 만드는 게임, 애니메이션에 대한 자료가 많으니 관심이 있다면 확인해봐도 좋다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dorey.github.io/JavaScript-Equality-Table/"&gt;Equality in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript 문법을 통해 동등 연산자(&lt;code&gt;==&lt;/code&gt;)를 수행하는 경우, 생각했던 것과는 다른 당황스러운 결과를 얻게 될 때가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;[] == &amp;quot;&amp;quot; // true
[] == 0 // true
undefined == null // true
...
// 그만 알아보도록 하자. -,-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;어떤 값과 비교했을 때 true/false 인지 잘 기억나지 않는다면 비교 테이블을 통해 확인해 보자.
추가로 다양한 사례들과 설명을 모아둔 &lt;a href="https://github.com/denysdovhan/wtfjs"&gt;wtfjs&lt;/a&gt;도 확인해 보자.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/mokkapps/debug-why-react-re-renders-a-component-3i8e"&gt;Debug Why React (Re-)Renders a Component&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React의 렌더링, Virtual Dom을 간단히 설명하고, 렌더링이 된 이유를 알 수 있는 툴을 알려준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;렌더링을 시각화: &lt;a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"&gt;React DevTools&lt;/a&gt;의 설정&lt;/li&gt;
&lt;li&gt;렌더링 된 이유: React DevTools의 Profiler&lt;/li&gt;
&lt;li&gt;hook의 렌더링 된 이유   &lt;a href="https://github.com/welldone-software/why-did-you-render"&gt;Why Did You Render&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 글을 통해 React가 Component를 다시 렌더링 하는 이유와 동작을 시각화하고 디버깅하는 방법을 알 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dmitripavlutin.com/parseint-mystery-javascript"&gt;Solving a Mystery Behavior of parseInt() in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;parseInt&lt;/code&gt;가 아래 코드의 경우 의도대로 동작하지 않는 원인을 알아본다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;parseInt(0.0000005); // =&amp;gt; 5
parseInt(999999999999999999999); // =&amp;gt; ? 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://seanbarry.dev/posts/switch-true-pattern"&gt;Using the Switch(true) Pattern in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;switch true 패턴에 대해서 설명하고 이것이 언제 유용한지 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;switch (true) {
  case !user:
    throw new Error(&amp;quot;User must be defined.&amp;quot;);
  case !user.firstName:
    throw new Error(&amp;quot;User's first name must be defined&amp;quot;);
  case typeof user.firstName !== &amp;quot;string&amp;quot;:
    throw new Error(&amp;quot;User's first name must be a string&amp;quot;);
  // ...lots more validation here
  default:
    return user;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/rangav/thunder-client-support"&gt;Thunder Client&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;VS Code 플러그인으로 Rest API 클라이언트 도구로 유명한 &lt;a href="https://www.postman.com/"&gt;Postman&lt;/a&gt;과 유사한 기능들을 제공한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/vercel/pkg"&gt;Pkg&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Next.js를 개발한 Vercel에서 개발한 도구로, 개발한 Node.js 패키지를 Node.js가 설치되지 않은 환경에서도 실행 가능한 파일로 만들어 준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/appsmithorg/appsmith"&gt;Appsmith&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript 기반의 비주얼 개발 플랫폼으로 내부 도구들을 빠르고 쉽게 만들 수 있게 한다. 빌트인 된 위젯들을 드래그 드롭으로 끌어다 놓은 후, 서비스의 API를 연결하는 것만으로 상호작용하는 페이지를 생성할 수 있다.&lt;/p&gt;
</content></entry><entry><title>2021-04</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-04.md</id><updated>2021-05-10T13:59:57+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-04.md" rel="alternate"/><published>2021-03-15T13:31:11+00:00</published><content type="html">&lt;h1&gt;2021-04 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://builtformars.com/clubhouse-conversations/"&gt;Finding conversations on Clubhouse&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;최근 가장 인기 있는 음성 기반의 소셜 네트워크 앱인 Clubhouse는 많은 이들에게 회자되고 있다.&lt;/p&gt;
&lt;p&gt;UX는 FE 관점에서도 매우 주요한 영역 중 하나이기 때문에, Clubhouse의 UX 사례 분석을 통해 좋은 UI/UX를 적용할 수 있는 인사이트를 얻을 수 있지 않을까?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/mini-apps/"&gt;Mini apps&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Mini apps는 일반적으로 4MB 내외의 크기를 가지며, 실행되기 위한 &lt;a href="https://web.dev/mini-app-super-apps/#for-mini-apps-you-need-super-apps"&gt;super app&lt;/a&gt;을 필요로 한다. 이들은 웹 기술(HTML, CSS, JS)을 기반으로 구축된다. (예: WeChat, Line 등과 같은 메신저에서 설치 없이 바로 실행 가능한 다양한 미니 앱들이 이에 속한다.)&lt;/p&gt;
&lt;p&gt;브라우저(mini apps의 런타임은 super app의 WebView)에서 직접 실행은 되는 것은 아니지만, 웹 기술이 사용되므로 또 다른 의미에서의 Front-end 기술 사용 확대라 할 수 있다.&lt;/p&gt;
&lt;p&gt;이 글에선 Mini apps의 개론적인 부분과 개발에 필요한 도구 및 생태계 등을 모두 훑어볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.liftosaur.com/blog/posts/offline-mode-in-liftosaur/"&gt;Offline mode in Liftosaur&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;PWA 앱의 가장 주요한 이점 중에 하나는 바로 오프라인 모드를 활성화할 수 있다는 점이다. 캐싱은 &lt;a href="https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API"&gt;Service Worker&lt;/a&gt;를 통해 구현되며, 이미 수많은 튜토리얼과 사례들을 온라인에서 찾아볼 수 있다. 그러나 캐싱은 오프라인 모드를 구현하기 위한 빙산의 일각으로, 제대로 동작하는 오프라인 앱을 만들기 위해선 더 많은 고려와 작업들이 필요하다.&lt;/p&gt;
&lt;p&gt;이 글은 역도 운동 트래킹 앱인 &lt;a href="https://www.liftosaur.com/about/"&gt;Liftosaur&lt;/a&gt; 개발팀에선 어떻게 오프라인 모드 지원을 추가했는지, 그리고 현실적 고려 사항들이 무엇인지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://davidwalsh.name/react-authentication-2"&gt;React authentication, simplified&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;권한 인증은 항상 많은 노력이 필요한 영역이다. 이 문서에서는 React 애플리케이션에서 인증(및 액세스 제어, SSO 등)에 대한 다른 접근 방식을 설명한다.&lt;/p&gt;
&lt;p&gt;구현/적용 시마다 최신 상태로 유지하거나 다시 조사가 필요한 정적 라이브러리 추가 방식 대신, 자동으로 최신 상태로 유지되고 &lt;a href="https://auth0.com/docs/"&gt;Auth0&lt;/a&gt;, &lt;a href="https://www.okta.com/"&gt;Okta&lt;/a&gt; 및 기타 기능보다 훨씬 간단한 대체 서비스(&lt;a href="https://userfront.com/"&gt;https://userfront.com/&lt;/a&gt;)를 사용하는 방법을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/anmshpndy/functional-javascript-fundamentals-44f2"&gt;Fundamentals of Functional JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 문서는 JavaScript 애플리케이션과 관련된 함수형 프로그래밍에 대한 기본 사항을 설명하는 것과 함께 다음을 이해하기 위한 목표를 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수란 무엇인가?&lt;/li&gt;
&lt;li&gt;함수(Functions) vs 프러시저(Procedures)&lt;/li&gt;
&lt;li&gt;선언적(Declarative) vs 명령적(Imperative)&lt;/li&gt;
&lt;li&gt;함수 입력과 출력에 대한 이해&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/react-component-tests-for-humans/"&gt;React Component Tests for Humans&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React에서 유지보수하기 쉬운 컴포넌트 테스트 코드를 작성하는 것은 매우 어려운 일이다. 이 글에서는 다음 세 단계로 이루어진 패턴을 통해 가독성이 좋은 컴포넌트 테스트를 작성하는 방법에 대해 설명한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;Arrange: 컴포넌트 props를 준비한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="2"&gt;
&lt;li&gt;Act: 컴포넌트를 렌더하고 사용자의 이벤트를 코드로 발생시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Assert: 기댓값을 설정해서 컴포넌트가 정상적으로 동작하는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://overreacted.io/before-you-memo/"&gt;Before You &lt;code&gt;memo()&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React에서 성능을 최적화하기 위해 &lt;code&gt;memo&lt;/code&gt; 혹은 &lt;code&gt;useMemo&lt;/code&gt;를 사용하는 경우가 많다. 하지만 Dan Abramov는 &lt;code&gt;memo&lt;/code&gt;를 무작정 사용하기 전에 &lt;code&gt;memo&lt;/code&gt;를 사용하지 않는 두가지 기초적인 성능 최적화 방법을 소개한다.&lt;/p&gt;
&lt;p&gt;이 글에서 설명하는 패턴을 적용하면 성능 향상 뿐만 아니라 애플리케이션의 데이터 흐름을 더 쉽게 파악할 수 있을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://kentcdodds.com/blog/optimize-react-re-renders"&gt;One simple trick to optimize React re-renders&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://web.dev/javascript-this"&gt;JavaScript: What is the meaning of this?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript에서 &lt;code&gt;this&lt;/code&gt;는 굉장히 복잡한 개념이다. 이 글에서는 &lt;code&gt;if (…) … else if () … else if (…) …&lt;/code&gt; 식으로 다음과 같이 케이스를 나누어서 &lt;code&gt;this&lt;/code&gt;를 설명한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;화살표 함수를 사용하는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;와 함께 함수/클래스가 호출되는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;code&gt;bind&lt;/code&gt; 메서드를 사용하는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="4"&gt;
&lt;li&gt;호출되는 시점에 &lt;code&gt;this&lt;/code&gt;가 설정되는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="5"&gt;
&lt;li&gt;상위 객체에서 함수를 호출하는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="6"&gt;
&lt;li&gt;함수 혹은 상위 스코프가 &lt;code&gt;strict mode&lt;/code&gt; 내에 있는 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="7"&gt;
&lt;li&gt;그 외 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://hyperflow.dev/Frontend/Javascript-this"&gt;한글 번역&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://developer.chrome.com/blog/css-in-js/"&gt;CSS-in-JS support in DevTools&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;구글은 Chrome 85 버전부터 &lt;a href="https://developer.chrome.com/docs/devtools/"&gt;개발자도구&lt;/a&gt;에서 CSS-in-JS 프레임워크를 위한 스타일 수정 기능을 지원했다. 개발자도구의 스타일 창에서 어떻게 CSS-in-JS 규칙 수정 기능을 추가했는지 설명하는 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/wantedjobs/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-ssr-cache-%EC%A0%81%EC%9A%A9%EA%B8%B0-bf022e3a1a72"&gt;웹 성능 최적화 SSR + Cache 적용기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹 애플리케이션의 성능은 매출에도 영향을 미친다. 또한, 구글은 사이트 순위를 지정할 때 속도를 중요한 요소로서 고려한다.&lt;/p&gt;
&lt;p&gt;이 글에서는 SSR과 Cache를 적용해서 웹 성능을 최적화한 경험을 공유하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.blog/2021-03-25-how-github-actions-renders-large-scale-logs/"&gt;How GitHub Actions renders large-scale logs&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;GitHub 프로젝트들의 개발 워크플로 자동화를 구성할 수 있는 GitHub Actions에서 대용량 로그 렌더링 개선을 위한 여정을 소개한다.&lt;/p&gt;
&lt;p&gt;대용량의 로그를 한 번에 렌더링 하는 것은 성능적으로 좋지 않기 때문에, UI 가상화를 통해 뷰포트를 통해 노출되는 영역 만을 렌더링 하는 것과 최소 5만 라인을 갖는 로그를 문제없이 렌더링 하는 자체 라이브러리 개발에 이르게 된 배경 등을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/compat2021/"&gt;Compat2021&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;브라우저 벤더들인 Google, Mozilla 그리고 Microsoft은 브라우저 호환성 이슈 해결이 시급한 TOP 5 항목들에 대해 2021년 내 호환성 이슈를 해결하기 위한 작업 파트너십을 구성하는데 합의했다.&lt;/p&gt;
&lt;p&gt;연내 해결하기로 합의한 TOP 5 이슈들은 주로 CSS 영역이며, 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS Flexbox&lt;/li&gt;
&lt;li&gt;CSS Grid&lt;/li&gt;
&lt;li&gt;position: sticky&lt;/li&gt;
&lt;li&gt;aspect-ratio&lt;/li&gt;
&lt;li&gt;CSS transforms&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://wpt.fyi/compat2021"&gt;Compat 2021 Dashboard&lt;/a&gt;를 통해 각 브라우저들에서의 TOP 5 지원에 대한 테스트 수행 점수를 확인해 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/nefe/You-Dont-Need-jQuery/blob/master/README.ko-KR.md"&gt;You (Might) Don't Need jQuery&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React, Vue 등의 프런트엔드 라이브러리가 나타나면서 jQuery 사용은 점차 줄어들고 있다. 본 글에서는 jQuery가 제공하던 대부분의 기능을 네이티브로서 대체하는 방법을 제시한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jbee.io/react/error-declarative-handling-0/"&gt;효율적인 프런트엔드 에러 핸들링&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;서비스를 개발할 때 에러 핸들링은 빼놓을 수 없는 관심사다. React에서 사용자 경험을 고려하면서 효율적으로 에러를 처리했던 경험을 공유한 글이다.&lt;/p&gt;
&lt;p&gt;이 글에서는 다음과 같이 세 개의 글을 시리즈로 묶어 설명하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://jbee.io/react/error-declarative-handling-1/"&gt;React에서 선언적으로 비동기 다루기&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;a href="https://jbee.io/react/error-declarative-handling-2/"&gt;클라이언트의 사용자 중심 예외 처리&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;a href="https://jbee.io/react/error-declarative-handling-3/"&gt;선언적으로 에러 상황 제어하기&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.sitepoint.com/beyond-console-log-level-up-your-debugging-skills/"&gt;Beyond Console.log() – Level up Your Debugging Skills&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;브라우저의 개발자도구는 디버깅할 때 도움이 되는 여러 강력한 기능을 가지고 있다.&lt;/p&gt;
&lt;p&gt;이 글에서 설명하는 개발자도구의 강력한 기능을 익히면 디버깅 능력을 한층 더 끌어올릴 수 있을 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.freecodecamp.org/news/fetch-data-react/"&gt;How to Fetch Data in React: Cheat Sheet + Examples&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 글은 React에서 HTTP 요청을 통해 데이터를 fetch하는 방법 다섯 가지를 예제 코드와 함께 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.codeinwp.com/blog/css-grid-tutorial-layout/"&gt;The Ultimate CSS Grid Tutorial for Beginners (With Interactive Examples)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Grid Layout 명세의 주요한 기능을 많은 CodePen 예제와 함께 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ui.toast.com/weekly-pick/ko_20210303"&gt;국제화(i18n) 자동화 가이드&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;글로벌 서비스를 지원하는 웹 애플리케이션에서 국제화(i18n)는 필수적이다. 국제화를 지원할 때 개발과 번역 과정에서 반복적인 수동 작업으로 인해 고통 받기 쉽다.&lt;/p&gt;
&lt;p&gt;이 가이드에서는 구글 스프레드 시트와 &lt;code&gt;i18next&lt;/code&gt;, &lt;code&gt;i18next-scanner&lt;/code&gt; 라이브러리를 활용하여 단 몇개의 스크립트로 효율적인 협업과 프로세스 자동화를 이룬 방법에 대해 설명하고 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://stoxy.dev/"&gt;Stoxy&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹 컴포넌트가 장착된 반응형 상태 관리자 시스템으로, 상태들은 인 브라우저(in-browser)의 IndexedDB 데이터베이스에 저장하며, 마지막 접근된 5개 객체들만 인 메모리(in-memory)를 사용하도록 구성된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// Write
import { write } from &amp;quot;@stoxy/core&amp;quot;;

write(&amp;quot;Shoppingcart&amp;quot;, [{ id: 123, name: &amp;quot;Free gift&amp;quot; }]);

// Read
import { read } from &amp;quot;@stoxy/core&amp;quot;;

async function getItems() {
  const items = await read(&amp;quot;shoppingcart&amp;quot;);
  return items;
}

// Clear
import { clear } from &amp;quot;@stoxy/core&amp;quot;;

clear(&amp;quot;shoppingcart&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/ahuth/raycast"&gt;Raycast&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Canvas를 사용하지 않고, React와 HTML로 구성된 Raycasting(광선 투사) JavaScript 엔진이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://ahuth.github.io/raycast/"&gt;라이브 데모&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/KiwiTalk/KiwiTalk"&gt;KiwiTalk&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React, Typescript로 개발된 크로스플랫폼 비공식 카카오톡 클라이언트&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/github/github-elements"&gt;github-elements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;GitHub의 웹 컴포넌트 컬렉션으로, 현재 16개의 커스텀 엘리먼트들이 제공되고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/toplenboren/simple-git-hooks"&gt;simple-git-hooks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git Hook의 대표 주자인 husky에 비해 의존성 없는 가벼운 용량의 hook 라이브러리다.&lt;/p&gt;
&lt;p&gt;패키지 설치 후, 간단하게 &lt;code&gt;package.json&lt;/code&gt;에 커밋 훅을 작성하면 된다. 다음은 커밋 전에 linter를 수행하고 푸시 시점에 formatter를 수행하도록 하는 예제다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// package.json
 &amp;quot;simple-git-hooks&amp;quot;: {
    &amp;quot;pre-commit&amp;quot;: &amp;quot;npx lint-staged&amp;quot;,
    &amp;quot;pre-push&amp;quot;: &amp;quot;cd ../../ &amp;amp;&amp;amp; npm run format&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/zthxxx/react-dev-inspector"&gt;React Dev Inspector&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;브라우저에서 React 컴포넌트를 클릭하면 로컬 IDE의 해당 컴포넌트 코드로 편리하게 이동시켜주는 도구다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://shepherdjs.dev/"&gt;Shepherd.js&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;사용자에게 웹 애플리케이션 사용법을 쉽게 보여줄 수 있도록 도와주는 자바스크립트 라이브러리다. React, Vue, Angular 등 주요 자바스크립트 프레임워크를 위한 Wrapper 라이브러리도 개발되어있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dndkit.com/"&gt;dnd kit&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서 사용할 수 있는 가볍고 성능과 확장성이 좋은 drag &amp;amp; drop 라이브러리다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.akashmittal.com/gui-utility-to-generate-react-table-code/"&gt;GUI tool to generate React-Table code for your projects&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;페이지네이션, 정렬, 검색, 필터 기능을 가지고 있는 React 테이블 코드를 생성할 수 있게 해주는 웹 애플리케이션이다. 여러 기능을 가진 테이블을 개발할 때 생성된 코드를 참고해 유용하게 활용할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://svelte.nodegui.org/"&gt;Svelte NodeGUI: Build Cross Platform Apps with Node and Svelte&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://github.com/nodegui/nodegui"&gt;NodeGUI&lt;/a&gt;는 &lt;a href="https://www.qt.io/download"&gt;Qt5&lt;/a&gt; 기반의 크로스플랫폼 데스크톱 애플리케이션 개발 도구다. NodeGUI는 Chromium 기반의 &lt;a href="https://www.electronjs.org/"&gt;electron&lt;/a&gt;보다 CPU와 메모리를 더 효율적으로 활용한다고 알려져 있다.&lt;/p&gt;
&lt;p&gt;기존에 React용 렌더러인 &lt;a href="https://github.com/nodegui/react-nodegui"&gt;React NodeGUI&lt;/a&gt;와 Vue용 렌더러인 &lt;a href="https://github.com/nodegui/vue-nodegui"&gt;Vue NodeGUI&lt;/a&gt;가 존재했는데 최근 Svelte용 렌더러인 &lt;a href="https://github.com/nodegui/svelte-nodegui"&gt;Svelte NodeGUI&lt;/a&gt;가 릴리즈되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=AlexShen.classdiagram-ts"&gt;classdiagram-ts (VS Code 플러그인)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;TypeScript로 UML 클래스 다이어그램을 자동으로 생성해주는 VS Code 플러그인이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/nodeca/probe-image-size"&gt;probe-image-size&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이미지는 웹에서 가장 많은 리소스를 차지하는 요소 중 하나이다. 만약, 이미지의 크기만 필요한 경우라면 이미지 전체를 다운로드하는 것은 낭비일 수 있다. 특히나 큰 이미지라면 더더욱 그렇다.&lt;/p&gt;
&lt;p&gt;이 라이브러리는 이미지 전체를 다운로드하지 않고, 크기와 정보를 조회할 수 있는 라이브러리다.&lt;/p&gt;
</content></entry><entry><title>2020-11</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-11.md</id><updated>2020-11-04T01:11:58+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-11.md" rel="alternate"/><published>2020-11-04T01:11:58+00:00</published><content type="html">&lt;h1&gt;2020-11 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/evanw/esbuild/issues/478"&gt;Safari deopt with a large ESBuild bundle&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;한 사용자가 Go로 작성된 번들러인 &lt;a href="https://github.com/evanw/esbuild"&gt;esbuild&lt;/a&gt; 프로젝트 이슈를 통해, Safari에서 커다란 크기의 번들 파일을 실행하면 타 브라우저 대비 6~8x 배 성능이 느려지는 현상에 대해 재현 케이스들과 함께 문의하는 내용의 글이다.&lt;/p&gt;
&lt;p&gt;esbuild 프로젝트 메인터너 중 한 명인, Evan Wallace는 변수 선언 시 &lt;code&gt;let/const&lt;/code&gt; 대신 &lt;code&gt;var&lt;/code&gt;를 사용하는 경우 문제가 해결되는 것을 발견했고, 관련 내용은 &lt;a href="https://bugs.webkit.org/show_bug.cgi?id=199866"&gt;JavaScriptCore의 버그&lt;/a&gt;로 리포팅 되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://mdn-web-dna.s3-us-west-2.amazonaws.com/MDN-Browser-Compatibility-Report-2020.pdf"&gt;MDN Browser Compatibility Report 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Mozilla에서 해마다 발행하는 브라우저 호환성 리포트로 공개 설문조사를 통해 수집된 의견을 통해 현재 웹 개발의 상태를 보여주고, 일부 항목들에 대한 개별적 인터뷰도 포함하고 있어 실 사용 환경에서의 생생한 경험을 엿볼 수도 있다.&lt;/p&gt;
&lt;p&gt;결과를 통해 비단 IE는 국내뿐만 아니라 해외 개발자들에게도 가장 골칫거리 임을 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/commonjs-larger-bundles/"&gt;How CommonJS is making your bundles larger&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;왜 CommonJS 모듈 시스템이 여러분들의 번들 크기를 필요 이상으로 크게 만들 수 있는지에 대해 설명하는 글로 인기 있는 번들러인 Webpack에서 ModuleConcatenationPlugin을 통해 모듈이 번들링 되는 과정을 예제를 통해 소개한다.&lt;/p&gt;
&lt;p&gt;결론적으론 번들러가 성공적인 최적화를 적용하기 위해선 CommonJS 대신 ESM을 사용하는 것이 가장 확실한 방법임을 얘기한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://github.com/mgechev/is-esm"&gt;is-esm&lt;/a&gt; 프로젝트는 해당 패키지가 ESM 모듈인지 간단하게 확인할 수 있게 도와준다.
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://developer.mozilla.org/ko/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks"&gt;Understanding client-side JavaScript frameworks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mozilla 재단이 운영하는 MDN 문서 사이트는 사실상 웹 기술들의 &amp;quot;공식&amp;quot; 문서와 다름없는 defacto 사이트라 할 수 있다.&lt;/p&gt;
&lt;p&gt;MDN은 표준 기술들을 주로 다루지만, 주요 프레임워크들에 대한 내용도 다루고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ko/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started"&gt;React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started"&gt;Svelte
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ko/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started"&gt;Vue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ko/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_getting_started"&gt;Ember&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://addyosmani.com/blog/the-prpl-pattern/"&gt;Faster Web App Delivery with PRPL&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;PRPL(Push, Render, Pre-cache, Lazy-load) 패턴은 Polymer 팀이 2016년 소개했던 개념으로 웹 애플리케이션의 구조화와 제공에 대한 방법론이다.&lt;/p&gt;
&lt;p&gt;이 글에선 PRPL 웹 애플리케이션을 위한 구성 요소와 구조에 대해 가볍게 소개하며, 2017년부터 PRPL을 적용해 서비스하고 있는 트위터의 사례를 통해 성능 지향적인 서비스 개발 패턴을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/playlist?list=PLNBNS7NRGKMGCBNebw8xkpkq_lhgPoIzR"&gt;React Summit Remote Edition 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 5월 진행됐던 &lt;code&gt;React Summit Remote Edition 2020&lt;/code&gt; 온라인 콘퍼런스 세션들에 대한 재생목록으로, &lt;a href="https://nextjs.org/"&gt;Next.js&lt;/a&gt; 개발자인 Guillermo Rauch, &lt;a href="https://github.com/testing-library/react-testing-library"&gt;React Testing Library&lt;/a&gt; 개발자인 Kent C. Dodds 등이 연사로 참여한 세션들을 들어볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://sveltesummit.com/"&gt;Svelte Summit 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 10월 18일 진행된 Svelte 온라인 콘퍼런스로, 총 18개의 다양한 주제로 구성된 세션들을 확인해 볼수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/hacking-talent/two-years-of-micro-frontends-a-retrospective-522526f76df4"&gt;Two years of micro-frontends: A retrospective&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Create React App과 Stroybook 메인터너로 참여하고 있는 Brody McKee의 글로, 지난 2년간 마이크로 프런트엔드 도입에 대한 소회를 밝히는 글로 실 서비스 도입을 통한 장단점을 공유한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/frontend-digest/whats-new-in-webpack-5-ef619bb74fae"&gt;Whats's New in Webpack 5&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 10월 Webpack 4가 릴리스된 지 2년 만에 v5가 출시되었다.
v5에서는 이전 버전에 비해 빌드 속도가 향상되었으며, 번들 사이즈도 감소했다.&lt;/p&gt;
&lt;p&gt;v5에서 주목해 볼 만한 변경사항은 &lt;a href="https://webpack.js.org/concepts/module-federation/"&gt;&lt;strong&gt;Module Federation&lt;/strong&gt;&lt;/a&gt; 기능으로, 다수의 Webpack 빌드가 함께 동작할 수 있으며 필요에 따라 큰 제약 없이 다른 모듈로부터 코드를 동적으로 불러올 수도 있다.&lt;/p&gt;
&lt;p&gt;개발 환경에서 번들러의 메이저 버전 마이그레이션은 어쩌면 귀찮고 어려우며 손이 많이 가는 작업일 것이다. 하지만 더 쾌적하고 생산적인 빌드 및 개발 환경을 위해 꼭 필요한 작업이기도 하다. 앞으로의 2년을 위해 &lt;a href="https://webpack.js.org/migrate/5/"&gt;가이드&lt;/a&gt;를 참고하여 차근차근 마이그레이션하는 시간을 가져보는 것은 어떨까?&lt;/p&gt;
&lt;p&gt;보다 더 자세한 사항은 &lt;a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/"&gt;공식 문서&lt;/a&gt;에서 참고할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://nextjs.org/blog/next-10"&gt;Next.js 10&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React 애플리케이션 프레임워크인 Next.js의 새로운 메이저 릴리스인 &lt;code&gt;Next.js 10&lt;/code&gt;이 공개되었다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nextjs.org/blog/next-10#built-in-image-component-and-automatic-image-optimization"&gt;빌트인 이미지 최적화&lt;/a&gt; 기능, 성능 측정을 위한 &lt;a href="https://nextjs.org/blog/next-10#nextjs-analytics"&gt;Analytics&lt;/a&gt;, 이커머스
사이트를 위한 &lt;a href="https://nextjs.org/blog/next-10#nextjs-commerce"&gt;Commerce 스타터킷&lt;/a&gt;, 최신 &lt;a href="https://nextjs.org/blog/next-10#react-17-support"&gt;React 17 지원&lt;/a&gt; 등이 포함되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://nextjs.org/conf/schedule"&gt;&lt;strong&gt;Next.js CONF&lt;/strong&gt;&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;
지난 10월 27일, Next.js의 첫 온라인 콘퍼런스가 진행되었다. 총 4개 트랙으로 구성된 프로그램에서는 Next.js를 사용하는 여러 분야의 기업들 연사들이 참여해 다양한 사례들을 공유한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://nickb.dev/blog/results-of-authoring-a-js-library-with-rust-and-wasm"&gt;Results of Authoring a JS Library with Rust and Wasm&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;스웨덴 게임 개발사인 &lt;a href="https://en.wikipedia.org/wiki/Paradox_Development_Studio"&gt;Paradox Development Studios&lt;/a&gt;에서 개발된 게임 파일들의 plaintext를 파싱 하거나 저장하는 라이브러리인 &lt;a href="https://github.com/nickbabcock/jomini"&gt;Jomini.js&lt;/a&gt; 프로젝트에서 사용하던 순수 JavaScript 파서를 Rust로 작성된 wasm 모듈로의 전환 과정을 다룬다.&lt;/p&gt;
&lt;p&gt;전환을 통해 더 나은 성능 향상과 그에 따른 경험적 측면을 살펴볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/alekseiberezkin/what-happened-to-immutable-js-and-how-can-we-react-5c34"&gt;What happened to Immutable.JS? And how can we react?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Immutable(불변성) 데이터를 처리하기 위한 대표적인 JS 라이브러리로는 &lt;a href="https://github.com/immutable-js/immutable-js"&gt;Immutable.js&lt;/a&gt;, &lt;a href="https://github.com/immerjs/immer"&gt;immer&lt;/a&gt; 등을 꼽을 수 있다. 하지만 Immutable.js는 약 2년 전에 마지막으로 publish 된 것을 알고 있는가?&lt;/p&gt;
&lt;p&gt;이 글에서는 Immutable.js가 현재 유지 보수가 되지 않고 있으며 어떤 대안을 찾을 수 있는지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.swyx.io/svelte-sites-react-apps/"&gt;Svelte for Sites, React for Apps&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;웹사이트는 주로 콘텐츠를 보여주기 위한 용도로 제한적인 인터렉션을 포함하며, 제한적인 상황(낮은 성능의 CPU, 제한적 데이터 사용 등)에서도 소비될 수 있어야 한다.&lt;/p&gt;
&lt;p&gt;반면, 웹앱은 주로 인터렉션을 통한 사용성을 제공하며, 일반적으로 무거운 자원들을 포함하나 2MB 정도의 JS 웹앱의
크기는 200MB 용량의 모바일 앱과 비교 시 상대적으로 나쁘지 않다고 생각될 수 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 웹사이트와 웹앱의 특성에 따라 각각의 프레임워크들의 기술적 특성들을 통해 왜 웹사이트는 Svelte가 더 적합하고,
그리고 React는 웹앱에 더 적합한지를 설명한다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://medium.com/nmc-techblog/introducing-the-async-cookie-store-api-89cbecf401f"&gt;Introducing: The Async Cookie Store API&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 87+부터 새롭게 추가된 기존의 &lt;code&gt;document.cookie&lt;/code&gt;의 새로운 개선 API인  &lt;a href="https://wicg.github.io/cookie-store/"&gt;&lt;code&gt;Cookie Store API&lt;/code&gt;&lt;/a&gt;를 소개하는 글로, Service Worker와 비동기 처리를 통해 쿠키를 설정하거나 가져올 수 있는 방법들을 간단한 예제를 통해 설명한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 기존 방식
document.cookie.split(&amp;quot;;&amp;quot;).forEach(v =&amp;gt; ...);

// Cookie Sotre API
await cookieStore.get(&amp;quot;쿠키이름&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/Asabeneh/30-Days-Of-React"&gt;30 Days Of React&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;30일의 기간 동안 매일 따라 해 볼 수 있는 Step by step React 가이드를 통해 React를 마스터할 수 있도록 도와주는 프로젝트다.&lt;/p&gt;
&lt;p&gt;꼭 일정에 맞춰 학습하지 않더라도, 목차를 통해 제공되는 각각의 개념들에 대한 설명을 읽어보는 것만으로도 React의 주요 개념들을 학습할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=K5eoHVbwAhI"&gt;Build an Income Tracker in ReactJS ~ useState, useEffect, useRef&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;토이 프로젝트인 &amp;quot;Income Tracker&amp;quot; 애플리케이션 개발을 처음부터 완성까지 따라 해 볼 수 있는 튜토리얼 동영상으로, React의 기본적 구성요소와 함께 다양한 Hooks(useState, useRef, useEffect) 등의 활용 방법 등도 함께 배워볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로젝트 저장소: https://github.com/TylerPottsDev/income-tracker-rjs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/microsoft/beginners-intro-javascript-node"&gt;Beginner's Series - Intro to JavaScript (Node.js)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MS에서 만든 Node.js에서 동작하는 애플리케이션 개발을 위한 초심자 대상 JavaScript 튜토리얼로, 이론적인 것보단 문법에 보다 집중한다.&lt;/p&gt;
&lt;h1&gt;도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/volta-cli/volta"&gt;Volta&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Node.js 버전 관리를 위한 대표적인 도구로는 &lt;a href="https://github.com/nvm-sh/nvm"&gt;nvm&lt;/a&gt;과 &lt;a href="https://github.com/tj/n"&gt;n&lt;/a&gt;이 있지만, 몇가지 이슈들(Windows 미지원, 성능, 직관적이지 않은 설정방법 등)이 존재한다.&lt;/p&gt;
&lt;p&gt;Rust로 개발된 Volta는 Node.js외, npm, yarn 등 FE 개발에 필요한 다양한 툴체인 도구들을 빠르고 쉽게 설치하고, 프로젝트별 다른 버전 사용 등의 기능들을 제공한다.&lt;/p&gt;
&lt;p&gt;대다수의 Unix(MacOS) 시스템에선 간단하게 다음과 같이 설치할 수 있고, Windows는 다음의 &lt;a href="https://github.com/volta-cli/volta/releases/download/v0.8.7/volta-0.8.7-windows-x86_64.msi"&gt;설치파일&lt;/a&gt;을 받아 설치하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;# Unix 환경에서 설치
curl https://get.volta.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;volta install node
volta install node@12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로젝트에 따라 서로 다른 Node.js(또는 다른 툴체인) 버전으로 자동 전환되게 하고 싶다면, package.json 파일의 &lt;a href="https://docs.npmjs.com/files/package.json#engines"&gt;&lt;code&gt;engines&lt;/code&gt;&lt;/a&gt; 필드 또는 &lt;code&gt;volta pin 패키지명@버전&lt;/code&gt; 명령어를 통해 관리할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// &amp;quot;volta pin node@10.15.3&amp;quot; 명령어는 package.json 파일에 아래와 같은 설정을 추가해 관리한다.
&amp;quot;volta&amp;quot;: {
  &amp;quot;node&amp;quot;: &amp;quot;10.15.3&amp;quot;,
  &amp;quot;yarn&amp;quot;: &amp;quot;1.14.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또한 다양한 CLI 도구들에 대한 버전 전환 기능도 제공한다. 해당 프로젝트 내에서 서로 다른 typescript 패키지를 사용(devDependency나 dependency로 설정된 경우)하고 있다면 commend line에서 해당 버전을 사용하도록 설정할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;cd /dev/project-using-typescript-2.9.2
tsc --version # 2.9.2

cd /dev/project-using-typescript-3.4.5
tsc --version # 3.4.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/verdaccio/verdaccio"&gt;Verdaccio&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Verdaccio는 무설정 로컬 프라이빗 npm 레지스트리를 구축할 수 있게 도와주는 도구로, 자체 데이터베이스를 포함하고 있어 사용을 위해 별도 데이베이스를 구축 필요가 없다. 또한 외부의 다른 레지스트리들(ex. npmjs.org)에 대한 프록시 기능도 제공된다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/open-source-labs/reactime"&gt;Reactime&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 확장 기능으로, React 애플리케이션 컴포넌트들의 상태를 스냅샷으로 저장해 Time Travel Debugging을 통해 특정 상태 이동을 통한 디버깅을 도와준다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://chrome.google.com/webstore/detail/reactime/cgibknllccemdnfhfpmjhffpjfeidjga"&gt;chrome 웹 스토어에서 설치하기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;페이스북의 새로운 상태 관리자 라이브러리인 Recoil을 포함, Context API, 등을 지원한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://www.consolechat.io/"&gt;ConsoleChat.io &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이제 막 시작한 지 얼마 되지 않은 프로젝트로, 브라우저 콘솔을 통한 실시간 채팅룸을 만들 수 있도록 도와주는 라이브러리다.
사용 방법은 라이브러리가 로딩된 페이지에 접속 후, 콘솔에서 라이브러리 초기화와 사용할 사용자명을 설정하고 바로 대화를 시작할 수 있다.&lt;/p&gt;
&lt;p&gt;아직 명령어를 통한 사용방법 등에서 개선될 여지가 많아 보이지만, 참신한 접근 방법이 재미있어 보이는 프로젝트다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/turbolinks/turbolinks"&gt;Turbolinks&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Turbolinks는 별도의 복잡한 클라이언트 JavaScript 프레임워크를 사용하지 않고 SPA에서 내비게이션 페이지들로의 빠른 이동(렌더링)을 가능케 한다.&lt;/p&gt;
&lt;p&gt;동일 도메인 내의 모든 &lt;code&gt;&amp;lt;a href&amp;gt;&lt;/code&gt; 클릭을 인터셉트하고 History API로 기존 link를 업데이트한 후, XHR을 통해 링크 대상 페이지를 로딩한다.
이후 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 영역의 모든 콘텐츠를 새로운 페이지의 것으로 대체하고, &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;는 머지 하는 형태로 동작한다.&lt;/p&gt;
&lt;p&gt;HTML5 History API와 requestAnimationFrame이 지원되는 브라우저라면 사용이 가능하다.&lt;/p&gt;
</content></entry><entry><title>2020-12</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-12.md</id><updated>2020-12-02T01:17:30+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-12.md" rel="alternate"/><published>2020-11-24T07:23:47+00:00</published><content type="html">&lt;h1&gt;2020-12 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://docs.npmjs.com/cli/v7/commands/npm-init"&gt;npm-init&lt;/a&gt; &lt;code&gt;&amp;lt;initializer&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;보통 새로운 프로젝트를 시작할 때, &lt;code&gt;npm init -y&lt;/code&gt;를 수행해 기본 값이 지정된 package.json을 만들거나, 또는 특정 프레임워크라면 &lt;code&gt;create-XXX&lt;/code&gt;(create-react-app)와 같은 도구를 사용해 프로젝트 스캐폴딩을
통해 시작한다.&lt;/p&gt;
&lt;p&gt;스캐폴딩 도구를 자주 사용하는 경우라면, 전역 영역에 설치하고 사용하거나 자주 사용되지 않는
경우라면 &lt;code&gt;npx&lt;/code&gt;를 통해 한 번만 다운로드해 실행하는 경우가 일반적이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;npx create-react-app my-app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 알려지지 않은 사실 중 한 가지는, &lt;code&gt;npm init&lt;/code&gt; 명령어를 사용해 보다 간편하게 이 작업을 수행할 수 있다는 점이다. npm &lt;code&gt;v6+&lt;/code&gt;부터 &lt;code&gt;&amp;lt;initializer&amp;gt;&lt;/code&gt;지정을 통해 외부 도구를 활용한 스캐폴딩을 수행할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;npm init &amp;lt;initializer&amp;gt;

npm init foo # ==&amp;gt; npx create-foo
npm init foo -- --hello # ==&amp;gt; npx create-foo --hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;npm 패키지명이 &lt;code&gt;create-&amp;lt;initializer&amp;gt;&lt;/code&gt;와 같이 존재하는 경우, npx를 통해 해당 패키지를 다운로드 후 해당 패키지를 통한 프로젝트 스캐폴딩을 생성한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;npm init react-app my-app
npm init react-app@3.3.0 my-app

# Yarn의 경우도, 유사한 &amp;quot;yarn create&amp;quot;를 사용할 수 있다.
yarn create react-app my-app # Yarn 0.25+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://blog.isquaredsoftware.com/2020/11/how-web-apps-work-javascript-dom/"&gt;How Web Apps Work: JavaScript and the DOM&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;웹 개발은 넓고 다양한 콘셉트, 정의, 도구 그리고 기술들을 포함한다. 처음 웹 개발 영역에 접근하는 이들은 이들 각각이 어떻게 결합되고 동작하는지 잘 알지 못한 채 시작하는 경우가 대다수다.&lt;/p&gt;
&lt;p&gt;이 글에서는 기본적인 웹 개발 개념과 기술들에 대해 무엇인지, 왜 필요한지, 그리고 그것들이 어떻게 서로 연관되어 있는지를 개괄적으로 다룬다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://developer.chrome.com/devsummit/"&gt;Chrome Dev Summit 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;12월 9-10일, 크롬 브라우저와 웹 기술과 관련된 총 26개의 세션으로 구성되어 있는 크롬 개발자 서밋이 진행된다. 올해는 다른 개발자 행사들과 마찬가지로 온라인으로 진행된다.&lt;/p&gt;
&lt;p&gt;본 행사에 앞서 12월 7-8일 진행되는 &lt;a href="https://developer.chrome.com/devsummit/schedule/#workshops"&gt;워크숍&lt;/a&gt;을 통해 각 분야별 전문가들을 통해 직접 새로운 기술들을 배워볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/hymanaharon/why-i-will-no-longer-be-using-console-log-to-check-react-state-updates-29el"&gt;Why I will no longer be using console.log() to check React state updates&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React 개발을 하다 보면 종종 state를 보기 위해 &lt;code&gt;console.log&lt;/code&gt;를 이용할 때가 있다. 하지만, &lt;code&gt;console.log&lt;/code&gt;는 가독성 면에서 좋지 않을 때가 많다.
이 글은 &lt;code&gt;console.table&lt;/code&gt;과 &lt;code&gt;columns&lt;/code&gt; 파라미터를 통해 React state를 좀 더 보기 쉽게 디버깅하는 방법을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://snyk.io/blog/10-react-security-best-practices"&gt;10 React security best practices&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React 환경에서 개발 시 쉽게 놓칠 수 있는 10가지 보안 위협 케이스와 그에 대한 해법을 제시한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/microsoft/TypeScript/wiki/TypeScript&amp;#x27;s-Release-Process"&gt;TypeScript's Release Process&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;타입스크립트 팀이 타입스크립트 릴리스 프로세스에 대한 글을 작성하였다. 릴리스 단계, 주기 등을 타입스크립트 팀은 어떻게 관리하는지 엿볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.seokjun.kim/react-ssr-the-record-of-pain/"&gt;React SSR 그 고통의 기록&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;운영 중인 서비스에 SSR 적용을 위한 개발 경험을 공유하는 글로, SSR을 통해 성능적인 개선을 이루기도 했지만 많은 리소스를 투입할 만큼 매력적인 기능인지에 대한 의문점을 얘기한다.&lt;/p&gt;
&lt;p&gt;SSR이 초기 페이지 렌더링 속도 향상과 SEO를 위해 꼭 적용해야 하는 테크닉처럼 인식되고 있지만, 무조건 적용하면 좋다는 식의 접근보다는 균형 잡힌 접근이 필요함을 확인할 수 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/microsoft/Web-Dev-For-Beginners"&gt;Web Development for Beginners - A Curriculum&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;MS에서 12주, 24개의 강좌로 이루어진 JS, CSS, HTML 기초 수업을 공개했다. 각 강좌마다 퀴즈와 과제, 비디오 등이 포함되어 있어 학습을 돕는다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/alephjs/aleph.js"&gt;aleph&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Next.js 영감을 받은 Deno 런타임을 위한 React 프레임워크로, 기본적으로 ESM import 문법 지원을 통해 Next.js와는 다르게 Webpack 또는 그 외 다른 번들러의 사용이 필요하지 않다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://yqnn.github.io/svg-path-editor/"&gt;SvgPathEditor&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;온라인 SVG path 에디터로, path 값만 넣으면 바로 시각화된 모습을 볼 수 있고 직접 편집점들을 조작해 원하는 형태로 수정할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://spacetime.how/"&gt;spacetime&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;15kb (gizipped) 크기를 갖는 아주 경량화된(moment-timezone은 98kb) timezone 라이브러리로, moment와 유사한 API를 제공한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;let s = new spacetime('January 5 2018', 'Africa/Djibouti');

s.date() // 5
s.isAsleep() // true
s.time() // '2:30pm'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://joshwcomeau.com/operator-lookup"&gt;Operator Lookup&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript의 다양한 연산자들의 사용법과 간단한 예제를 검색해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/Marak/faker.js"&gt;faker.js&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;더미 데이터(fake data)를 생성해 주는 JS 라이브러리이다. address, commerce, company 등 매우 다양한 데이터 형식을 지원한다.&lt;/p&gt;
&lt;p&gt;다음은 Browser와 Node 환경에서의 사용 예시이다:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;script src = &amp;quot;faker.js&amp;quot; type = &amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var randomName = faker.name.findName(); // Caitlyn Kerluke
    var randomEmail = faker.internet.email(); // Rusty@arne.info
    var randomCard = faker.helpers.createCard(); // random contact card containing many properties
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var faker = require('faker');

var randomName = faker.name.findName(); // Rowan Nikolaus
var randomEmail = faker.internet.email(); // Kassandra.Haley@erich.biz
var randomCard = faker.helpers.createCard(); // random contact card containing many properties
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 프로젝트의 높은 인기도와는 상관없이 원 개발자는 프로젝트 메인터넌스를 위한 어려움을 겪고 있는 것으로 보이며, 최근 라이브러리 사용을 원하는 기업들은 비용을 지불하거나 포크 하라고 선언하기도 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Marak/faker.js/issues/1046"&gt;No more free work from Marak - Pay Me or Fork This&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/kpdecker/jsdiff"&gt;jsdiff&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;문자열 비교(diff) Javascript 라이브러리이다. 다음과 같이 간단한 로직으로 문자열 비교 결과를 출력할 수 있다:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;require('colors');
const Diff = require('diff');

const one = 'beep boop';
const other = 'beep boob blah';

const diff = Diff.diffChars(one, other);

diff.forEach((part) =&amp;gt; {
  // green for additions, red for deletions
  // grey for common parts
  const color = part.added ? 'green' :
    part.removed ? 'red' : 'grey';
  process.stderr.write(part.value[color]);
});

console.log();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- raw HTML omitted --&gt;
</content></entry><entry><title>2021-08</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-08.md</id><updated>2022-01-14T04:07:24+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-08.md" rel="alternate"/><published>2021-07-30T02:18:54+00:00</published><content type="html">&lt;h1&gt;2021-08 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://pascalpares.appspot.ovh/webassembly-for-javascript-developers/"&gt;An Introduction to WebAssembly for JavaScript Developers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이 문서는 JavaScript WebAssembly 인터페이스에 대한 소개 글로 JavaScript 코드가 wasm과 어떻게 상호작용하는지와 함께 래퍼(&lt;a href="https://github.com/emscripten-core/emscripten"&gt;Emscripten&lt;/a&gt; 도구 등을 통해 생성된)를 통한 구현 방식에  대해도 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wasm에 관심이 생겼다면, 이어서 15k 라인의 C++ 코드로 작성된 &lt;a href="https://cyberbotics.com/"&gt;렌더링 엔진&lt;/a&gt;을 wasm 변환기 글도 재미있게 읽을 수 있을 것이다.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://medium.com/cyberbotics/porting-a-c-rendering-engine-to-webassembly-9c32d76c31f1"&gt;Porting a C++ Rendering Engine to WebAssembly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/bcoe/esm-doesn-t-need-to-break-the-ecosystem-4p8b"&gt;ESM doesn't need to break the ecosystem&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;오랜 시간 동안 npm 패키지를 다루는 환경에서 개발해 왔다면 모듈 사용과 관련해선 CommonJS(&lt;code&gt;require()&lt;/code&gt;) 문법이 ESM 보다 더 친숙할 것이다. 그러나 CommonJS는 표준 영역에 속하지 않으며, ESM 등장 이후로 전체 생태계는 점진적으로 ESM으로 전환이 이뤄질 것이다.&lt;/p&gt;
&lt;p&gt;이 글은 CommonJS 패키지를 순수 ESM 패키지로 전환하는 방법과 생태계 호환성을 위한 &lt;a href="https://nodejs.org/api/packages.html#packages_dual_commonjs_es_module_packages"&gt;Dual CJS/ESM 모듈 패키지&lt;/a&gt;를 어떻게 만들 수 있는지 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;순수(Pure) ESM 패키지가 무엇인지, 그리고 현실적 이슈들에 대해 궁금하다면 다음 링크를 추가로 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c"&gt;Pure ESM package&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://tsh.io/blog/finite-state-machines-in-react/"&gt;How to use finite state machines in React?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Finite state machines(&lt;a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%95%9C_%EC%83%81%ED%83%9C_%EA%B8%B0%EA%B3%84"&gt;유한 상태 기계&lt;/a&gt;)는 시스템의 상태(행위)를 기술하는데 사용되는 수학적 모델이다. 주어진 객체가 가질 수 있는 모든 상태와 상태 간의 전환을 다루며, 기본 규칙은 상태 시스템은 한 번에 하나의 상태에만 있을 수 있다는 것이다. (현실 세계에서의 예는 신호등을 떠올려 볼 수 있다.)&lt;/p&gt;
&lt;p&gt;이 글은 React 프로젝트의 일반적 상태 관리에서 finite state machine을 사용으로 전환하는 예제를 통해 보다 안정성 높은 코드를 작성하는 방법을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://openjsf.org/openjs-world-2021/"&gt;OpenJS World 2021&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 6월, 리눅스 재단 산하의 OpenJS 재단이 해마다 주최하는 콘퍼런스로 총 6개 트랙의 다양한 양질의 JavaScript 생태계 관련 세션들을 확인해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/arcanis/yarn-3-0-performances-esbuild-better-patches-e07"&gt;Yarn 3.0 🚀🤖 Performances, ESBuild, Better Patches, ...&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;패키지 관리자인 Yarn의 차기 메이저 릴리스인 3.0에 대한 작업이 시작되었고, 어떤 기능들이 포함될지를 소개하는 글이다.&lt;/p&gt;
&lt;p&gt;Yarn 1 → 2로의 마이그레이션 과정에서의 불편함을 제거해, 모든 버전에서 3으로의 마이그레이션을 쉽게 만들고, Node 10+ 이상의 버전을 지원할 계획이라고 밝히고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;a href="https://medium.com/wantedjobs/yarn-berry-%EC%A0%81%EC%9A%A9%EA%B8%B0-1-e4347be5987"&gt;yarn berry 적용기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://alexsidorenko.com/blog/react-render-always-rerenders/"&gt;A Visual Guide to React Rendering - It Always Re-renders&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React 애플리케이션 구조와 상탯값 변경에 따라 컴포넌트별 재 렌더링이 발생하는 과정을 시각적 예제를 통해 보여주고, React.memo를 통해 불필요한 재 렌더링을 방지할 수 있는지 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;상탯값에 이어, props를 다룬 글도 이어서 보면 좋다.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://alexsidorenko.com/blog/react-render-props/"&gt;A Visual Guide to React Rendering - Props&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://exploringjs.com/deep-js/toc.html"&gt;Deep JavaScript: Theory and techniques&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;언어(JavaScript)를 보다 잘 다룰 수 있는 실용적인 기법들과 ECMAScript 스펙에 기반한 언어적 측면에서의 동작과 그 이유에 대해 설명하는 책이다. (HTML 버전은 무료로 제공된다.)&lt;/p&gt;
&lt;p&gt;프레임워크나 도구 환경 등이 아닌 JavaScript를 보다 깊게 이해하고 잘 다루고 싶은 이에게 큰 도움이 될 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://portal.gitnation.org/contents/vite-rethinking-frontend-tooling"&gt;Vite: Rethinking Frontend Tooling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/vitejs/vite"&gt;Vite&lt;/a&gt;는 Vue.js 개발자인 Evan You가 새롭게 개발한 빌드 도구로, 개발 시에는 번들링을 수행하지 않고 ESM을 통해 필요한 모듈만 로딩하고 이후 프로덕션 빌드는 Rollup을 사용한다.&lt;/p&gt;
&lt;p&gt;Evan You는 온라인 세션을 통해 프로젝트의 자세한 배경(기술적 세부사항 및 설계 과정)을 소개하며, Vite를 통해 무엇을 해결하는지 왜 빠른지 그리고 JS 도구 영역에 왜 더 적합한지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://developer.chrome.com/blog/renderingng/"&gt;RenderingNG&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Chrome 개발팀은 지난 8년여의 작업을 통해 Chromium의 Blink 렌더링 엔진을 새롭게 재설계한 아키텍처인 &lt;a href="https://developer.chrome.com/blog/renderingng/"&gt;RenderingNG&lt;/a&gt;(Next Generation)를 공개했다.&lt;/p&gt;
&lt;p&gt;RenderingNG은 보다 안정적인 렌더링 성능을 구현하는 것에 있으며, 예측 가능하고 신뢰할 수 있는 성능, 하드웨어 기능 사용의 극대화, 표시되는 내용에 필요한 작업만을 수행, 렌더링 비용을 관리할 수 있는 개발자 APIs 제공, 비주얼 콘텐츠 최적화 등의 작업이 포함된다.&lt;/p&gt;
&lt;p&gt;RenderingNG는 다양한 주요 프로젝트들(CompositeAfterPaint, LayoutNG, 등)로 구성되어 있으며, 이들에 대해서는 이어지는 시리즈 글을 통해 자세한 내용을 공개할 예정이라고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;보다 자세한 아키텍처는 이어지는 다음 시리즈 글을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://developer.chrome.com/blog/renderingng-architecture/"&gt;Overview of the RenderingNG architecture&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;RenderingNG에 대한 간략한 요약은 다음을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://meetup.toast.com/posts/293"&gt;Chromium이 발표한 RenderingNG가 무엇인가?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://www.bram.us/2019/03/17/the-future-of-css-nesting-selectors/"&gt;The future of CSS: Nesting Selectors&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS 전처리기인 LESS/SASS 등을 사용해 본 경험이 있다면, 중첩 규칙을 통해 상위 선택자와 매칭할 수 있는 &lt;code&gt;&amp;amp;&lt;/code&gt; 규칙에 대해 잘 알고 있을 것이다.&lt;/p&gt;
&lt;p&gt;이를 별도의 도구를 통해 변환 없이 네이티브에서 사용할 수 있게 하는 &amp;quot;Nesting Selector&amp;quot;(CSS Nesting Module) 스펙에 대한 제안으로, 기본적 문법과 사용 예시 등을 소개한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;table.colortable {
  &amp;amp; td {
    text-align: center;
    &amp;amp;.c { text-transform: uppercase }
    &amp;amp;:first-child, &amp;amp;:first-child + td { border: 1px solid black }
  }
  &amp;amp; th {
    text-align: center;
    background: black;
    color: white;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSSWG은 2021/7/7, 관련 제안에 대해 Public Working Draft 발행에 동의해 표준화를 향한 여정이 시작되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS 표준화 프로세스에 대해서는 다음을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://fantasai.inkedblade.net/weblog/2011/inside-csswg/process"&gt;An Inside View of the CSS Working Group at W3C&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/next-gen-css-container/"&gt;Next Gen CSS: @container&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/w3c/csswg-drafts/issues?q=is:issue+label:css-contain-3+"&gt;Containment Level 3 spec&lt;/a&gt;의 일원인 &lt;code&gt;@container&lt;/code&gt; 속성은 부모 컨테이너의 크기를 기준해 요소를 스타일링 할 수 있게 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;사용을 위해선 최신 Chrome(v91+)에서 다음 플래그를 활성화해야 한다.&lt;!-- raw HTML omitted --&gt;
&lt;code&gt;chrome://flags/#enable-container-queries&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/07/dynamic-header-intersection-observer/"&gt;Building A Dynamic Header With Intersection Observer&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;뷰 영역에서 특정 요소가 스크롤 됨에 따라 동적으로 반응하는 UI를 구현하려고 할 때 Intersection Observer API를 활용할 수 있다.
이 글에서 제공하는 데모를 확인해 본다면 Intersection Observer를 더 쉽게 이해할 수 있을 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://codepen.io/michellebarker/full/xxwLpRG"&gt;#Intersection Observer 시각화 도구&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/michellebarker/pen/QWpzwYN"&gt;#동적 헤더 구현&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://jsbooks.revolunet.com/"&gt;JS books&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;무료로 다운로드하거나 읽을 수 있는 다양한 JavaScript 서적들에 대한 목록을 제공한다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dev.to/gitpaulo/journey-of-a-web-page-how-browsers-work-10co"&gt;Journey of a web page 🛣️ - How browsers work&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;사용자가 브라우저에서 웹 주소를 입력하고, 그 결과로 출력되는 웹 페이지 사이에는 어떤 일들이 발생할까?&lt;/p&gt;
&lt;p&gt;브라우저가 동작하는 방식에 대해선 많이 다뤄져 왔지만, 네트워크 레벨에서의 과정과 이후 브라우저에서의 처리 과정들을 순차적 흐름에 따라 내용을 이해할 수 있도록 설명하고 있어 보다 넓은 시각에서 웹을 이해할 수 있도록 도와주는 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/dstrekelj/how-to-write-unit-tests-in-javascript-with-jest-2e83"&gt;How to write unit tests in JavaScript with Jest&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;단위 테스트는 매우 중요하지만, 또한 많은 경우 간과되는 영역이기도 하다. 좋은 품질을 갖는 코드에 대한 이점은 확실히 부정적인 면보다 크지만, 별도의 시간을 들여 단위 테스트를 작성하는 것은 항상 부담스러운 영역이기도 하다.&lt;/p&gt;
&lt;p&gt;아직 단위 테스트 코드 작성에 익숙치 않다면, 이 튜토리얼을 통해 단위 테스트 작성을 시작해 보자.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/blueedgetechno/windows11"&gt;Windows 11 in React&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹 표준 기술(React)을 사용해, 웹에서 Windows 11 데스크톱 버전을 경험해 볼 수 있도록 복제한 프로젝트다.&lt;/p&gt;
&lt;p&gt;https://win11.blueedge.me/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vanilla로 구현한 Windows 7 프로젝트도 참고해 보라.&lt;!-- raw HTML omitted --&gt;
https://desk.glitchy.website/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/nicoespeon/abracadabra"&gt;Abracadabra&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;VS Code에서 제공하는 &lt;a href="https://code.visualstudio.com/docs/editor/refactoring"&gt;기본적 리팩토링&lt;/a&gt;에 더해 리팩토링을 빠르고 안전하게 수행할 수 있는 추가적 기능을 제공하는 플러그인이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;리팩토링 자동화를 위해 제공되는 전체 기능 목록은 다음을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://github.com/nicoespeon/abracadabra/blob/master/REFACTORINGS.md"&gt;List of available refactorings
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://slinky.dev/"&gt;slinky&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Slinky는 Scala로 React 애플리케이션을 작성할 수 있는 프레임워크다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/solidjs/solid"&gt;solid&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Solid는 사용자 인터페이스를 만들 수 있는 선언적이며, 유연한 라이브러리다.&lt;/p&gt;
&lt;p&gt;VDOM을 사용하지 않고 템플릿을 통해 실제 DOM으로 컴파일하며, 상태에 종속된 코드만이 업데이트 되도록 래핑 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// solid로 작성된 간단한 카운터 증가 예제 코드
import { render } from &amp;quot;solid-js/web&amp;quot;;
import { createSignal } from &amp;quot;solid-js&amp;quot;;

function Counter() {
  const [count, setCount] = createSignal(0);
  const increment = () =&amp;gt; setCount(count() + 1);

  return (
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick={increment}&amp;gt;
      {count()}
    &amp;lt;/button&amp;gt;
  );
}

render(() =&amp;gt; &amp;lt;Counter /&amp;gt;, document.getElementById(&amp;quot;app&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;직접 solid 애플리케이션을 작성하고 테스트 해볼 수 있다.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://playground.solidjs.com/"&gt;Solid Playground&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;solid의 보다 자세한 내용은 다음 글을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://dev.to/ryansolid/solidjs-official-release-the-long-road-to-1-0-4ldd"&gt;SolidJS Official Release: The long road to 1.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content></entry><entry><title>2022-01</title><id>https://github.com/naver/fe-news/blob/master/issues/2022-01.md</id><updated>2022-01-05T06:48:12+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2022-01.md" rel="alternate"/><published>2021-12-28T10:22:26+00:00</published><content type="html">&lt;h1&gt;2022-01 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42"&gt;자바스크립트는 왜 프로토타입을 선택했을까?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;플라톤 세계관의 영향을 받아 만들어진 &lt;code&gt;클래스&lt;/code&gt;와 그 세계관에 정면으로 반박하며 만들어진 &lt;code&gt;프로토타입&lt;/code&gt;을 철학적인 방식으로 설명하고 있다.
저자의 이런 독특한 해석은 hoisting, this, lexical scope, prototype을 더욱 명확하게 이해할 수 있게 도와준다.
이 글을 통해 '자바스크립트는 prototype으로 상속한다'라는 잘못된 편견을 버리고 보다 자바스크립트를 잘 이해하는 데 도움이 되길 바란다. 자바스크립트를 이용하여 개발하는 개발자라면 꼭 읽어 보길 적극 권장한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=uQntFkK8Z54"&gt;The Future of Svelte (Interview with Rich Harris)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;'21/11월, Svelte 개발자인 Rich Harris가 Next.js 개발사인 Vercel로의 이직에 대한 &lt;a href="https://vercel.com/blog/vercel-welcomes-rich-harris-creator-of-svelte"&gt;깜짝 발표&lt;/a&gt;가 있었다. 이는 Svelte 생태계에 큰 뉴스일 수밖에 없는 게, Vercel은 React 기반의 Next.js를 개발해오고 있고, 이를 통해 주요 비즈니스를 수행하고 있기 때문이다.&lt;/p&gt;
&lt;p&gt;왜 Vercel 합류를 결정했을까? 그리고 Svelte의 미래는 어떻게 되는 걸까?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://twitter.com/dan_abramov/status/1470613731071696896"&gt;A hundred things I learned working on the react team&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Dan Abramov가 React 개발팀의 일원으로 일하면서 배운 내용들을 100개의 트윗 스레드로 정리한 글이다. 기술적인 내용과 함께 프로젝트 관리, 커뮤니케이션 등 다양한 인사이트를 엿볼 수 있다.&lt;/p&gt;
&lt;p&gt;일례로 50번째 트윗의 내용은 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;50. naming is one of the most important decisions you will be doing. it’s not just bikeshedding. give it appropriate time and effort. you will mess it up anyway though.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 좀 더 편하게 읽고 싶다면, 다음 링크를 방문하라.
https://threadreaderapp.com/thread/1470613731071696896.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/wojtekmaj/enzyme-is-dead-now-what-ekl"&gt;Enzyme is dead. Now what?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React 테스팅 유틸리티인 &lt;a href="https://github.com/enzymejs/enzyme"&gt;Enzyme&lt;/a&gt;을 위한 비공식 React 17 어댑터 프로젝트 &lt;a href="https://github.com/wojtekmaj/enzyme-adapter-react-17"&gt;&lt;code&gt;enzyme-adapter-react-17&lt;/code&gt;&lt;/a&gt; 개발자인 Wojciech Maj의 글로, 현재 Enzyme을 사용하고 있고 앞으로 React 18로 이동을 고려하고 있다면, 왜 Enzyme 이외의 다른 대체재를 당장 찾아야 하는지에 대해 얘기한다.&lt;/p&gt;
&lt;p&gt;자신 또한 인기 있는 다수의 React 프로젝트(&lt;a href="https://github.com/wojtekmaj/react-pdf"&gt;React-PDF&lt;/a&gt;, &lt;a href="https://github.com/wojtekmaj/react-calendar"&gt;React-Calendar&lt;/a&gt;, &lt;a href="https://github.com/wojtekmaj/react-date-picker"&gt;React-Date-Picker&lt;/a&gt; 등)를 개발하고 있고, Enzyme 기반의 단위 테스트를 수행하고 있지만 Enzyme의 React 17 공식 지원을 위한 PR이 오랫동안 머지 되지 않고 있다는 점과 React 18 지원을 위해서는 어댑터 차원만의 수정으로 해결될 수 없다는 점을 근거로 들고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/"&gt;Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Redux maintainer인 Mark Erikson이 React Rendering에 대해 정리한 글이다. 비교적 자세한 설명으로 구성되어 있어, React Rendering 과정에 대해, 그리고 성능 최적화에 대해 보다 높은 이해가 필요한 사람은 읽어보길 추천한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/swyx/why-turborepo-will-be-the-first-big-trend-of-2022-4gfj"&gt;Why TurboRepo Will Be The First Big Trend of 2022&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;크고 작은 여러 프로젝트를 효율적으로 관리하고자 할 때 monorepo를 고민하지만 세팅하고 최적화하는데 많은 리소스를 할애해야 하는 장벽을 마주하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://turborepo.org/"&gt;Turborepo&lt;/a&gt;는 이러한 문제점을 해결하기 위한 JavaScript 및 TypeScript 코드 베이스용 고성능 빌드 시스템으로, 캐싱과 작업 스케줄링 최적화, CPU 리소스를 최대한 활용한 병렬적 처리 등의 기법을 통해 빌드 속도를 85프로 향상시킬 수 있다고 한다. 그리고 &amp;quot;Zero config&amp;quot;를 지향하기 때문에 간편한 설정으로 편리하게 이용할 수 있다고 한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;또한 전통 monorepo 도구들과 차이점으로 pipeline 기능을 제공하는데 이것은 개발자가 명시적으로 작업 관계 및 순서를 지정할 수 있어, 새로운 개발자가 이를 보고 작업흐름을 빠르게 이해할 수 있게 된다. 이 pipeline에 정의된 작업들은 앞서 언급한 CPU의 멀티코어 프로세서를 최대한 활용해 병렬적으로 처리되기 때문에 더 빠른 빌드를 가능하게 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vercel.com/blog/vercel-acquires-turborepo?utm_source=turbo-site&amp;amp;utm_medium=banner&amp;amp;utm_campaign=turbo-website"&gt;Vercel 사의 Turborepo 인수&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=9iU_IE6vnJ8&amp;amp;t=370s"&gt;Turborepo 소개영상&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/channel/UC1hOCRBN2mnXgN5reSoO3pQ/videos"&gt;React Conf 2021&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;'21/12/9일 온라인으로 진행되었던 &lt;code&gt;React Conf 2021&lt;/code&gt;의 모든 세션이 공개되었다. 새롭게 개발 중인 &lt;a href="https://youtu.be/lGEMwh32soc?t=590"&gt;React Forget&lt;/a&gt; (auto-memoizing 컴파일러)와 &lt;a href="https://youtu.be/FZ0cG47msEk?t=1884"&gt;새로운 아키텍처로 React Native 재작성 계획&lt;/a&gt; 등에 대한 내용을 공개했다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://2021.stateofcss.com/"&gt;The State of CSS 2021&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;2021년 전세계 개발자들의 CSS 현황 설문조사 결과가 공개되었다. Front-end 개발자들이 사용하는 CSS 기능, 기술, 도구 등을 통계로 볼 수 있어 CSS 관련 기술과 도구를 선택하는 데에 큰 참고가 될 것이다. 다음은 해당 설문조사에서 볼 수 있는 통계 예시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 프레임워크와 관련해서 &lt;a href="https://tailwindcss.com/"&gt;Tailwind CSS&lt;/a&gt; 사용률이 전년대비 13%로 큰 폭으로 상승했고, &lt;a href="https://getbootstrap.com/"&gt;Bootstrap&lt;/a&gt;이 여전히 사용률 1위를 차지하고 있다.&lt;/li&gt;
&lt;li&gt;98.7%의 개발자가 CSS의 &lt;a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox"&gt;Flexbox&lt;/a&gt; 기능을 사용해 본 적이 있다고 답했다.&lt;/li&gt;
&lt;li&gt;34%의 개발자가 CSS-In-JS 라이브러리를 행복하게 사용하고 있다고 답했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한, 매년 발표하는 JavaScript 현황 설문조사는 2022년 1월에 공개된다고 한다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://studiomeal.com/archives/197"&gt;차세대 CSS 레이아웃&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Flex와 Grid 레이아웃이 등장한 지 꽤 되었지만 능숙하게 잘 사용하기는 쉽지 않다.
저자는 디자이너와 개발자로 일한 경험을 통해 다음의 2개 시리즈 글을 통해 Flex와 Grid의 각 속성들을 그림을 통해 쉽게 이해할 수 있도록 설명한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://studiomeal.com/archives/197"&gt;이번에야말로 CSS Flex를 익혀보자&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://studiomeal.com/archives/533"&gt;이번에야말로 CSS Grid를 익혀보자&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://blog.logrocket.com/how-to-create-nfts-with-javascript/"&gt;How to create NFTs with JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;대체 불가능 토큰(NFT, non-fungible token)은 최근 미래 기술(디지털 자산 거래)로 많은 이들의 관심을 받고 있다.
이 글은 JavaScript로 NTF를 생성하는 방법을 단계별로 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.charpeni.com/blog/array-prototype-group-by-to-the-rescue"&gt;Array.prototype.groupBy to the rescue!&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Array.prototype.GroupBy가 드디어 TC39 stage3으로 변경되었다.
이 글은 기존에 reduce, filter, map 등의 다양한 함수를 이용해야만 GroupBy를 구현할 수 있었던 예를 보여주고 마지막으로 &lt;code&gt;Array.prototyp.groupBy&lt;/code&gt;를 이용하여 구현하는 방법을 보여준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const items = [
  {
    type: &amp;quot;fruit&amp;quot;,
    value: &amp;quot;🍎&amp;quot;,
  },
  {
    type: &amp;quot;fruit&amp;quot;,
    value: &amp;quot;🍇&amp;quot;,
  },
  {
    type: &amp;quot;vegetable&amp;quot;,
    value: &amp;quot;🥕&amp;quot;,
  },
  {
    type: &amp;quot;vegetable&amp;quot;,
    value: &amp;quot;🌶️&amp;quot;,
  },
];
items.groupBy(({ type }) =&amp;gt; type);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/BuilderIO/mitosis"&gt;Mitosis: Write components once, run everywhere&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Mitosis를 사용하면 하나의 컴포넌트 코드로 React, Vue, Angular, Svelte 등 여러 프레임워크의 컴포넌트 코드로 컴파일할 수 있다. &lt;a href="https://mitosis.builder.io/"&gt;Playground&lt;/a&gt;를 통해 어떻게 동작하는지 테스트해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.patterns.dev"&gt;Pattens.dev&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Front-end 개발자를 위한 이보다 좋은 참고 사이트는 없다!
Front-end에서 자주 접하게 되는 &lt;code&gt;디자인 패턴, 랜더링패턴, 성능 패턴&lt;/code&gt;을 시각적인 자료, CodeSandbox 예제와 함께 제공하고 있다.
책까지 무료로 제공하고 있으니 꼭! 보고 학습해 보기 바란다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://www.sitepoint.com/google-zx-write-node-shell-scripts/"&gt;How to Write Shell Scripts in Node with Google’s zx Library&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;zx는 Shell Script를 여러분이 친숙한 JavaScript/TypeScript로 간단하게 프로그래밍할 수 있게 도와주는 라이브러리이다.
인터페이스도 상당히 직관적이라 bash나 zsh 스크립트에 익숙하지 않는 개발자에게는 유용한 라이브러리이다.
이 글은 zx를 이용하여 프로젝트를 생성하는 간단한 빌드 스크립트를 만드는 예제를 다루고 있으니 한번 따라 해보면 zx의 간편함을 몸소 체험해 볼 수 있을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// hello-world-typescript.ts

import { $ } from &amp;quot;zx&amp;quot;;

void (async function () {
  await $`ls`;
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=zYY1hfDEFZk"&gt;Drawing a Christmas Elf with HTML and CSS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;HTML와 CSS만을 이용해서 크리스마스 엘프를 만들어가는 제작 과정의 비디오이다.
gradients, masks, clip-path를 사용해서 하나하나 그려가는 모습을 보면 개발 덕후란 무엇인지 알 수 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
</content></entry><entry><title>2020-03</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-03.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-03.md" rel="alternate"/><published>2020-02-26T09:44:48+00:00</published><content type="html">&lt;h1&gt;2020-03 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/request/request#deprecated"&gt;Request - Simplified HTTP client: Deprecated!&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;24K 깃헙 Star와 매주 18M 건의 다운로드, 그리고 무려 48K 개의 패키지들이 의존하고 있는 인기 HTTP 클라이언트 라이브러리인 'Request'가 지난 2월 20일을 기점으로 deprecate 되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지난 10여 년간(2009년 시작) 유지되었던 이 프로젝트의 개발자인 Mikeal Rogers는 지난 몇 년간 빠르게 변화한 JavaScript 생태계의 변화들로 인해 request의 코어 패턴은 시대에 뒤떨어지게 되었고, 생태계를 위한 최선책은 메인터넌스 모드로 전환하는 것이라고 그 이유를 밝혔다. 보다 자세한 내용은 아래 링크를 통해 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/request/request/issues/3142"&gt;Request’s Past, Present and Future&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;(영상) &lt;a href="https://www.youtube.com/watch?v=bwA9i6wjfhw"&gt;dotJS 2019 - Vladimir Agafonkin - Fast by default: algorithmic performance optimization in practice&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;병목지점을 찾고 왜 느린지 생각하고 빠르게 만들어라!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Javascript에서 퍼포먼스를 향상시키는 방법을 다양한 경험과 예제를 통해 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/naver-fe-platform/some-tips-for-the-web-vr-beginners-ee12002f36bf"&gt;Some Tips for the Web VR Beginners&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;단돈 5 달러만 있어도 VR 콘텐츠를 즐길 수 있는 세상, Web VR 개발 팁을 공유한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web VR을 개발하려고 할 때 어떤 것들을 고민해봐야 하는지 여러 가지 브라우저와 기기의 측면에서 이야기한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://overreacted.io/goodbye-clean-code/"&gt;Good bye, Clean Code&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;클린코드 빌런이 되지는 말자. 클린 코드는 목표가 아니고 단지 프로그램의 복잡성을 줄이고자 하는 시도일 뿐이며, 코드가 어떻게 바뀔지 모르는 상황에서, 피해를 최소한으로 줄이고자 하는 방어 전략 중 하나일 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;코드가 어떻게 보이는지만 보는 게 아니라 다양한 사람들로부터 어떻게 발전시켜 나갈지가 중요하다는 것을 경험을 토대로 이야기한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/a-guide-to-console-commands/"&gt;A Guide to Console Commands | CSS-Tricks&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;console은 간단히 다루기에는 알아야할 것들이 의외로 많다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;우리가 코드를 처음 시작할 때 다뤘던 console의 다양한 활용법, 기능을 자세히 가이드한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://softwareontheroad.com/ideal-nodejs-project-structure/"&gt;Bulletproof node.js project architecture 🛡️&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Express.js는 node.js로 REST API를 개발할 때 정말 좋은 프레임워크이지만, node.js 프로젝트를 어떻게 구성해야 하는지에 대해 그 누구도 알려주지 않는 건 큰 문제다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Express.js 기반의 node 프로젝트를 어떻게 설계/구성해야 하는지 자세하게 설명한다. 한글로 번역된 글(&lt;a href="https://velog.io/@hopsprings2/%EA%B2%AC%EA%B3%A0%ED%95%9C-node.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0"&gt;#바로가기&lt;/a&gt;)도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://uxdesign.cc/the-ultimate-guide-to-proper-use-of-animation-in-ux-10bd98614fa9"&gt;The ultimate guide to proper use of animation in UX&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;사용자 경험(UX)을 위해 애니메이션을 사용하는 경우 고려해야 하는 종합적인 가이드를 제공한다. Timing Function에 따라 적합한 애니메이션들은 무엇인지, 인터페이스 애니메이션의 가장 최적화된 속도는 200~500ms 사이(다수의 &lt;a href="https://valhead.com/2016/05/05/how-fast-should-your-ui-animations-be/"&gt;리포트&lt;/a&gt;에 근거한)라는 내용들을 소개하며, 각 항목 별로 제공되는 애니메이션 예제를 통해 차이점들을 직접 체감해 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex) 속도와 관련해서는 너무 빠르지는 않지만 사용자들의 기다림을 최소화한 속도의 애니메이션 적용의 필요성에 대한 애니메이션 예제
&lt;img src="https://miro.medium.com/max/3840/1*SYWUDqw9jPF4Q--MWqisVg.gif" alt="" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://uxdesign.cc/design-better-forms-96fadca0f49c"&gt;Design Better Forms&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;인생은 짧고 사용자는 폼에 데이터를 넣기 꺼려 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;사용자에게 어떻게 폼을 제공해야 효과적이고 완료율이 높은지 설명하는 글. 현재 프로젝트에서 폼을 개발하고 있다면 필독!&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://uxdesign.cc/7-design-psychologies-every-designer-should-know-d01a1becd961"&gt;7 design psychology fundamentals every designer should know&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;프로덕트를 개발할 때 멘탈모델을 염두해 두면 사용자의 반응을 성공적으로 이끌어 낼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;인간의 7가지 심리적요소를 UX에 어떻게 녹여야 사용자의 좋은 반응이 나오는지 설명해 준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://onezero.medium.com/why-apples-notification-bubbles-are-so-stressful-65a544e51f10"&gt;Why Apple's Notification Bubbles Are so Stressful&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;iPhone의 잠금을 해제할 때마다 시뻘건 알림 벳지로 부터 공격을 받는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나은 UX는 작은 변화로부터 시작된다. 필자가 &amp;quot;인지 과부화&amp;quot;라고까지 일컫는 알림 벳지 스트레스를 어떤 작은 변화로 해결할 수 있는지 이야기한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://brunch.co.kr/@sijin90/50"&gt;네이버 지도 vs 카카오맵 사용자 경험 비교 (Mobile)&lt;/a&gt; / &lt;a href="https://brunch.co.kr/@sijin90/49"&gt;(PC)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;네이버 지도와 카카오맵을 Mobile과 PC 두 플랫폼에서 음성검색, 복사, 즐겨찾기 등 다양한 측면에서 비교한 글.
두 지도 서비스를 모두 설치하고 상황에 따라 적절히 이용하고 있는 필자의 UX에 대한 깊은 인사이트를 엿볼 수 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://stackshare.io/posts/top-developer-tools-2019"&gt;The Top ~~50~~ 100+ Developer Tools 2019&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2019년 한 해동안 StackShare 커뮤니티에서 공유된 4백만 개 이상의 데이터를 분석했고, 프런트/백엔드부터 디자인 툴 그리고 협업 툴까지 18가지의 범주로 분류해서 순위화했다.&lt;/p&gt;
&lt;p&gt;다양한 측면에서 비교를 통해 의미 있는 선택을 할 수 있게 도와주는 참고 자료가 될 것이다.&lt;/p&gt;
&lt;p&gt;stackshare에서는 UBER, Airbnb, Shopify 등 기업들이 사용하는 기술 스택을 확인할 수 있다. &lt;a href="https://stackshare.io/stacks"&gt;링크&lt;/a&gt;에서 내가 사용하는 기술 스택과 다른 기업들이 사용하는 기술 스택을 비교하는 것도 쏠쏠한 재미가 되지 않을까?&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://www.30secondsofcode.org/"&gt;30 seconds of code&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2018년 깃헙 Top 프로젝트로 선정되기도 했던 이 프로젝트는 코드 작성 시 맞닥뜨릴 수 있는 문제들의 해결을 위한 다양하고 짤막한 코드 스니펫 모음들을 제공한다. JavaScript 외에도 CSS, React, Python 등 총 7가지 개발 환경 및 언어들의 분류로 제공된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// ex) 배열 내에 존재하는 교차 값을 구하는 스니펫
const intersectionBy = (a, b, fn) =&amp;gt; {
  const s = new Set(b.map(fn));
  return [...new Set(a)].filter(x =&amp;gt; s.has(fn(x)));
};

intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [2.1]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;추가로 &lt;a href="https://github.blog/2018-12-13-new-open-source-projects/#top-projects-of-2018"&gt;2018년 Top 깃헙 프로젝트&lt;/a&gt;로 선정되었던 다음 프로젝트도 유용하게 참고할만하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leonardomso/33-js-concepts"&gt;33-js-concepts&lt;/a&gt;
JavaScript 개발자들이 알아두면 좋을 주요한 33가지 개념들에 대한 설명글과 동영상들의 방대한 목록을 제공한다.  이들 개념들 중에는 Call Stack, Expression(표현식) vs Statement(문장)의 차이 등을 살펴볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/google-lighthouse/"&gt;Google Lighthouse: Firefox Add-ons&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 브라우저의 기본 성능 측정 도구인 Lighthouse를 이제 Firefox에서도 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/fullcalendar/fullcalendar"&gt;fullcalendar/fullcalendar&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이벤트 drag &amp;amp; drop이 가능한 full-sized 달력이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/myliang/x-spreadsheet"&gt;myliang/x-spreadsheet&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;웹 엑셀. 엑셀 function 도 사용 가능하다.&lt;/p&gt;
</content></entry><entry><title>2020-09</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-09.md</id><updated>2020-09-02T09:56:19+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-09.md" rel="alternate"/><published>2020-09-02T06:29:15+00:00</published><content type="html">&lt;h1&gt;2020-09&lt;/h1&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html"&gt;JavaScript 번들러로 본 조선시대 붕당의 이해&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Javascript의 모듈시스템과 번들러는 종류도 많고 방식도 달라서 처음 진입하는데 어려움이 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 여려운 내용을 쉽게 전달하기 위해 &amp;quot;조선시대 붕당의 이해&amp;quot;라는 짤에 유머러스하게 비유해 제시하고, 시간의 흐름에 따라 설명하고 있다.&lt;/p&gt;
&lt;p&gt;복잡하고 어려운 Javascript의 모듈시스템과 번들러의 이해를 도와줄 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://v8.dev/blog/cost-of-javascript-2019#json"&gt;The cost of parsing JSON&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;아래의 JS 객체 리터럴과 &lt;code&gt;JSON.parse()&lt;/code&gt;를 통한 문자열 파싱 방식들 중, 어떤 것이 성능적으로 더 빠를까?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const data = { foo: 42, bar: 1337 };
const data = JSON.parse('{&amp;quot;foo&amp;quot;:42,&amp;quot;bar&amp;quot;:1337}');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;JSON.parse()&lt;/code&gt;는 파싱, 컴파일 그리고 실행 모든 단계에 있어, 대다수의 JS 엔진에서 객체 리터럴 대비 약 1.7배 이상 더 빠르게 처리된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON의 빠른 파싱을 위해 SIMD(Single Instruction Multiple Data)를 사용해 GB 단위의 데이터를 초당 처리할 수 있는 &lt;a href="https://github.com/simdjson/simdjson"&gt;simdjson&lt;/a&gt; 프로젝트도 흥미로워 보이며, 다양한 바인딩(Node.js 바인딩은 &lt;a href="https://github.com/luizperes/simdjson_nodejs"&gt;simdjson_nodejs&lt;/a&gt;)과 포트들이 제공된다.&lt;/p&gt;
&lt;p&gt;암호화폐 호가 JSON 데이터를 simdjson보다 더 빠르게 파싱하는 C++ 코드를 작성한 경험을 다룬 &amp;quot;&lt;a href="https://tanstaafl.dev/20200821-worlds-fastest-json-parser.html"&gt;세계에서 제일 빠른 JSON 파서 만들기&lt;/a&gt;&amp;quot; 글도 재밌게 읽어볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;다음의 벤치마크와 적용 사례 등도 같이 참고해 보기 바란다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/GoogleChromeLabs/json-parse-benchmark"&gt;JSON.parse benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://joreteg.com/blog/improving-redux-state-transfer-performance"&gt;Improving Redux state transfer performance with JSON.parse(), a quick case study&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://medium.com/better-programming/whats-new-in-typescript-4-fe8d50f08e31"&gt;What’s New in TypeScript 4&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;typescript 4.0 버전이 발표되었다.&lt;/p&gt;
&lt;p&gt;이번 버전에서는 튜플 타입에 라벨링을 할 수 있고 스프레드 오퍼레이터를 제네렉 타입에도 쓸 수 있게되었다. 자세한 내용은 글에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 &lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/"&gt;공식블로그&lt;/a&gt;에서는 보다 더 상세한 내용을 참고할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html"&gt;React v17.0 Release Candidate: No New Features&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React major 버전이 곧 올라간다. 곧바로 추가되는 새로운 기능은 없고, 사용자들이 큰 무리없이 업그레이드를 가능하게끔 하는 것을 중점으로 두었다. 이 외에 document에서 root노드로 이벤트 위임변경 등 여러가지 개선한 내용을 담고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dmitripavlutin.com/what-is-string-in-javascript/"&gt;What Actually is a String in JavaScript?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;다음 출력값은 무엇일까?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(&amp;quot;🥶&amp;quot;.length);
console.log([...&amp;quot;🥶&amp;quot;].length);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;한 이모지이므로 차례로 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;이라고 생각할 수 있겠지만 결과는 &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;이다.
왜 그럴까? 이 글에서는 Javascript가 문자열을 다루는 방식을 설명하고, 어떻게 위와 같은 결과가 도출되는지 간략하게 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=S1wQ0WvJK64"&gt;Why I Don’t Use GraphQL Anymore&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MongoDB 엔지어인 &lt;a href="https://hswolff.com/"&gt;Harry Wolff&lt;/a&gt;가 밝히는 왜 GraphQL을 더 이상 사용하지 않는지에 대한 동영상이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;GraphQL은 매력적이고 FE 개발에 놀라운 기능들을 제공하지만 그에 반해 서버 구현은 매우 어렵다.&lt;/p&gt;
&lt;p&gt;또한 Facebook과 같은 스케일의 서비스에서는 많은 문제들을 해결해 줄 수 있지만, 대다수의 사용자들은 그러한 환경에서 사용하지는 않기 때문이라고 그 이유를 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/better-programming/10-awesome-chrome-flags-you-should-enable-right-now-2684e4518cb5"&gt;10 Awesome Chrome Flags You Should Enable Right Now&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;바로 사용해도 좋은 10가지 크롬 플래그를 소개한다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://sunilsandhu.com/posts/i-created-the-exact-same-app-in-react-and-vue-2020-edition"&gt;I created the exact same app in React and Vue. Here are the differences&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React와 Vue를 이용해서 똑같은 TODO 앱을 만들어 보면서 어떤 점이 다른지, 코드 스타일은 어떤 식으로 차이가 있는지를 설명하고 있다. 2020년 버전으로 React는 Hooks를 Vue(3+)는 Composition API를 사용했다. (2019년, 2018년 버전도 본문 하단 링크에 있다.)&lt;/p&gt;
&lt;p&gt;소스를 올려놓은 저장소 링크도 있으니 코드를 확인하거나 직접 실행해볼 수 있다.&lt;/p&gt;
&lt;p&gt;두 개의 선택지에서 갈등하는 개발자가 읽어보기를 추천한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://typescript-exercises.github.io/"&gt;TypeScript Exercises&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;인터랙티브한 구성을 통해 제공되는 16개의 연습문제를 해결을 통해 아래의 TS 기능들을 학습해 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basic typing.&lt;/li&gt;
&lt;li&gt;Refining types.&lt;/li&gt;
&lt;li&gt;Union types.&lt;/li&gt;
&lt;li&gt;Merged types.&lt;/li&gt;
&lt;li&gt;Generics.&lt;/li&gt;
&lt;li&gt;Type declarations.&lt;/li&gt;
&lt;li&gt;Module augmentation.&lt;/li&gt;
&lt;li&gt;Advanced type mapping.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://youtu.be/U64vIhh0TyM"&gt;Let's build BATTLESHIPS in JavaScript, HTML and CSS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;배틀쉽 게임을 제작하는 과정을 소개한 유튜브 동영상 강의이다.&lt;/p&gt;
&lt;p&gt;1시간 40분간의 강의를 따라서 간단한 게임을 만들어본다면,&lt;/p&gt;
&lt;p&gt;HTML, CSS, JavaScript을 학습함은 물론 큰 성취감을 느낄 수 있을것이다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/mswjs/msw"&gt;Mock Service Worker&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;기존의 mock API 도구 또는 서비스들은 별도로 제공되는 API 주소를 사용하기 때문에, 테스트 용도로써는 유용하지만 실 서비스 단계에서는 실 API로의 업데이트가 필요하다는 단점이 존재한다.&lt;/p&gt;
&lt;p&gt;MSW(Mock Service Worker)는 ServiceWorker를 사용해 네트워크 레벨에서 mocking이 이뤄지기 때문에 실 서비스 API 주소를 테스트 단계에서도 그대로 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import { setupWorker, rest } from 'msw'

const worker = setupWorker(
  // 'https://github.com/octocat'에 대한 mock response를 구성
  rest.get('https://github.com/octocat', (req, res, ctx) =&amp;gt; {
    return res(
      ctx.delay(1500),
      ctx.status(202, 'Mocked status'),
      ctx.json({
        message: 'Mocked response JSON body',
      }),
    )
  }),
)

worker.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://bansal.io/pattern-css"&gt;pattern.css&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;background에 다양한 패턴효과를 줄 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://codepen.io/martinlaxenaire/full/OJVKVYa"&gt;WebGL water ripples&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;WebGL base인 &lt;a href="https://www.curtainsjs.com/"&gt;curtain.js&lt;/a&gt;로 만든 물결효과.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/hediet/vscode-debug-visualizer/blob/master/extension/README.md"&gt;Debug Visualizer&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;디버깅 시 데이터 구조를 시각화해 보여주는 VS Code 확장도구로 JS/TS 및 대다수 언어들을 지원한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JS/TS 외 언어들은 기본적 수준에 한해서만 지원된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
</content></entry><entry><title>2020-10</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-10.md</id><updated>2021-10-06T04:47:40+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-10.md" rel="alternate"/><published>2020-09-23T07:08:10+00:00</published><content type="html">&lt;h1&gt;2020-10  &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html"&gt;Introducing the New JSX Transform&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JSX는 일반 JavaScript 코드로 transpile 되지 않으면, 브라우저는 이해하지 못한다. 따라서 아래 예제 코드와 같이 작성된 코드는 React.createElement를 사용하도록 변환된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;import React from 'react';

// 작성된 코드
function App() {
  return &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;;
}

// 변환된 코드
function App() {
  return React.createElement('h1', null, 'Hello world');
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러나, &lt;code&gt;React.createElement&lt;/code&gt;의 사용은 다음의 2가지 문제가 존재한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React 스코프 내에 있어야 하는 문제 (즉, React import를 필요)&lt;/li&gt;
&lt;li&gt;적용된 일부 &lt;a href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation"&gt;성능 향상과 단순화&lt;/a&gt;를 지원하지 못하는 문제&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새로운 Transform은 &lt;a href="https://babeljs.io/blog/2020/03/16/7.9.0#a-new-jsx-transform-11154httpsgithubcombabelbabelpull11154"&gt;Babel 개발팀과의 협업&lt;/a&gt;을 통해 다음의 이점들을 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React import 없이 JSX를 사용&lt;/li&gt;
&lt;li&gt;번들 크기의 개선(사용자의 설정 환경에 따라 다를 수 있다.)&lt;/li&gt;
&lt;li&gt;학습이 필요한 React의 개념적 부분을 감소시켜 주는 개선을 활성화한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새로운 Transform은 &lt;code&gt;React 17&lt;/code&gt;(향후 0.14.x, 15.x, 16.x 들도 지원 예정)을 통해 사용할 수 있으며, 컴파일러(Babel, TS) 전용 entry point를 제공해 &lt;code&gt;React.createElement&lt;/code&gt; 대신 특별한 함수를 자동으로 import 하고 사용하도록 변환된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;// 작성된 코드 (React import 없이 작성)
function App() {
  return &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;;
}

// 변환된 코드 (아래 모듈은 컴파일러를 통해 자동 import)
import {jsx as _jsx} from 'react/jsx-runtime';

function App() {
  return _jsx('h1', { children: 'Hello world' });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://momentjs.com/docs/#/-project-status/"&gt;We now generally consider Moment to be a legacy project in maintenance mode&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Moment 라이브러리가 더 이상의 기능 추가 없이 유지 보수만 한다.&lt;/p&gt;
&lt;h3&gt;대안 라이브러리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://moment.github.io/luxon/"&gt;Luxon&lt;/a&gt;: Moment의 진화로 생각할 수 있다. 오랜 기간 Moment 컨트리뷰터인 Isaac Cambron이 개발하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://day.js.org/"&gt;Day.js&lt;/a&gt;: 유사한 API를 사용하여 Moment를 최소한으로 대체하도록 설계되었다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://date-fns.org/"&gt;date-fns&lt;/a&gt;: Date 객체를 조작하기 위한 다양한 함수를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://js-joda.github.io/js-joda/"&gt;js-Joda&lt;/a&gt;: JSR-310 기반의 Java SE8 java.time 패키지를 포팅 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://medium.com/@arsenyyankovsky/effective-limited-parallel-execution-in-javascript-ea2a1fb9a632"&gt;Effective limited parallel execution in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;병렬 실행에 효과적으로 제한을 두는 방법이다.&lt;/p&gt;
&lt;p&gt;간단한 예제를 통해서 적절하게 병렬 실행을 제한할 수 있는 방법을 알려 준다.
&lt;a href="https://www.npmjs.com/package/@supercharge/promise-pool"&gt;promise-pool&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://medium.com/swlh/the-ugly-side-of-hooks-584f0f8136b6"&gt;The Ugly Side of React Hooks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;요즘 많은 React 관련 글들이 class component보다는 hooks를 권장하는데, 제목에서 알 수 있듯, 이 글은 그와 반대이다. &lt;a href="https://reactjs.org/docs/hooks-intro.html#motivation"&gt;React 공식 문서에서 말하는 hooks의 motivation&lt;/a&gt;을 하나하나 집으며 비판한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0"&gt;Vue.js 3.0 &amp;quot;One Piece&amp;quot;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;오랜 개발 기간 끝에 드디어 Vue 3.0(코드명 &amp;quot;One Piece&amp;quot;)의 공식 릴리스가 공개되었다. Progressive framework 콘셉트를 지향하는 Vue.js의 새로운 출발을 주목해 보자.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://deno.land/posts/v1.4"&gt;Deno 1.4&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript 런타임인 Deno의 새로운 버전인 1.4가 릴리스가 공개되었다. 이번 릴리스에는 웹소켓 지원과 개발 환경에서 사용할 수 있는 watch 모드 지원이 추가되었다. 점점 실무에서 활발한 사용이 증가할 것으로 기대된다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dev.to/alexi_be3/react-component-patterns-49ho"&gt;React Component Patterns&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;다양한 React Component 패턴(Compound, Flexible Compound 그리고 Provider Pattern)들을 소개하고, 각 패턴들의 사용이 어떤 경우에 적합한지 그리고 각각의 trade-offs 들을 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/streamich/react-use"&gt;React-use hooks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React에서 사용하는 사용자 정의(custom) hook 이다. 유용한 hook이 많이 있으니 개발할 때 만들기 보다 필요한 hook을 찾고 이용해 보면 좋다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/hemanth/logical-assignment-operators-in-javascript-inh?utm_source=ESnextNews.com&amp;amp;utm_medium=Weekly+Newsletter&amp;amp;utm_campaign=2020-09-01"&gt;Logical assignment operators in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;논리 할당 연산자가 (EcmaScript 2021)에 추가될 예정이다. &lt;a href="https://dev.to/hemanth/stage-4-features-5a26"&gt;stage-4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;간략하게 알아보면,&lt;/p&gt;
&lt;h3&gt;OR 연산&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;x ||= y;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;x || (x = y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 표현식은 동일하다.&lt;/p&gt;
&lt;h3&gt;AND 연산&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;x &amp;amp;&amp;amp;= y;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;x &amp;amp;&amp;amp; (x = y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 표현식은 동일하다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.kommit.co/a-gentle-introduction-to-code-splitting-with-react-395ddf44b71b"&gt;A Gentle Introduction to Code Splitting with React&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React를 사용한 프로젝트에서 코드 분할 방법을 설명한다.&lt;/p&gt;
&lt;h3&gt;분할하는 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Route level
&lt;pre&gt;&lt;code class="language-jsx"&gt;import React, { Suspense } from 'react';
import { Location, Router } from '@reach/router';

import Loading from './components/Loading';

const Home = React.lazy(() =&amp;gt; import('./components/Home'));
const AppointmentForm = React.lazy(() =&amp;gt; import('./components/AppointmentForm'));
const PreviousAppointments = React.lazy(() =&amp;gt; import('./components/PreviousAppointments'));

class App extends React.Component {
  render() {
    return (
      &amp;lt;Location&amp;gt;
        {({ location }) =&amp;gt; (
          &amp;lt;Suspense fallback={&amp;lt;Loading /&amp;gt;}&amp;gt;
            &amp;lt;Router location={location}&amp;gt;
              &amp;lt;Home path=&amp;quot;/&amp;quot; /&amp;gt;
              &amp;lt;AppointmentForm path=&amp;quot;/newAppointment&amp;quot; /&amp;gt;
              &amp;lt;PreviousAppointments path=&amp;quot;/previousAppointments&amp;quot; /&amp;gt;
            &amp;lt;/Router&amp;gt;
          &amp;lt;/Suspense&amp;gt;
        )}
      &amp;lt;/Location&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Component level
&lt;pre&gt;&lt;code class="language-jsx"&gt;class PreviousAppointments extends Component {
  constructor(props) {
    super(props);

    this.state = { map: null };

    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    import('./components/Map').then(module =&amp;gt;
      this.setState(() =&amp;gt; ({
        map: module.default,
      })),
    );
  }

  render() {
    const { map: Map } = this.state;

    return (
      &amp;lt;&amp;gt;
        &amp;lt;div&amp;gt;Previous Appointments&amp;lt;/div&amp;gt;
        ...
        {Map ? &amp;lt;Map /&amp;gt; : &amp;lt;button onClick={this.handleClick}&amp;gt;Show Map&amp;lt;/button&amp;gt;}
      &amp;lt;/&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;두 분할 방법을 잘 이용해서 성능을 높이고 사용자 경험을 최적화 시키자.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/tc39/proposal-decorators"&gt;Decorators&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2020년 9월에 제시된 데코레이터들이다.&lt;/p&gt;
&lt;p&gt;몇 가지만 살펴보면,&lt;/p&gt;
&lt;h3&gt;@logged&lt;/h3&gt;
&lt;p&gt;메서드의 시작과 끝에 로그를 출력한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import { logged } from &amp;quot;./logged.mjs&amp;quot;;

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) { }
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;@tracked&lt;/h3&gt;
&lt;p&gt;필드 값을 추적(tracking)해 값의 변경이 발생되면, render 메서드를 트리거 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import { tracked } from &amp;quot;./tracked.mjs&amp;quot;;

class Element {
  @tracked counter = 0;

  increment() { this.counter++; }

  render() { console.log(counter); }
}

const e = new Element();
e.increment();  // logs 1
e.increment();  // logs 2

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/GoogleChromeLabs/comlink"&gt;Comlink&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;예제 코드 이미지 (클릭하면 확대해서 볼 수 있다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;크롬 개발팀에서 공개한 아주 작은 크기(1.1kb)의 라이브러리로, WebWorkers 사용에 대한 초기 접근 장벽을 제거해 준다. 좀 더 추상적 수준에서 보자면, postMessage와 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"&gt;ES6 Proxies&lt;/a&gt;에 대한 &lt;a href="https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C"&gt;RPC&lt;/a&gt; 구현이라 할 수 있다.&lt;/p&gt;
&lt;p&gt;Webpack을 번들러로 사용하고 있다면 &lt;a href="https://github.com/GoogleChromeLabs/comlink-loader"&gt;comlink-loader&lt;/a&gt;를 같이 사용해, 코드의 일부 수정(또는 없이)을 통해 사용되는 모듈들을 WebWorkers 스레드에서 실행될 수 있도록 만들 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://cli.github.com/"&gt;GitHub CLI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;GitHub의 공식 CLI 도구로 Beta 기간을 끝내고, 얼마 전 1.0 버전을 선보였다. 터미널 상에서 GitHub PR을 만들거나 관리도 할 수 있다.&lt;/p&gt;
</content></entry><entry><title>2021-12</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-12.md</id><updated>2021-12-01T05:22:01+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-12.md" rel="alternate"/><published>2021-11-26T09:13:17+00:00</published><content type="html">&lt;h1&gt;2021-12 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://deview.kr/2021"&gt;DEVIEW 2021&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;국내 개발자 콘퍼런스인 DEVIEW 2021이 지난 11월 24일 ~ 26일 3일간 진행되었다.&lt;/p&gt;
&lt;p&gt;키노트를 포함한 모든 세션 영상이 공개되어 확인해 봐도 좋을 듯하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] &lt;strong&gt;DEVIEW 2021 Front-end 세션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/518"&gt;Inside React (동시성을 구현하는 기술)&lt;/a&gt;&lt;br /&gt;
React의 방향성을 함께 살펴보며 Concurrent Rendering과 그 기반 기술에 대해 연구한 내용을 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/443"&gt;Next.js, Apollo와 함께 리액트 개발의 Next Level로 가자!&lt;/a&gt;&lt;br /&gt;
이전에 사용하던 기술 스택과 Next.js와 Apollo Client를 비교해 보고, 새 기술을 도입하며 겪은 경험을 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/499"&gt;React, Vue, Svelte… 변화하는 프레임워크 속에서 컴포넌트 발전하기&lt;/a&gt;&lt;br /&gt;
다양한 프레임워크에서 동작하는 Cross Framework Component을 2년간 운영하면서 겪었던 다양한 고민들과 경험들을 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/508"&gt;The state of JavaScript &amp;amp; FE, 2021 Edition (2021년 FE 동향, 한방에 끝내기)&lt;/a&gt;&lt;br /&gt;
2021년 Front-end는 어느 방향으로 나아가고 있을까? 2021년 한 해의 변화들을 확인해 본다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/429"&gt;WhateverBuilder - HomeBuilder로 만드는 웹의 모든것&lt;/a&gt;&lt;br /&gt;
사이트 제작 플랫폼 HomeBuilder에서 연결, 편집, 확장이라는 문제에 대해 Front-end, Back-end에서 어떤 고민들을 했고 어떻게 문제를 해결했는지 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/521"&gt;그치만...이렇게 하지 않으면 넷플릭스가 관심을 주지 않는걸 (시리즈온 TV App 개발기)&lt;/a&gt;&lt;br /&gt;
네이버 웹툰의 OTT 서비스인 시리즈온 TV App을 오픈하며 겪은 개발 경험을 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/454"&gt;네이버 검색의 Server Driven UI - LAPIN&lt;/a&gt;&lt;br /&gt;
기존 Front-end 업무 프로세스를 개선하여 빠르고 효율적으로 기능을 제공하기 위해 실제 경험을 바탕으로 알게 된 노하우와 팁을 설명한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/483"&gt;데이터 시각화의 꽃 APM FE 개발 이야기&lt;/a&gt;&lt;br /&gt;
APM에서 Front-end 개발은 어떤지 소개하고, APM에서 사용되는 다양한 UI 컴포넌트들의 난제와 이를 어떻게 해결하고 있는지 노하우와 팁을 공유한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/507"&gt;슬기로운 웨일앱 개발&lt;/a&gt;&lt;br /&gt;
웨일 플랫폼에서 사용할 수 있는 웨일앱을 만드는 과정과 배포, 유지 보수하는 방법을 이야기한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/421"&gt;웹과 브라우저를 위한 프로파일링과 성능 개선&lt;/a&gt;&lt;br /&gt;
웨일 브라우저와 웹페이지 성능을 개선했던 경험을 공유하며 프로파일링 방법에 대해 소개한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deview.kr/2021/sessions/413"&gt;피그마 API로 하나 되는 우리 : 피그마 API를 활용해 협업 효율성 올리기&lt;/a&gt;&lt;br /&gt;
Figma와 Figma API의 특성을 이해하고 실제로 현업에서 협업의 효율성을 높이기 위해 Figma API를 활용한 사례와 팁을 소개한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://nanxiaobei.medium.com/react-split-components-a-new-way-of-function-components-without-hooks-f256411d2d55"&gt;React Split Components: A new way of Function Components without Hooks&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React 16.8에서 Hook이 등장한 이후로 이제 대부분의 React 개발은 클래스 컴포넌트에서 함수 컴포넌트로 넘어가는 추세이다.
하지만 Hook은 초심자에게 React를 더욱 어렵게 만드는 요소이기도 하다.&lt;/p&gt;
&lt;p&gt;이 글에서는 이러한 Hook들을 래핑 하여 좀 더 쉽게 개발할 수 있도록 하는 &lt;code&gt;RiC&lt;/code&gt;(React Split Component)라는 라이브러리를 만드는 과정을 보여준다.&lt;/p&gt;
&lt;p&gt;각 구현 과정을 한 단계씩 자세히 설명하며 진행하는데, 무엇보다 구현 방식이 재미있으니 한번 읽어보길 추천한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://developer.chrome.com/docs/devtools/recorder/"&gt;Record, replay and measure user flows&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 97의 새로운 기능으로 recorder 패널이 추가되었다. 사용자의 액션을 녹화하고 이를 다시 확인해 볼 수 있는 기능이다.
단순 녹화뿐만 아니라 저장한 사용자의 액션을 수정할 수도 있기에 다양한 용도로 사용될 수 있는 기능이라 생각한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://maxkim-j.github.io/posts/suspense-argibraic-effect"&gt;Suspense for Data Fetching의 작동 원리와 컨셉 (feat.대수적 효과)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;기존의 명령적인 비동기 처리는 코드의 가독성을 떨어뜨리기 쉽다.
그래서 Suspense와 ErrorBoundary를 이용하여 선언적 비동기 처리 방식으로 코드를 사용하기도 한다.
이 글에서는 Suspense를 이용한 data fetching의 동작 원리를 살펴보고 이를 통해 대수적 효과에 대해 이해한 작가의 멘탈 모델을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1"&gt;CS Visualized: Useful Git Commands&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git의 명령어를 시각적으로 잘 설명한 글이다.
Git에 익숙한 사용자든 익숙하지 않은 사용자든 Git 명령어를 보다 잘 이해하는 데 도움 되는 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://yozm.wishket.com/magazine/detail/1176"&gt;스벨트 vs 리액트, 누가 더 뛰어날까?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;다소 자극적인 제목으로, 간단하게 Svelte와 React를 비교한 글이다.
React와는 익숙하지만 Svelte는 생소한 개발자들이 React와 비교를 통해 Svelte에 대한 대략적인 이해를 얻을 수 있을 거라 생각한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.proposals.es/"&gt;proposals.es&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ECMAScript proposal들을 한눈에 볼 수 있는 사이트이다.&lt;/p&gt;
&lt;p&gt;각 stage 별로 진행 중인 proposal들을 볼 수 있으며 원하는 proposal을 검색해 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://leerob.io/blog/rust"&gt;Rust Is The Future of JavaScript Infrastructure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mozilla에서 만든 저수준 프로그래밍 언어인 Rust가 JavaScript 언어를 대신해서 JavaScript 도구 생태계의 많은 부분을 대체하고 있다.
그 대표적인 예는 &lt;a href="https://swc.rs/"&gt;SWC&lt;/a&gt;, &lt;a href="https://deno.land/"&gt;Deno&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Rust가 JavaScript 도구 생태계에 많은 부분을 차지하고 있는 이유를 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/"&gt;Under-the-hood-ReactJS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;시각적 블록 방식으로 React 내부에서 어떻게 동작하는지 코드 기반으로 설명한다. 총 15개의 섹션으로 구분되어 있으며, 문서는 Stack Reconciler를 사용하는 React 15.4.2에 기반해 설명한다. 최신 버전의 React는 아니지만, React 내부 동작 방식에 대한 궁금증을 해결해 줄 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/tree/master/stack/languages/korean/book"&gt;한글 번역&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;추가적으로 React의 기본 기능과 구조를 기반으로 설명하는 다음의 글도 유용하다.
&lt;a href="https://bluewings.github.io/build-your-own-react/"&gt;나만의 리액트 라이브러리 만들기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@kimbyungchan/canvas-starcraft"&gt;Canvas StarCraft&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;HTML canvas element를 이용해 스타크래프트 유닛 선택 및 이동을 흉내 내어 구현한 글이다.&lt;/p&gt;
&lt;p&gt;GIF와 함께 자세한 구현 내용이 담겨 있으니 참고해 보면 좋을 듯하다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/alexeagleson/how-to-create-and-publish-a-react-component-library-2oe"&gt;How to Create and Publish a React Component Library&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Custom React Component를 만들고 NPM을 통해 배포하는 방법에 대한 글이다.&lt;/p&gt;
&lt;p&gt;한 단계씩 자세히 설명하여 Custom React Component를 만들어 보고 싶은 사람이라면 누구라도 쉽게 따라 할 수 있을 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://regexlearn.com/"&gt;RegexLearn&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;정규 표현식을 interactive 하게 배울 수 있는 사이트이다.
총 55개의 문제를 간단한 설명을 통해 학습하고 풀어 볼 수 있다.
Playground는 준비 중이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.joshfinnie.com/blog/using-webassembly-created-in-rust-for-fast-react-components/"&gt;Using WebAssembly (created in Rust) for Fast React Components&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;보다 빠른 React 컴포넌트 개발을 위해 wasm(Rust로 작성된)을 사용할 수 있는 방법을 설명하며, Rust를 사용해 wasm 컴파일 방법과 이후 프로젝트에서 wasm을 다루기 위한 설정 방법 등 각 단계별 필요한 작업들을 소개한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/joshfinnie/rusty-react"&gt;예제 코드 저장소&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import React, { useState } from &amp;quot;react&amp;quot;;
import ReactDOM from &amp;quot;react-dom&amp;quot;;

const wasm = import(&amp;quot;../build/rusty_react&amp;quot;);

wasm.then(m =&amp;gt; {
  const App = () =&amp;gt; {
    const [name, setName] = useState(&amp;quot;&amp;quot;);
    ...
    return (
      &amp;lt;&amp;gt; ...  &amp;lt;/&amp;gt;
  };

  ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&amp;quot;root&amp;quot;));
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://hasty.dev/"&gt;Hasty: A JavaScript Snippet Perfomance Comparison Tool&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript의 특정 함수에 대해 간단하고 빠르게 성능을 측정할 수 있도록 도와주는 웹사이트다.
비슷한 도구로는 &lt;a href="https://perf.link"&gt;perf.link&lt;/a&gt;와 &lt;a href="https://jsbench.github.io"&gt;jsBench&lt;/a&gt;가 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://fxts.dev/"&gt;FxTS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;국내 회사인 Marpple에서 공개한 TypeScript 함수형 프로그래밍 라이브러리이다.
아직 Beta 버전이긴 하지만 지연 평가, 동시성 제어, 타입 추론, 에러 처리 등에서 강점을 가진다고 한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://react-spectrum.adobe.com/index.html"&gt;React Spectrum Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Adobe에서 만든 React UI 라이브러리이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://app.netlify.com/drop"&gt;Netlify Drop&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;정적 웹 사이트 배포로 유명한 &lt;a href="https://www.netlify.com/"&gt;Netlify&lt;/a&gt;에서 Netlify Drop이란 서비스를 공개했다.&lt;/p&gt;
&lt;p&gt;이를 통해 HTML, CSS, JavaScript로 구성된 폴더를 drag and drop하여 올리면 간단히 배포가 진행되고 URL을 통해 접근해 확인해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://remix.run/"&gt;Remix&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Remix는 지난 1년여 전 &amp;quot;sponsorware&amp;quot; 형태로 시작해 스폰서십 참여자들만 제한적 사용 라이선스가 부여되었던 SSR을 지원하는 새로운 React 기반 프레임워크다. React 생태계에서 라우팅 라이브러리로 유명한 &lt;a href="https://reactrouter.com/"&gt;React Router&lt;/a&gt;를 개발한 &lt;a href="https://github.com/mjackson"&gt;Michael Jackson&lt;/a&gt;이 참여하고 있어, 생태계에서 높은 관심과 주목을 받고 있었고 최근의 &lt;a href="https://remix.run/blog/seed-funding-for-remix"&gt;3백만 달러의 시드 펀딩&lt;/a&gt; 투자를 통해 모든 이들이 사용할 수 있도록 MIT 라이선스로 변경되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Remix에 대한 보다 자세한 내용은 다음 링크를 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=r4B69HAOXnA"&gt;Remix is a NEW JavaScript framework you MUST try&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=hsIWJpuxNj0"&gt;Remix Tutorial with Kent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=A9frCHnOeHo"&gt;Remix.run | Reviewing Remix: an Edge-first Web Framework for React&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/berstend/puppeteer-extra/tree/master/packages/puppeteer-extra"&gt;puppeteer-extra&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;puppeteer-extra는 Puppeteer의 &lt;a href="https://en.wikipedia.org/wiki/Drop-in_replacement"&gt;drop-in replacement&lt;/a&gt; 래퍼로 다양하고 유용한 플러그인을 활용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const puppeteer = require(&amp;quot;puppeteer-extra&amp;quot;);

// puppeteer-extra-plugin-stealth 플러그인은 다양한 회피 기술을 통해 puppeteer(headless)의 탐지를 어렵게 만든다.
const StealthPlugin = require(&amp;quot;puppeteer-extra-plugin-stealth&amp;quot;);

puppeteer.use(StealthPlugin());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/yurkagon/Doom-Nukem-CSS"&gt;Doom Nukem CSS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;일반적으로 웹에서의 게임은 Canvas를 사용해 구현하는 것이 일반적이다. 이 프로젝트는 4년 전 시작되어 FPS 게임의 시초라 할 수 있는 Doom을 Canvas가 아닌 HTML/CSS/TypeScript만을 활용해 구현한 것이 특징이다. 직접 개발한 &lt;a href="https://github.com/yurkagon/ReactCasting"&gt;ReactCasting&lt;/a&gt; HTML &lt;a href="https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%A0_%ED%88%AC%EC%82%AC"&gt;광선 투사&lt;/a&gt;(Ray Casting) 엔진을 사용했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://yurkagon.github.io/Doom-Nukem-CSS/"&gt;Live demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/type-challenges/type-challenges"&gt;Type&amp;lt;Challenge[]&amp;gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript에 익숙해지고 싶은 분들을 위한 사이트.
해결해야 할 타입 문제를 주고 TypeScript Playground에서 도전해 볼 수 있다.
TypeScript를 익히는데 많은 도움이 되는 사이트이다.&lt;/p&gt;
</content></entry><entry><title>2021-07</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-07.md</id><updated>2021-07-12T06:40:14+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-07.md" rel="alternate"/><published>2021-06-28T02:18:25+00:00</published><content type="html">&lt;h1&gt;2021-07 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@jay/React-18-%EB%B3%80%EA%B2%BD%EC%A0%90"&gt;React 18 변경점&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2021.6.8 React 공식 페이지에서 &lt;a href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html"&gt;React 18에 대한 계획&lt;/a&gt;을 공유하였다. 이 글은 React 18에서 변경될 Suspense ssr architecture, State batch update, Transition 에 대해 설명한 글이다.&lt;/p&gt;
&lt;p&gt;기존에는 개발자가 직접 제어해야하거나 제약이 있던 SSR 랜더링 부분이 pipeToNodeWritable, Suspense와 Lazy를 통해 React 단위에서 효과적으로 적용할 수 있게 된다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;기존에 부분 적용되었던 State batch update도 api 요청, timeout과 같은 비동기 작업 내에서도 자동 적용된다. 뿐만아니라 상태 업데이트의 우선순위를 정할 수 있는 startTransition 인터페이스도 제공한다.&lt;/p&gt;
&lt;p&gt;React 18은 기존 Major 버전 업그레이드와 동일하게 어플리케이션 코드 변경 없이 손쉽게 적용할 수 있기에 정식 릴리즈가 되면 부담없이 적용해 보면 좋을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서 전체를 살펴보기 부담스럽다면, 다음의 12개 트윗으로 정리된 요약본을 확인하라.&lt;br /&gt;
https://twitter.com/ProvablyFlarnie/status/1406729279317045248&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project React 18 릴리즈 일정은 다음을 참고하기 바란다.&lt;br /&gt;
https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html#projected-react-18-release-timeline&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://medium.com/geekculture/react-5-things-that-might-surprise-you-ddefd9fbac0f"&gt;React — 5 Things That Might Surprise You&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React에 대해 잘못 사용하고 있을 만한 5가지 내용을 다루고 있다. 이 글에 나온 예시를 통해 조금 더 React를 잘 이해하길 바란다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6"&gt;5 Advanced React Patterns&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;단순한 Counter 예제를 바탕으로 5가지 React 패턴을 제어의 역전, 구현 복잡도 기준으로 설명한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/"&gt;Why React Hooks cannot be conditioned&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React hooks와 함께 &lt;a href="https://github.com/facebook/react/tree/master/packages/eslint-plugin-react-hooks"&gt;eslint-plugin-react-hooks&lt;/a&gt;을 사용해봤다면, &lt;code&gt;React Hook &amp;quot;useState&amp;quot; is called conditionally.&lt;/code&gt;와 같은 예기치 않은 경고 메세지와 맞닥뜨린 경험이 있을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function Component({ doEffect }) {
  // {value: 0, next: {value: 0, next: null}}
  const [first, setFirst] = useState(0);
  if (doEffect) {
    // {value: 0, next: null}
    useEffect(/*...*/); // ⚠️ Wrong hook here
  }
  // null
  const [second, setSecond] = useState(0); // ⚠️ No hook left!!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 글은 Hooks가 왜 조건식을 통해 사용될 수 없는지를 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://nextjs.org/blog/next-11"&gt;Next.js 11 정식 릴리즈&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next.js 11이 2021.6.16 정식 릴리즈 되었다. 11 버전에서는 React Fast Refresh 를 개선하여 시작 시간을 최대 24% 개선하였고, 변경 처리시간을 40% 단축 시켰다. 뿐만아니라 기본 번들러 도구로 Webpack5를 제공함으로써 Webpack5의 장점을 Next.js 11에서도 체감할 수 있다.&lt;br /&gt;
또한 &lt;code&gt;next/script&lt;/code&gt;, &lt;code&gt;next/image&lt;/code&gt;와 같은 모듈도 제공하여 손쉽게 스크립트 제어와 이미지 플레이스 홀더 제어를 할 수 있게 되었다.
그 외에 Create React App Migration, Next.js Live 기능을 실험적으로 이용할 수 있게 되었다.&lt;/p&gt;
&lt;h2&gt;ES2021&lt;/h2&gt;
&lt;p&gt;2021.6.22 ES2021 스펙이 정식 승인 되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logical Assignment Operators (&amp;amp;&amp;amp;= ||= ??=)&lt;/li&gt;
&lt;li&gt;Numeric Separators (1_000)&lt;/li&gt;
&lt;li&gt;Promise.any &amp;amp; AggregateError&lt;/li&gt;
&lt;li&gt;String.prototype.replaceAll&lt;/li&gt;
&lt;li&gt;WeakRefs &amp;amp; FinalizationRegistry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ES2021 스펙의 간단한 예제는 다음 링크를 통해 살펴볼 수 있다.&lt;br /&gt;
https://h3manth.com/ES2021/&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/06/how-to-fix-cumulative-layout-shift-issues/"&gt;How To Fix Cumulative Layout Shift (CLS) Issues&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이미지 크기 부터 폰트, JavaScript 적용등 다양한 영역에서 발생 할 수 있는 CLS 이슈 해결 방법을 조목 조목 설명하고 있다. 개발하고 있는 서비스에 차근차근 적용해보기 좋은 글이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://web.dev/css-web-vitals/"&gt;CSS For Web Vitals&lt;/a&gt; 글도 함께 참고하기 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://web.dev/better-responsiveness-metric/"&gt;Towards a better responsiveness metric&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;사용자 반응성에 영향을 미칠수 있는 metric로 FID(First Input Delay)를 살펴보고 사용자 반응성을 높일 수 있는 몇가지 아이디어를 기술하고 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://web.dev/introducing-aurora/"&gt;Introducing Aurora&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;크롬 엔지니어(내부 코드명 WebSDK)팀 은 지난 2년간 주요 오픈소스 프레임워크/도구들과의 협업을 통해 더 나은 사용자 경험을 제공하기 위한 노력을 해왔으며, 지난 6월 15일 이를 &amp;quot;Aurora&amp;quot;라 명명했다.&lt;/p&gt;
&lt;p&gt;목표는 단순하다. 앱이 어떤 브라우저에서 렌더링 되는 것인지 상관없이, 가장 뛰어난 사용자 경험을 제공하는 것이며, 앞으로 몇 개월간 보다 자세한 내용들을 공개할 예정임을 밝혔다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Aurora의 첫 번째 작업은 &amp;quot;Comformance&amp;quot;라 불리며, JavaScript 프레임워크 생태계에 집중해 예측 가능한 로딩 성능과 &lt;a href="https://web.dev/vitals/#core-web-vitals"&gt;Core Web Vitals&lt;/a&gt; 점수를 높일 수 있도록 코딩 모범사례를 구현할 수 있도록 도움을 주는 것에 목표를 두고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.dev/conformance/"&gt;Conformance for Frameworks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://www.w3.org/community/webextensions/2021/06/04/forming-the-wecg/"&gt;Forming the WebExtensions Community Group&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;지난 수년간 브라우저 확장 익스텐션(플러그인)들의 사용의 증가와 함께 다수 브라우저들에서의 상호 호환 모델 채택 등의 움직임에 따라 확장 익스텐션의 표준화된 접근의 필요성이 대두되었고, 이를 위해 W3C 산하 WebExtenstions Community Group(WECG)가 지난 6월 4일 주요 브라우저 벤더들인 Apple, Google, MS 그리고 Mozilla가 참여를 통해 만들어졌다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.matthewgerstman.com/tech/history-of-the-web/"&gt;History of the Web: Part 1&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;저자의 지난 20년간 웹 영역에서의 기술적 경험을 바탕을 통해 웹의 역사를 간략하게 정리한 내용의 글이다.&lt;/p&gt;
&lt;p&gt;웹을 구성하는 요소들이 어디에서부터 시작되었는지를 알게 되면, 어디로 가야 하는지 알 수 있기 때문에 지난 역사에 대한 문맥을 아는 것이 중요하다고 생각해 글을 작성하게 되었다고 그 이유를 밝히고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://developer.mozilla.org/en-US/plus"&gt;MDN Plus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MDN에서는 업계의 전문가들이 참여하는 월간 심층 기술적 문서를 제공하는 새로운 유료(월 $10 또는 연 $100 정도의) 프리미엄 서비스인 &amp;quot;MDN Plus&amp;quot;를 계획하고 있다. 기존의 MDN Web Docs는 어떠한 변화도 없이 기존과 같이 무료로 제공될 것임을 밝히고 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://www.euismod.dev/"&gt;Anyone Can Learn CSS Grid&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;CSS Grid의 핵심 요소들을 배울 수 있다. 직접 Grid 속성들에 대한 값을 입력해 렌더링 결과를 즉시 확인할 수 있어, 매우 직관적인 학습을 진행할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/generating-and-solving-sudokus-in-css/"&gt;Generating (and Solving!) Sudokus in CSS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript 한 줄 없이 스도쿠를 구현한 튜토리얼이다. CSS를 이용한 프로그래밍을 경험해 보기에는 충분한 튜토리얼이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/concrete-utopia/utopia"&gt;Utopia&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;디자인과 개발 환경(VSCode)이 통합된 온라인 React 개발 환경 도구로 제공되는 디자인 도구와 작성된 코드를 통해 실시간 편집과 완성된 결과를 미리 보기를 통해 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;아직 개발 초기 단계지만, 직접 사용해 볼수 있다. 보다 자세한 내용은 &lt;a href="https://utopia.app/blog"&gt;Introducing Utopia&lt;/a&gt;를 통해 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://domevents.dev/"&gt;The DOM Event Visualizer&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;프레임워크의 사용이 보편화되면서, DOM 이벤트가 어떻게 흐르는지 세부적인 내용을 이해하지 못한 채 이벤트를 다루고 있는 것이 현실이다. 직접적으로 다루지는 않더라도, 이벤트 처리의 본질적인 것은 달라지지 않기 때문에 보다 깊은 이해를 위해선 DOM에서 이벤트가 어떻게 동작하는지를 아는 것은 중요하며, 링크를 통해 제공되는 도구를 통해 시각적인 이벤트 흐름을 쉽게 확인해 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DOM 이벤트에 대해 보다 깊게 이해하고 싶다면, 다음의 무료 온라인 강의 동영상을 참고하라.&lt;br /&gt;
&lt;a href="https://egghead.io/courses/the-ultimate-guide-for-understanding-dom-events-6c0c0d23"&gt;Your Ultimate Guide to Understanding DOM Events&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://yare.io/"&gt;yare.io&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript 코드 작성을 통해 유닛을 제어하는 실시간 전략 게임이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://gchq.github.io/CyberChef/"&gt;CyberChef&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;사이버상의 &amp;quot;스위스 아미 나이프&amp;quot;를 표방해, 입력값에 대한 다양한 변환작업(암호화, 인코딩, 등)을 손쉽게 수행할 수 있는 웹 도구다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/n8n-io/n8n"&gt;n8n&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Node 기반의 워크플로우 자동화 도구다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아래의 데모 동영상에선, GitHub Star에 대한 Slack 알림을 받는 자동화 구성방법을 확인할 수 있다.
&lt;a href="https://www.youtube.com/watch?v=3w7xIMKLVAg"&gt;n8n.io - Slack Notification on Github Star&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://lighthouse-metrics.com/"&gt;Lighthouse Metrics&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;간단하게 사이트의 Lighthouse Metrics를 지역별로 확인해 볼 수 있다. 내가 개발 중인 서비스의 성능 지표를 손쉽게 확인해보자.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/google-map-react/google-map-react"&gt;Google Map React&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Google Map React를 사용하면, 구글 지도 위에 어떠한 React 컴포넌트라도 렌더링 할 수 있도록 구성할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://s-kngstn.github.io/wu-loremipsum/"&gt;Wu Tang Lorem Ipsum Text Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Vanilla JavaScript로 작성된 텍스트 생성기로 테스트 용도로 간편하게 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments"&gt;Better Comments&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VS Code Extension으로 Alerts, Query, TODO, Highlight와 같은 다양한 종류의 커멘트를 편집기에서 표현할 수 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=vincaslt.highlight-matching-tag"&gt;Highlight Matching Tag&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;HTML 태그 짝을 시각적으로 표시해주는 VS Code Extension 이다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://github.com/depcheck/depcheck"&gt;depcheck&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;depcheck를 통해 실제 사용하지 않거나 누락된 npm 모듈을 확인 할 수 있다. CI에 도입하면 좋은 라이브러리이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;$&amp;gt; depcheck /path/to/my/project
Unused dependencies
* underscore
Unused devDependencies
* jasmine
Missing dependencies
* lodash
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>2020-08</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-08.md</id><updated>2020-07-22T07:36:20+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-08.md" rel="alternate"/><published>2020-07-22T07:36:20+00:00</published><content type="html">&lt;h1&gt;2020-08  &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10665/"&gt;Safari Web Extensions&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 WWDC 행사에서 차기 OS인 Big Sur에서 Chrome, Firefox, Edge 등과 대부분 호환되는 확장 기능 API인 &amp;quot;Safari Web Extensions&amp;quot;에 대한 지원(&lt;a href="https://webkit.org/blog/10875/release-notes-for-safari-technology-preview-109-with-safari-14-features/"&gt;Safari 14&lt;/a&gt;)을 발표했다.&lt;/p&gt;
&lt;p&gt;작성된 확장 기능은 Native 앱으로 패키징 된 후, 앱스토어를 통해 호스팅 될 수 있으며, 다른 브라우저들의 기존 확장 기능 앱들은 Xcode 12(&lt;a href="https://developer.apple.com/documentation/safariservices/safari_web_extensions/converting_a_web_extension_for_safari"&gt;safari-web-extension-converter&lt;/a&gt;)를 통해 Safari에서 실행 가능하도록 손쉽게 변화될 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;Mozilla는 이번 결정에 &lt;a href="https://hacks.mozilla.org/2020/06/welcoming-safari-to-the-webextensions-community/"&gt;환영&lt;/a&gt; 한다는 입장을 밝히기도 했다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://devhints.io/"&gt;devhints.io&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;프레임워크뿐만 아니라, 도구, 언어 등에 대한 cheatsheet를 제공한다. 주요 사용법, 문법, 옵션 등을 빠르고 쉽게 확인하고 적용할 수 있어, 가끔 기억나지 않을 때 바로 참고할 수 있어 편리하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devhints.io/es6"&gt;ES6 cheatsheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devhints.io/react"&gt;React cheatsheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devhints.io/vue"&gt;Vue.js cheatsheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devhints.io/regexp"&gt;Regex cheatsheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devhints.io/mysql"&gt;MySQL cheatsheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;유사한 프로젝트인 &lt;a href="https://1loc.dev/"&gt;1loc&lt;/a&gt; (Favorite single line of code)도 같이 참고하면 좋다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/rxjs/observables-reactive-programming-and-regret-4jm6"&gt;Observables, Reactive Programming, and Regret&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;RxJS 프로젝트를 리딩 하는 Ben Lesh의 글로, 많은 개발자들은 Observables vs Reactive Programming vs RxJS 들을 동일시하거나 잘못 이해하고 있는 내용들을 설명하고, RxJS에 대한 후회를 담은 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=dtddBM8s7xY"&gt;Algorithms in CSS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://www.slideshare.net/laras126/algorithms-in-css-v310-css-day-2019"&gt;발표 슬라이드&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS는 프로그래밍 언어일까 아닐까?&lt;/p&gt;
&lt;p&gt;이는 명령형(imperative) 언어를 주로 사용해 온 JavaScript 개발자에게 선언적(declarative) 언어인 CSS는 때론 깊은 좌절감을 안겨주기도 한다.&lt;/p&gt;
&lt;p&gt;2019년 암스테르담에서 개최된 CSS Day 2019 콘퍼런스 세션에서는 CSS도 프로그래밍 언어의 일종이며, 왜 중요한가에 대해 언어적 측면에서의 접근을 통해 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://svelte.dev/blog/svelte-and-typescript"&gt;Svelte &amp;lt;3 TypeScript&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Svelte 개발팀은 공식적인 TypeScript 지원 추가를 발표했다.&lt;/p&gt;
&lt;p&gt;새로운 공식 &lt;a href="https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode"&gt;Svelte for VS Code&lt;/a&gt; 확장 기능을 통해 syntax highlighting, Svelte 컴포넌트를 위한 intellisense 등의 지원을 활용할 수 있게 되었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/javascript-in-plain-english/use-chrome-devtools-like-a-senior-frontend-developer-99a4740674"&gt;Use Chrome DevTools Like a Senior Frontend Developer&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;FE 개발자 필수템(?) 중 하나인 Chrome DevTools. 이 글에서는 Chrome DevTools의 잘 알려지지 않은 강력한 기능을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;글에서 소개하는 몇 가지 기능들을 익혀 놓는다면 본인의 개발력을 상승시키는 데 도움이 되지 않을까?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/yeonjuan/dev-blog/blob/master/JavaScript/return-null-vs-undefined.md"&gt;return null vs undefined&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript에서 값이 존재하지 않는 경우, 함수 반환값으로 null 과 undefined 중 어떤 값을 사용하면 좋을지에 대한 고민이 녹아 있는 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://d2.naver.com/helloworld/2177909"&gt;어서 와, SSR은 처음이지? - 개발 편&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Node.js 기반의 SSR 개발과 운영을 통해 겪은 경험기 총 3편 중 두 번째 글로, 17년간 잔존해 왔던 레거시 시스템 내에서 네이버 모바일 블로그 서비스를 어떻게 SSR로 전환했는지와 대한민국의 거의 모든 사람들이 사용하는 모바일 블로그 서비스의 트래픽에 대응하기 위해 SSR 구축을 어떻게 준비하고 개발했는지에 대한 이야기를 다룬다.&lt;/p&gt;
&lt;h2&gt;https://beta.caniuse.com/&lt;/h2&gt;
&lt;p&gt;웹 명세들의 브라우저 지원 여부를 검색할 수 있는 &lt;code&gt;Can I use...&lt;/code&gt; 사이트의 베타 버전이 공개되었다.&lt;!-- raw HTML omitted --&gt;
베타 버전에서는 보다 개선된 접근성, 다크 모드 지원, 개선된 URL 접근 경로 등이 제공된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;보다 자세한 업데이트 설명은 다음을 참고하라.&lt;!-- raw HTML omitted --&gt;
&lt;a href="https://caniuse.com/feed/162"&gt;Canise: Beta site updates&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://medium.com/developers-tomorrow/google-javascript-technical-interview-7a20accd6ddf"&gt;Google JavaScript Technical Interview (Callbacks, Promises, Await/Async)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;구글에서 기술면접 문제로 출제하고 있는 JavaScript 문제들 중 callback, promise, await/async를 비교하며 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/@matanbobi/react-defaultprops-is-dying-whos-the-contender-443c19d9e7f1"&gt;React defaultProps is dying, who’s the contender?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서 &lt;code&gt;props&lt;/code&gt;에 기본 값을 할당하는 방법으로는 대표적으로 ES6에서 도입된 &lt;a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Default_parameters"&gt;기본 매개 변수 문법&lt;/a&gt;과, React에서 제공하는 &lt;code&gt;defaultProps&lt;/code&gt;를 이용하는 방법이 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 두 방법의 차이점과 장단점은 무엇이 있는지 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://d2.naver.com/helloworld/4268738"&gt;2020년과 이후 JavaScript의 동향 - JavaScript(ECMAScript)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2016년부터 매해 공유되고 있는 JavaScript 및 Front-end 동향에 대한 시리즈로, 그 첫 번째 영역인 &amp;quot;JavaScript(ECMAScript)&amp;quot;에 대한 글이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지난 JavaScript(ECMAScript) 동향 시리즈: &lt;a href="http://d2.naver.com/helloworld/3618177"&gt;2016&lt;/a&gt;, &lt;a href="http://d2.naver.com/helloworld/2809766"&gt;2017&lt;/a&gt;, &lt;a href="http://d2.naver.com/helloworld/7495331"&gt;2018&lt;/a&gt;, &lt;a href="http://d2.naver.com/helloworld/4007447"&gt;2019&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 글에서는 새로운 전환점의 시작을 맞고 있는 JavaScript의 변화와 앞으로의 전망 그리고, ECMAScript 2020/2021 새로운 주요 명세들을 확인해 볼 수 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://web.dev/one-line-layouts/"&gt;Ten modern layouts in one line of CSS&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;FE News &lt;a href="./2020-06.md"&gt;6월 소식&lt;/a&gt;에서 공유했었던 &lt;a href="https://web.dev/live/"&gt;web.dev LIVE&lt;/a&gt; 세션들 중 하나로, 모던 CSS 레이아웃 명세들을 이용해 자주 사용되는 10여 개의 레이아웃을 빠르고 간단하게 만드는 방법을 코드 예제와 함께 소개한다. 실행 결과 또한 시각화해 보여주기 때문에 쉽게 이해할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://webglfundamentals.org/"&gt;WebGL Fundamentals&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;WebGL이 실제로 무엇이고 어떻게 작동하는지 기초부터 2D, 3D, 조명, 텍스처 등 WebGL에서 알아야 하는 모든 요소들에 대한 기초적인 설명과 예제와 함께 제공된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://webglfundamentals.org/webgl/lessons/ko/"&gt;한글 번역&lt;/a&gt;도 제공되지만, 일부 영역에 대해서만 한정적으로 제공된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://dev.to/calvintwr/build-instagram-using-typescript-node-express-and-vue-part-1-57do"&gt;Build Instagram Using TypeScript, Node, Express and Vue&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;총 5개의 시리즈로 구성된 이 튜토리얼은 Node.js, Express, TypeScript, Vue를 사용해 instagram과 유사한 기능을 갖는 웹앱을 만드는 방법을 단계별로 설명한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://twitter.com/b0rk/status/1284528767151611904"&gt;inline vs block&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;짧은 코믹 컷을 통해 프로그래밍 관련 개념들을 소개하는 &lt;a href="https://twitter.com/b0rk"&gt;Julia Evans&lt;/a&gt;가 inline과 block 요소의 차이점을 설명한 그림으로, 간단하고 빠르고 쉽게 개념을 이해할 수 있다.&lt;/p&gt;
&lt;p&gt;트위터 계정에서는 웹 이외에도 다양한 기술적 영역들에 대한 코믹들을 확인할 수 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://playwright.dev/"&gt;Playwright&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Playwright은 MS에서 개발한 Node 라이브러리로, Chromium, Firefox 그리고 WebKit 등의 브라우저를 자동화할 수 있는 크로스 브라우저 단일 API를 제공한다.&lt;/p&gt;
&lt;p&gt;다음은 Chromium, Firefox 그리고 WebKit으로 http://whatsmyuseragent.org/ 를 방문하고, 3개의 스크린숏을 저장하는 예제 코드다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const playwright = require('playwright');

(async () =&amp;gt; {
  for (const browserType of ['chromium', 'firefox', 'webkit']) {
    const browser = await playwright[browserType].launch();
    const context = await browser.newContext();
    const page = await context.newPage();

    await page.goto('http://whatsmyuseragent.org/');
    await page.screenshot({ path: `example-${browserType}.png` });
    await browser.close();
  }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/checkly/puppeteer-recorder"&gt;Puppeteer Recorder&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 확장 기능으로, 브라우저에서 수행한 인터렉션을 기록하고 이를 Puppeteer 스크립트 코드로 만들어 준다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjimgehda"&gt;chrome 웹 스토어에서 설치하기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://dev.to/gajus/my-favorite-css-hack-32g3"&gt;My favorite CSS hack&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;아래의 괴상한 CSS 스니펫은 무슨 일을 할까?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;* { background-color: rgba(255,0,0,.2); }
* * { background-color: rgba(0,255,0,.2); }
* * * { background-color: rgba(0,0,255,.2); }
* * * * { background-color: rgba(255,0,255,.2); }
* * * * * { background-color: rgba(0,255,255,.2); }
* * * * * * { background-color: rgba(255,255,0,.2); }
* * * * * * * { background-color: rgba(255,0,0,.2); }
* * * * * * * * { background-color: rgba(0,255,0,.2); }
* * * * * * * * * { background-color: rgba(0,0,255,.2); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 스니펫은 아래의 우측 이미지와 같이 요소들을 구분해 볼 수 있도록 해 페이지 레이아웃 작업 시 유용하게 사용될 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본문 글에 달린 댓글에서는 몇몇 사용자들이 개선한 버전들도 함께 찾아볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://tsdx.io/"&gt;TSDX&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;최근의 TypeScript 인기에 따라 많은 프로젝트들이 TypeScript로 개발되고 있다. 하지만, TS 프로젝트를 설정하는 일은 때로는 도전적인 일이 되기도 한다. 다양한 개발 환경에 따라 그에 맞는 TS 관련 도구들을 설치하고 설정하는 것은 골치 아프면서 귀찮은 일이다.&lt;/p&gt;
&lt;p&gt;TSDX는 무설정(Zero-Config)을 표방하는 CLI 도구로, 간단하고 빠르게 새로운 TS 프로젝트를 부트스트랩 해 주는 도구다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;npx tsdx create 프로젝트명
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;총 3가지 형태의 프로젝트 템플릿을 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;basic: Plain TypeScript 프로젝트&lt;/li&gt;
&lt;li&gt;react: React를 사용하는 프로젝트&lt;/li&gt;
&lt;li&gt;react-with-storybook: React + React Storybook 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://npmview.now.sh/"&gt;npmview&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;npm 패키지 내의 파일들을 미리 보기 할 수 있는 도구로, 패키지 내의 파일 구성과 해당 파일의 내용까지 미리 보기 할 수 있다.
사용방법은 아래와 같이 npm에 배포된 패키지명을 덧붙이면 바로 확인이 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://npmview.now.sh/패키지명
https://npmview.now.sh/패키지명@버전
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://screensizemap.com/"&gt;Screen size map&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;다양한 디바이스들에서 사용하고 있는 스크린 크기를 비교해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://designer.mocky.io/"&gt;Mocky&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;원하는 형태(status code, content-type 등의 설정이 가능)로 응답을 받을 수 있는 목업 API를 만들고 테스트할 수 있다.&lt;/p&gt;
&lt;p&gt;별도의 로그인 없이 사용 가능하며, JSONP, CORS 등도 지원하고 있어 아직 실 API의 개발이 완료되지 않은 상황에서 개발 작업을 진행할 수 있도록 도와준다.&lt;/p&gt;
</content></entry><entry><title>2020-02</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-02.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-02.md" rel="alternate"/><published>2020-02-05T07:56:21+00:00</published><content type="html">&lt;h1&gt;2020-02 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을꺼리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://illustrated.dev/"&gt;Illustraded.dev&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;FE 기술들에 대한 근본적인 개념을 도식화해 설명해 주며, GraphQL, Babel, React Hooks 등에 대한 주제들이 포함되어 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://free-for.dev/"&gt;free-for.dev&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;무료로 사용할 수 있는 다양한 기반 서비스(SaaS, PaaS, IaaS, etc.)들의 방대한 목록들을 제공한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex) 메이저 클라우드 서비스 제공자들 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/free/?awsf.Free%20Tier%20Types=categories%23alwaysfree"&gt;AWS 프리 티어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://azure.microsoft.com/en-us/free/"&gt;Microsoft Azure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.oracle.com/cloud/free/"&gt;Oracle Cloud Free Tier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/cloud/free/"&gt;IBM Cloud free tier&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://ebookfoundation.github.io/free-programming-books/"&gt;List of Free Learning Resources&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;무료로 제공되는 다양한 프로그래밍 서적, 리소스, 온라인 교육과정들에 대한 방대한 목록을 제공하며, 한글로 작성된 콘텐츠 목록도 다수 포함하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한글 컨텐츠는 AWS, Docker, Git, JavaScript, LaTex, Python 등의 주제가 등록되어 있다.
https://ebookfoundation.github.io/free-programming-books/free-programming-books-ko.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://webassembly-summit.org/"&gt;WebAssembly Summit&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 2월10일 구글 본사에서 진행된 웹어셈블리 개발자 써밋. 전체 발표 동영상은 아래 링크를 통해 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;발표 동영상: https://www.youtube.com/watch?v=WZp0sPDvWfw&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://schepp.dev/posts/today-the-trident-era-ends/"&gt;Today, the Trident Era Ends&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;IE의 렌더링 엔진 &lt;a href="https://en.wikipedia.org/wiki/Trident_(software)"&gt;Trident&lt;/a&gt;의 지난 기록을 돌아보는 글로, 과거 IE가 도입했던 몇몇 혁신적인 기술적 내용들을 돌아본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;과거 웹사이트들은 IE와 같이 특정 브라우저에서만 동작이 보장되는 경우가 많아, 다음과 같은 아이콘을 사이트에 노출하기도 했었다.
&lt;img src="https://schepp.dev/img/ieget_animated.gif" alt="" /&gt;&lt;/li&gt;
&lt;li&gt;관련해서 HackerNews에서 이뤄지고 있는 &lt;a href="https://news.ycombinator.com/item?id=22146629"&gt;다양하고 흥미 있는 의견들&lt;/a&gt;도 함께 참고해 보기 바란다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://almanac.httparchive.org/en/2019/table-of-contents"&gt;Web Almanac 2019&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Web Almanac은 &lt;a href="https://httparchive.org/"&gt;HTTP Archive&lt;/a&gt;를 통해 수집된 다양한 웹사이트 데이터에 연례 보고서로 전 세계 웹사이트들의 사용 현황(페이지 내의 JS 크기, 이미지 크기 등과 같은)을 살펴볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.native.directory/"&gt;React Native Directory&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;큐레이션된 다양한 React Native 라이브러리들의 목록을 제공한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/practical-css-scroll-snapping/"&gt;Practical CSS Scroll Snapping&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;사용자의 스크롤 액션에 따라 뷰포트를 특정 요소 또는 위치에 잠금(lock) 되도록 만들 수 있는 'CSS Scroll Snap'의 다양한 실용적 사용 방법들을 소개한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS Scroll Snap는 CSS 만으로 다음과 같은 캐로셀 인터렉션을 쉽게 구현할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://medium.com/@michael.karen/learning-modern-javascript-with-tetris-92d532bcd057"&gt;Learning Modern JavaScript with Tetris&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript로 테트리스를 구현해 가는 과정을 step-by-step 형식으로 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/swlh/typescript-unit-testing-with-test-coverage-2cc0cc6f3fd1"&gt;TypeScript Unit Testing with Test Coverage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript를 사용한 프로젝트의 테스트 커버리지를 출력을 설정하는 방법을 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://csslayout.io/"&gt;CSS Layout&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS로 작성된 인기 있는 레이아웃과 패턴들의 코드를 제공해, 초기 페이지 레이아웃 구성 시 참고해 빠르게 레이아웃을 구성할 수 있도록 도와준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://tesseract.projectnaptha.com/"&gt;Tesseract.js | Pure Javascript Multilingual OCR&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;인기 있는 OCR 엔진인 &lt;a href="https://github.com/tesseract-ocr/tesseract"&gt;tesseract&lt;/a&gt;의 순수 JavaScript 포팅 버전으로 한국어도 지원된다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/you-dont-need/You-Dont-Need"&gt;You Don't Need&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Moment.js, Lodash, Redux, jQuery 등과 같은 도구/라이브러리/패턴들의 사용을 대체할 수 있는 방법(코드 예제)들이 제공된다.&lt;/p&gt;
&lt;p&gt;ex) Underscore/Lodash의 &lt;code&gt;_.dropRight()&lt;/code&gt;은 다음의 네이티브 코드로 대체할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;_.dropRight([1, 2, 3]);
// =&amp;gt; [1, 2]

_.dropRight([1, 2, 3], 2);
// =&amp;gt; [1]

// Native
[1, 2, 3].slice(0, -1);
// =&amp;gt; [1, 2]

[1, 2, 3].slice(0, -2);
// =&amp;gt; [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://github.com/minimaxir/big-list-of-naughty-strings/"&gt;Big List of Naughty Strings&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;문제를 일으킬 수 있는 다양한 텍스트 입력값의 모음을 제공해
입력값 테스트 시 예외적 항목들을 테스트해 볼수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;텍스트: https://github.com/minimaxir/big-list-of-naughty-strings/blob/master/blns.txt&lt;/li&gt;
&lt;li&gt;JSON: https://github.com/minimaxir/big-list-of-naughty-strings/blob/master/blns.json&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;ex) 예제에 포함된 2 바이트 문자열 테스트 값은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;#	Two-Byte Characters
#
#	Strings which contain two-byte characters: can cause rendering issues or character-length issues

田中さんにあげて下さい
パーティーへ行かないか
和製漢語
部落格
사회과학원 어학연구소
찦차를 타고 온 펲시맨과 쑛다리 똠방각하
社會科學院語學研究所
울란바토르
𠜎𠜱𠝹𠱓𠱸𠲖𠳏
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://tiny-helpers.dev/"&gt;Tiny helpers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;웹 개발에 사용할 수 있는 다양한 온라인 개발 도구들의 목록을 제공한다.&lt;/p&gt;
&lt;p&gt;ex) 확인할 수 있는 몇가지 도구들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.0to255.com/"&gt;0to255&lt;/a&gt;
밝거나 어두운 색상 컬러 코드를 쉽게 고를 수 있게 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://astexplorer.net/"&gt;AST explorer&lt;/a&gt;
다양한 파서들로부터 생성된 AST(Abstract Syntax Tree)를 탐색할 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/whats-new/2019/12/devtools"&gt;What's new in DevTools (Microsoft Edge 80)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chromium 기반의 MS Edge 브라우저가 정식 발표된 이후, Edge만의 고유한 기능들이 하나둘씩 추가되고 있으며
MS Edge 80 개발자 도구에 추가된 새로운 업데이트 내용을 통해 몇몇 기능들을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;ex) &lt;code&gt;3D View&lt;/code&gt; 기능은 페이지의 DOM 또는 z-index stacking context 시각화를 3D로 제공해 디버깅 할수 있도록 한다.
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jsonnet.org/learning/tutorial.html"&gt;Jsonnet - The Data Templating Language&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jsonn&lt;/code&gt; 확장자를 갖는 데이터 템플릿팅 언어로 설정관련 데이터 등을 손쉽게 관리할 수 있게 한다.  결과물은 &lt;code&gt;.json&lt;/code&gt;, &lt;code&gt;.ini&lt;/code&gt;, &lt;code&gt;.sh&lt;/code&gt; 등의 다양한 확장자로 출력할 수 있다.&lt;/p&gt;
&lt;p&gt;ex) 아래의 &lt;code&gt;.jsonnet&lt;/code&gt; 파일을 통해&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// example.jsonnet
local Person(name='Alice') = {
  name: name,
  welcome: 'Hello ' + name + '!',
};
{
  person1: Person(),
  person2: Person('Bob'),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음의 &lt;code&gt;.json&lt;/code&gt; 파일을 출력한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// output.json
{
  &amp;quot;person1&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;,
    &amp;quot;welcome&amp;quot;: &amp;quot;Hello Alice!&amp;quot;
  },
  &amp;quot;person2&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;Bob&amp;quot;,
    &amp;quot;welcome&amp;quot;: &amp;quot;Hello Bob!&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;온라인 데모&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://codepen.io/petrbroz/pen/OJJYGXv"&gt;Forge Viewer: Get Fragment Properties&lt;/a&gt;&lt;!-- raw HTML omitted --&gt; 유명한 3D 설계 프로그램을 개발하는 AutoDesk에서 제공하는 클라우드 기반의 도구인 &lt;a href="https://forge.autodesk.com/en/docs/viewer/v2/developers_guide/overview/"&gt;Forge&lt;/a&gt;를 사용해 구현한 뷰어 데모&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/ReGGae/pen/povjKxV"&gt;Infinite draggable webgl slider.&lt;/a&gt;: WebGL로 shader 프로그래밍 해서 캐로셀 전환 효과를 구현한 데모&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/alphardex/pen/VwwVLdM"&gt;Button Collection&lt;/a&gt;: 버튼에 적용할 수 있는 다양한 애니메이션 전환 효과 데모&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/cobra_winfrey/pen/BayQeyr"&gt;Sweaterize Yo'self&lt;/a&gt;: 화상 카메라를 통해 촬영된 실시간 이미지에 니팅 패턴을 적용하는 데모
&lt;blockquote&gt;
&lt;p&gt;자매작품: &lt;a href="https://codepen.io/cobra_winfrey/pen/ZEYzMBj"&gt;Holiday CSSweater Generator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/hoanghien0410/pen/MMPaqm"&gt;3D carousel&lt;/a&gt;: 3차원 캐로셀 구현 데모&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codepen.io/bsehovac/pen/EMyWVv"&gt;The Cube&lt;/a&gt;:  &lt;a href="https://threejs.org/"&gt;three.js&lt;/a&gt;로 구현한 인터랙티브 큐브 게임&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>2021-09</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-09.md</id><updated>2021-09-01T06:06:43+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-09.md" rel="alternate"/><published>2021-08-26T12:56:17+00:00</published><content type="html">&lt;h1&gt;2021-09 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://d2.naver.com/news/0267195"&gt;FE devtalk 20회, 디자인 시스템 개발 편 2탄&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;지난 8월 17일, 네이버에서 진행하는 사내 프론트엔드 컨퍼런스인 FE Devtalk에서 &amp;quot;디자인 시스템(개발편 2탄)&amp;quot;란 주제로 20회 행사가 진행되었다.&lt;/p&gt;
&lt;p&gt;쏘카, 뱅크샐러드, 카카오 엔터프라이즈, 직방과 같은 인터넷 서비스 회사들이 자체적인 디자인 시스템을 어떻게 기획/디자인/개발/협업하고 있을까 라는 궁금증으로 시작된 이 주제는 3회에 걸쳐 진행되면서 그 이야기들을 풀어내고 있다.&lt;/p&gt;
&lt;p&gt;이번 20회에선 코멘토, 코발트, 와디즈, 직방의 개발자들이 참여해 디자인 시스템 개발에 대한 경험을 공유했다. 아래 링크에서 발표들을 확인해 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NAVER-FEPlatform/FEDevtalk/blob/master/17_fedevtalk.md"&gt;17회 - 디자인 시스템(기획자, 디자이너 편) - 리디, 소카, 마이리얼트립&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/NAVER-FEPlatform/FEDevtalk/blob/master/19_fedevtalk.md"&gt;19회 - 디자인 시스템(개발편 1탄) - 다노, 뱅크샐러드, 카카오엔터프라이즈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/NAVER-FEPlatform/FEDevtalk/blob/master/20_fedevtalk.md"&gt;20회 - 디자인 시스템(개발편 2탄) - 코멘토, 코발트, 와디즈, 직방&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://judepark-6960.medium.com/a-design-system-made-with-tensorflow-js-8f6c567e9593"&gt;TensorFlow로 디자인시스템 만들기&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;디자인 시스템을 실제로 만드는 디자이너의 입장에서 매번 고통스럽게 반복해야하는 작업이 많다.&lt;/p&gt;
&lt;p&gt;이를 Zeplin과 tensorflow.js의 객체인식(Object Detection)을 사용해 문제를 해결했던 프로젝트에 대해 소개하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dusskapark/zeplin-ml"&gt;Zeplin-ML&lt;/a&gt;라는 이 프로젝트는 스크린 디자인들에서 UI객체를 찾아주는 기능을 제공하며, 그것을 비교하기 쉽게 컴포넌트 라이브러리 화면들도 제공한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/this-is-learning/javascript-vs-javascript-fight-53fa"&gt;JavaScript vs JavaScript. Fight!&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;소프트웨어 개발을 하면서 우리들은 결과적으로 동일한 것을 수행하지만, 자신들의 것이 최고라고 홍보하는 수많은 라이브러리와 도구들 중에서
그들의 장단점을 비교하고 선택하는 과정을 거친다. 그러나 때때로 차별화 요소는 우리가 성취하고자 하는 것과 덜 관련이 있고,
단점들이 무엇인지 항상 명확하지는 않다. 이런 것들이 정말 중요한 것들일까?&lt;/p&gt;
&lt;p&gt;한 번쯤은 다들 고민해 봤을 주제들인 MPA vs SPA, React vs Reactivity, VDOM vs No VDOM, Components vs Web Components 등의
논점들이 무엇이고 어떠한 점을 고려해야 할지 살펴볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://world.hey.com/dhh/modern-web-apps-without-javascript-bundling-or-transpiling-a20f2755"&gt;Modern web apps without JavaScript bundling or transpiling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2000년대 RJS (Ruby-to-JavaScript)나 CoffeeScript 등을 통해 JavaScript가 아닌 다른 언어로 JavaScript 코드를 생성해 낼수 있게 되었고, 이후 2015년 ES6로의 발전을 통해 더 나은 JavaScript 코드를 작성할 수 있게 되었고, 최신 문법의 브라우저 지원을 기다릴 필요 없이 Babel이 미래의 최신 문법의 코드를 즉시 사용할 수 있게 만들어 주었다. 그러나 이는 공짜가 아니었고, 웹의 복잡성을 수반하게 만들었다.&lt;/p&gt;
&lt;p&gt;오늘날의 웹 환경에서 transpiler나 번들링 도구가 꼭 필요한 것일까?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blogs.windows.com/msedgedev/2021/08/17/css-module-scripts-import-stylesheets-like-javascript-modules/"&gt;CSS module scripts: &lt;code&gt;import&lt;/code&gt; stylesheets like JavaScript modules&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS 파일을 ESM과 같이 import 문법으로 로딩할 수 있게 하는 &lt;a href="https://chromestatus.com/feature/5948572598009856"&gt;CSS module script&lt;/a&gt; 지원이 Edge와 Chrome 93에 추가될 예정이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import sheet from './styles.css' assert { type: 'css' };

document.adoptedStyleSheets = [sheet];
shadowRoot.adoptedStyleSheets = [sheet];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;보다 자세한 CSS Module Script에 대한 내용은 다음 링크를 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.dev/css-module-scripts/"&gt;Using CSS Module Scripts to import stylesheets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://nodejs.org/en/blog/release/v16.8.0/"&gt;Node v16.8.0 (Current) Released &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Node V16.8.0이 릴리즈 되었다.
&lt;a href="https://nodejs.org/en/blog/release/v16.6.0/"&gt;V16.6.0&lt;/a&gt;버전 부터는 &lt;code&gt;Array.prototype.at&lt;/code&gt; 이 사용 가능하다. 더이상 &lt;code&gt;array[array.length-1]&lt;/code&gt; 로 마지막 원소를 찾아갈 필요가 없다. &lt;code&gt;array.at(-1)&lt;/code&gt; 이면 끝!&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://alexsidorenko.com/blog/react-render-usememo/"&gt;A Visual Guide to React Rendering - useMemo &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;props가 바뀌지도 않았는데 자식 컴포넌트가 리렌더링되는 현상의 이유와 useMemo를 통한 해결과정을 알려주는 가이드이다. 의도치 않은 리렌더링으로 고생한 경험이 있다면 1독을 권한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jbee.io/react/headless-concept/"&gt;Headless UI Library란?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;컴포넌트를 라이브러리로 개발할 때에 Headless로 구현하면 어떤 점이 좋아지는지 그리고 어떻게 작성할 수 있는지에 대해 설명하고 있다.&lt;/p&gt;
&lt;p&gt;여기서 Headless(또는 Renderless)란 컴포넌트 라이브러리에서 스타일을 담당하는 부분을 제외하고 상태와 관련된 부분만을 다루는 것을 말한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@yrnana/Typescript-4.4%EC%97%90-%EC%B6%94%EA%B0%80%EB%90%9C-%EA%B8%B0%EB%8A%A5"&gt;Typescript 4.4에 추가된 기능&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript 4.4에 추가된 기능에 대해 예시를 통해 설명한 글이다.&lt;br /&gt;
class에서 static 블록을 사용할 수 있는 기능이 추가되었다. 또한, 기존에는 Type Guard를 통해 해결했던 문제를 4.4에서는 &amp;quot;alias 된 조건문과 판별문 흐름 분석&amp;quot;을 통해 좀더 쉽게 타입 추론을 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/"&gt;TypeScript 4.4 공식 릴리즈 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://joaoforja.com/blog/guideline-on-how-to-decompose-a-react-component"&gt;Guideline from the 70's on how to split your React components&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;컴포넌트를 어떻게 나눌지 결정하는 것은 쉬운 일이 아니다. 이 글은 David Parnas의 1979년 “Designing Software for Ease of Extension and Contraction”에서 얻은 아이디어에 기초하여, 코드의 재사용성을 높이고 유지보수 비용을 줄이는 측면에서 어떻게 컴포넌트를 나눌 수 있을지 가이드라인을 제시한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.daxx.com/blog/development-trends/javascript-market-trends-average-salaries"&gt;What’s the Average JavaScript Developer Salary in 2021?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;자바스크립트와 웹 생태계의 부흥에 따라 수 많은 프레임워크가 등장했고 최근에는 React, Angular, Vue 3강 구도가 유지되고있다. 각 프레임워크 별 연봉은 어떻게 될까?&lt;/p&gt;
&lt;p&gt;위 글에서는 자바스크립트 개발자의 연봉과 프레임워크 별 연봉을 서구권 국가 위주로 통계를 내서 정리해놓았다. (아쉽게도 대한민국의 통계는 없다.)&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Store"&gt;Vanilla Javascript로 상태관리 시스템 만들기&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Flux 기반의 Redux, Vuex의 상태 관리 라이브러리를 Vanilla JS를 이용해서 만들어 가는 튜토리얼 문서이다.
Observer pattern, 그리고 상태 변화를 인지할 수 있는 Object.defineProperty, proxy 등을 소개하면서 간단한 상태 관리 라이브러리를 만들어 볼 수 있다.
실무에서 상태 관리 라이브러리를 사용하기 전에 한 번씩 따라 해 보면 좋은 학습이 될 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://felixgerschau.com/how-to-make-your-react-app-a-progressive-web-app-pwa/"&gt;How to Make your React App a Progressive Web App(PWA)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React 앱을 PWA로 만들어가는 과정을 단계별로 서술한 튜토리얼이다.
PWA를 만져보고 싶지만 어떻게 시작해야 할지 모르는 상태에서 글을 한번 따라 해 보면 PWA에 대한 이해를 높일 수 있을 것이다.
튜토리얼을 따라 하지 않고 PWA와 Service Worker에 대한 설명만 읽어보아도 PWA에 대한 감을 잡을 수 있다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://jsisweird.com/"&gt;JS is weird&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript를 더 어렵게 만드는 이상한 문법 25개를 풀 수 있다.&lt;/p&gt;
&lt;p&gt;심심풀이로 풀어보고 실무에서는 이와 같은 혼란스러운 문법을 가급적 지양해야겠다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://rsuitejs.com/"&gt;React Suite&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React Suite는 기업용 제품을 위한 오픈소스 리액트 컴포넌트 라이브러리다. 좋은 개발 경험을 제공하는 데에 초점을 두었다. &lt;a href="https://rsuitejs.com/design/default/"&gt;링크&lt;/a&gt;와 같이 각 컴포넌트의 디자인 프로토타입과 명세도 제공한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/open-amdocs/webrix"&gt;WEBRIX&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Bootstrap이나 Material-UI와 같은 컴포넌트 프레임워크(또는 라이브러리)를 도입해 웹서비스를 개발하면 초기에 빠르게 서비스를 만들 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;하지만 컴포넌트를 커스터마이징을 하려고 하거나, 서비스가 발전해 자체적인 디자인 시스템을 구축한다고 했을 때 위와 같은 프레임워크의 도입이 부담이 될 수 있다.&lt;/p&gt;
&lt;p&gt;그렇다고 하나부터 열까지 컴포넌트를 자체적으로 개발하는 것 또한 낭비적인 부분이 생긴다.&lt;/p&gt;
&lt;p&gt;이를 해결해 줄 수 있는 솔루션이 바로 WEBRIX이다.&lt;/p&gt;
&lt;p&gt;WEBRIX 는 &lt;code&gt;&amp;lt;Movable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Stackable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Pannable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Resizable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Poppable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Scalable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Scrollable/&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Collapsible/&amp;gt;&lt;/code&gt; 와 같이 기능적 부분에 포커스 된 컴포넌트들을 제공한다. 서비스 개발자는 컴포넌트의 presentaion 적인 부분만 신경 써서 개발하면 된다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/katspaugh/wavesurfer.js"&gt;wavesurfer.js&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Web Audio API와 CANVAS로 audio리소스를 시각화하고 탐색할 수 있는 라이브러리다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/ShizukuIchi/winXP"&gt;WinXP&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Windows XP 운영체제의 몇가지 기능과 간단한 앱들을 React와 hooks를 사용해서 구현한 프로젝트이다.
윈도우에서 친숙한 인터렉션을 어떻게 구현했는지 코드를 통해 살펴볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/PuruVJ/macos-web"&gt;macos-web&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이번엔 MacOS 운영체제다. Svelte로 작성되었다. 코드를 통해 MacOS의 인터렉션을 어떻게 구현했는지 확인할 수 있다.&lt;/p&gt;
</content></entry><entry><title>2021-02</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-02.md</id><updated>2021-01-25T07:48:59+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-02.md" rel="alternate"/><published>2021-01-25T07:48:59+00:00</published><content type="html">&lt;h1&gt;2021-02 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://medium.com/javascript-in-plain-english/javascript-frameworks-performance-comparison-2020-cd881ac21fce"&gt;JavaScript Frameworks, Performance Comparison 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;총 20개의 다양한 프레임워크들에 대한 성능 비교를 수행하고 그 결과를 소개하는 글이다.
벤치마크는 크게 다음의 3가지 영역에 대한 실행을 통해 비교를 수행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 성능&lt;/li&gt;
&lt;li&gt;초기 시작 메트릭&lt;/li&gt;
&lt;li&gt;메모리 사용량&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 각 항목들은 상대적 비교를 위해, 가장 최적화된 Vanilla로 구현체의 결괏값이 제공된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최종 벤치마크 결과는 다음 링크를 통해 확인할 수 있다.
https://krausest.github.io/js-framework-benchmark/index.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://alexkondov.com/tao-of-react/"&gt;Tao of React - Software Design, Architecture &amp;amp; Best Practices&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;소프트웨어의 아키텍처와 디자인은 생산성과 유연성을 제공해 개발자들이 효율적으로 코어를 재작성하는 일이 없도록 만드는 것이 가장 큰 목표라 할 수 있다.&lt;/p&gt;
&lt;p&gt;글의 저자는 2016년부터 React를 사용한 개발 경험을 통해 애플리케이션 구조(아키텍처)와 디자인 측면에서의 모범사례를 제시한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// ex) 헬퍼 함수들에 대한 정리
// 👎 클로저를 유지할 필요가 없는 중첩 함수를 피하라.
function Component({ date }) {
  function parseDate(rawDate) {
    ...
  }

  return &amp;lt;div&amp;gt;Date is {parseDate(date)}&amp;lt;/div&amp;gt;
}

// 👍 헬퍼 함수들은 컴포넌트 앞에 배치하라.
function parseDate(date) {
  ...
}

function Component({ date }) {
  return &amp;lt;div&amp;gt;Date is {parseDate(date)}&amp;lt;/div&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://alesgenova.github.io/concurrent-wasm-workers/"&gt;Running Rust in WebAssembly in a Pool of Concurrent Web Workers in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;레이 트레이싱을 사용하는 3D 장면을 구성하는 단일 프레임을 렌더링 하는 실험적 애플리케이션 구현을 통해, 일련의 무거운 작업들을 빠르게 실행할 수 있는지에 대한 POC(Proof Of Concept)이다.&lt;/p&gt;
&lt;p&gt;wasm 모듈로 컴파일된 Rust 라이브러리는 웹 워커 풀을 통해 다수의 작업을 동시에 실행되도록 해 무거운 작업들을 빠르게 처리할 수 있음을 증명한다.&lt;/p&gt;
&lt;p&gt;데모 애플리케이션은 다음 링크를 통해 직접 실행해 볼수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://alesgenova.github.io/ray-tracer-app/&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://github.blog/2020-12-21-how-we-built-the-github-globe/"&gt;How we built the GitHub globe&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;총 5개 시리즈를 통해 &lt;a href="https://github.com/home"&gt;GitHub의 새로운 홈페이지&lt;/a&gt; 개발 과정을 소개한다. 첫 번째 시리즈에서는 메인 페이지에 추가된 지구본을 통해 전 세계에서 발생되는 PR을 시각화하기 위한 개발 과정을 다루고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/"&gt;Why React Context is Not a &amp;quot;State Management&amp;quot; Tool (and Why It Doesn't Replace Redux)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;Context vs Redux&amp;quot;에 대한 주제는 React Context API가 릴리스된 이래, 항상 많은 이들의 열띤 토론을 이끌어 냈던 단골 주제 중 하나였으며, 이들 &amp;quot;토론&amp;quot;의 대부분은 2가지 도구가 갖는 목적과 사용 사례에 대한 혼란에서 비롯되었음을 글에서 지적한다.&lt;/p&gt;
&lt;p&gt;글의 저자는 자신이 작성했던 답글들을 정리해 어떤 경우에 이들이 사용되어야 하고, 무엇이 다른지 그리고 어떤 경우에 사용되어야 하는지를 자세하게 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://browntreelabs.com/how-to-ace-your-next-javascript-interview/"&gt;How to ace your next Javascript interview&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;7분 내외의 짧은 동영상을 통해 저자는 지난 10여 년간의 경력에서 경험했던 수많은 인터뷰 참여를 통해 모든 인터뷰들에서 갖는 일반적인 패턴들이 존재하며, 이들 패턴들을 잘 이해하고 공부한다면 여러분들도 충분히 다음 인터뷰에서 성공할 수 있을 것이라 말한다.&lt;/p&gt;
&lt;p&gt;대다수 인터뷰에서 관찰됐던 일반적인 패턴들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최소한 한 가지 이상의 까다로운 문제(tricky question)가 존재한다.&lt;/li&gt;
&lt;li&gt;일반적으로 한 개 이상의 알고리즘 문제가 포함된다.&lt;/li&gt;
&lt;li&gt;전체 애플리케이션 내에 포함되는 작은(일부) 기능 구현을 작성해 보도록 요구된다.&lt;/li&gt;
&lt;li&gt;JavaScript의 경우, vanilla JS로 작성할 것이 요구된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2020 설문조사&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;또 다른 새해가 시작되었다. 지난 1년간 Front-end 영역에서의 변화가 무엇일지, 그리고 앞으로의 전망은 어떻게 될지 가장 빠르고 쉽게 알아볼 수 있는 방법은 바로 다양한 이들의 생각을 살펴보는 것이다.&lt;/p&gt;
&lt;p&gt;매해 진행되는 다음의 다양한 설문조사 결과들은 여러분들의 궁금증에 대한 해답을 들려줄 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tsh.io/State-of-Frontend-2020-by-TSH.pdf"&gt;State of Frontend 2020&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://2020.stateofjs.com/ko-KR/"&gt;2020 State Of JS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://2020.stateofcss.com/ko-KR/"&gt;2020 State Of CSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://risingstars.js.org/2020/en#section-framework"&gt;2020 JavaScript Rising Stars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://designsystemssurvey.seesparkbox.com/2020/"&gt;2020 Design Systems Survey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://stackshare.io/posts/top-developer-tools-2020"&gt;The Top 100+ Developer Tools 2020&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;개발 회사와 개발팀에서 어떤 오픈소스와 도구들을 사용하고 있는지 공유하고 파악할 수 있는 &lt;a href="https://stackshare.io/"&gt;stackshare&lt;/a&gt; 사이트에서 작년(2020) 한 해 동안 커뮤니티에서 가장 높은 점수를 받은 기술들에 대해 순위를 메겼다.&lt;/p&gt;
&lt;p&gt;이 순위는 커뮤니티에서 얻은 8백만 개 이상의 데이터를 분석해서 제공한 것이라고 한다.
언어, 프레임워크, 협업, 커뮤니케이션, 모니터링 등 각종 분야에서 어떤 기술들이 인기 있었는지 확인할 수 있고, 오픈소스와 기술 도구들의 트렌드와 흐름을 한눈에 파악하는 데 도움이 될 것이다.&lt;/p&gt;
&lt;h2&gt;카카오 FE개발자의 성장 스토리&lt;/h2&gt;
&lt;p&gt;카카오 FE 개발자들의 성장 스토리에 대한 시리즈 글로, 다양한 기술적 공유와 경험 등을 소개한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2020/11/24/frontend-growth-01/"&gt;01: Judy, 첫 컨퍼런스에 가다(feat. JSConf korea 2020)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2020/12/01/frontend-growth-02/"&gt;02: Babel7과 corejs3 설정으로 전역 오염 없는 폴리필 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2020/12/03/frontend-growth-03/"&gt;03: 카카오 어드민 UI 컴포넌트를 모노레포로 개발하여 얻은 것들&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2020/12/23/frontend-growth-04/"&gt;04: 공동체 FE 온라인 세션 후기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2021/01/12/frontend-growth-05/"&gt;05: 의존관계를 이용해 구조적 리팩토링 포인트 찾기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tech.kakao.com/2021/02/02/frontend-growth-06/"&gt;06: 2021년 Chrome의 새로운 변화 – Schemeful same-site을 대응하자&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://www.ridicorp.com/story/react-native-1year-review/"&gt;네이티브 앱 → 리액트 네이티브 앱 전환 그리고 1년 후&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android와 iOS 각각 별도로 구현되었던 앱을 React Native로 통합한 과정과 그 후 1년간에 대한 회고를 다룬다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/kettanaito/naming-cheatsheet"&gt;Naming cheatsheet&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;구체적인 가이드나 코드 컨벤션 없이 개발을 하다 보면 안 좋은 네이밍 방법으로 코드를 작성할 수 있다.&lt;/p&gt;
&lt;p&gt;이 아티클은 꽤나 보편적으로 통용되는 네이밍 가이드를 예제와 함께 제시하고 있다.
자신이 작성한 코드에서 네이밍에 대한 의심이 있다면 한번 읽어보는 것을 추천한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/* Bad */
const a = 5 // &amp;quot;a&amp;quot; could mean anything
const isPaginatable = a &amp;gt; 10 // &amp;quot;Paginatable&amp;quot; sounds extremely unnatural
const shouldPaginatize = a &amp;gt; 10 // Made up verbs are so much fun!

/* Good */
const postCount = 5
const hasPagination = postCount &amp;gt; 10
const shouldDisplayPagination = postCount &amp;gt; 10 // alternatively
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://www.youtube.com/watch?v=IuXpqUxJG90"&gt;You Should Use React.memo More!&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서 컴포넌트의 변경이 일어나면 렌더링이 발생하며, 해당 컴포넌트의 하위 컴포넌트도 변경 여부와 상관없이 렌더링이 다시 된다.&lt;/p&gt;
&lt;p&gt;이를 방지하기 위한 방법은 &lt;code&gt;React.memo&lt;/code&gt;를 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;이 영상에서는 memo가 어떻게 동작하는지 예시 프로젝트를 통해 보여주며 메모가 적용되지 않는 경우도 쉽게 설명해 준다.&lt;/p&gt;
&lt;p&gt;규모가 큰 프로젝트에선 이런 사소한 것이 큰 성능 변화를 일으킬 수 있다. React 프로젝트를 진행하고 있다면 memo를 더 적극적으로 적용해 보는 것은 어떨까?&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://taegon.kim/archives/9919"&gt;[JS] 한글도 지원하는 퍼지 문자열 검색&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;종종 어떤 키워드를 검색하고 싶은데 해당 키워드 전체가 기억나지 않을 때가 있다. 그럴 때면 적당히 생각나는 초성 등만을 입력하여 검색을 하게 되는데, 이러한 대략적인 검색 방식을 퍼지 검색이라고 한다.&lt;/p&gt;
&lt;p&gt;이 글은 한글 퍼지 검색에 대한 글이다. 하나씩 차근차근 설명하며 최종 구현 데모 페이지까지 제공한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ridicorp.com/story/how-to-use-redux-in-ridi/"&gt;리덕스 잘 쓰고 계시나요?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React 개발의 초창기에는 React 프로젝트에서 Redux를 사용하는 것이 당연시되어 왔다. 하지만, 이제는 리액트 자체적인 기능뿐 아니라 다른 라이브러리의 도움을 받아 훨씬 편하게 개발할 수 있는 방법이 존재한다.&lt;/p&gt;
&lt;p&gt;이 글은 Redux뿐만 아니라 &lt;a href="https://github.com/diegohaz/constate"&gt;Constate&lt;/a&gt;, &lt;a href="https://recoiljs.org/"&gt;Recoil&lt;/a&gt;, &lt;a href="https://jotai.surge.sh/"&gt;Jōtai&lt;/a&gt; 등 다른 상태 관리 라이브러리 대체재들을 소개하고 있고 같은 구현체를 여러 상태 관리 라이브러리 코드로 작성하고 있어 간단히 비교하기 좋다. React 프로젝트에서 어떤 상태 관리 라이브러리를 도입할지 검토 중일 때 참고하기 좋은 글이다.&lt;/p&gt;
&lt;p&gt;또한, Redux를 사용할 때 참고할만한 훌륭한 팁들을 많이 소개하고 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://dev.to/pandasekh/building-a-real-time-commenting-system-in-react-part-1-3-3kep"&gt;Building a Real-Time Commenting System in React&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/pandasekh/making-nested-comments-building-a-real-time-commenting-system-in-react-part-2-3-3044"&gt;Making Nested Comments - Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/pandasekh/emoji-reactions-for-comments-building-a-real-time-commenting-system-in-react-part-3-3-4m6"&gt;Emoji Reactions for Comments - Part 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;총 3개의 시리즈로 구성된 실시간 댓글 개발 과정을 소개하는 튜토리얼이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소스코드: https://github.com/PandaSekh/React-Commenting-System&lt;/li&gt;
&lt;li&gt;온라인 데모: https://react-commenting-system.vercel.app/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;튜토리얼을 통해 무제한 대댓글, 이모티콘, 마크다운 문법 지원, 페이지 새로 고침 없이 표현되는 실시간 업데이트 등의 기능이 지원되는 댓글 개발을 따라 해 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://dev.to/atapas/the-definitive-guide-to-javascript-debugging-2021-edition-116n"&gt;The definitive guide to JavaScript Debugging [2021 Edition]&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript 애플리케이션을 디버깅하기 위해 알아야 하는 개발자 도구의 사용법과 의미를 간략하게 소개하는 종합적 디버깅 가이드다.&lt;/p&gt;
&lt;p&gt;크롬 개발자 도구를 기반으로 하고 있지만, 타 브라우저들의 개발자 도구들도 모두 유사한 기능을 제공하고 있으므로 학습 내용을 활용하는 것은 전혀 문제 되지 않을 것이다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://forgojs.org/"&gt;Forgo&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;4KB 크기의 라이브러리로, JSX(React의 것과 유사한)를 사용한다. 이미 여러분이 알고 있는 DOM API와 플레인 JS를 사용해 모던 웹앱 개발을 할 수 있게 하기 때문에 별도의 러닝 커브 없이 빠르게 개발을 시작할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://moiva.io/"&gt;Moiva&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;npm 패키지의 다운로드 수, 릴리스 횟수 등 패키지에 대한 전반적 상태에 대한 지표를 확인해 볼 수 있다. 이들 지표를 기준으로 다른 패키지와의 비교를 통해 패키지 선택시 도움을 받을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 유사한 도구로는 다음을 함께 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.npmtrends.com/"&gt;npm trends&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bundlephobia.com/"&gt;Bundle Phobia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://aka.ms/codeswing"&gt;CodeSwing&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;코드 수정을 실시간으로 반영해 미리 보기 할 수 있는 &lt;a href="https://codepen.io/"&gt;CodePen&lt;/a&gt;, &lt;a href="https://jsfiddle.net/"&gt;JSFiddle&lt;/a&gt;과 같은 playground 도구와 같이 VS Code 내에서 상호 동작하는 코딩 환경을 만들어 주는 플러그인이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://handsfree.js.org/"&gt;Handsfree&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;별도의 입력장치를 사용하지 않는 핸즈프리 한 사용자 경험을 구성할 수 있게 도와주는 도구다.&lt;/p&gt;
&lt;p&gt;사용자의 웹캠을 통해 사용자의 움직임(얼굴, 손, 몸짓 등)을 인식하며, 특정 제스처를 인식해 페이지 스크롤, 게임 조작 등을 할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;보다 자세한 내용은 다음의 소개 글을 같이 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/midiblocks/introducing-handsfree-js-integrate-hand-face-and-pose-gestures-to-your-frontend-4g3p"&gt;Introducing Handsfree.js - Integrate hand, face, and pose gestures to your frontend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- CDN에서 관련 파일을 로딩 --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://unpkg.com/handsfree@8.2.2/build/lib/assets/handsfree.css&amp;quot; /&amp;gt;
&amp;lt;script src=&amp;quot;https://unpkg.com/handsfree@8.2.2/build/lib/handsfree.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
    // 초기화
    const handsfree = new Handsfree({hands: true})
    handsfree.enablePlugins('browser')
    handsfree.start()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href="https://createapp.dev"&gt;Create App&lt;/a&gt;: Frontend build config generator&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;webpack, Parcel, Snowpack의 환경 구성을 편리하게 해주는 도구다.&lt;/p&gt;
&lt;p&gt;React, Svelte, Vue의 설정을 지원하며, 이외에도 UI, Test, Transpiler, Style, Image, Utilities, Linting의 설정도 가능하다. 모든 설정이 끝난 뒤에는 다운로드하거나, &lt;code&gt;How to create your project yourself&lt;/code&gt; 가이드를 따라 하면 된다.&lt;/p&gt;
</content></entry><entry><title>2022-04</title><id>https://github.com/naver/fe-news/blob/master/issues/2022-04.md</id><updated>2022-04-06T03:56:52+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2022-04.md" rel="alternate"/><published>2022-04-06T03:56:52+00:00</published><content type="html">&lt;h1&gt;2022-04 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://reactjs.org/blog/2022/03/29/react-v18.html"&gt;React v18.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React v18이 지난 3/29일 정식으로 릴리스 되었다. 주요한 기능들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/reactwg/react-18/discussions/21"&gt;Automatic Batching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reactjs.org/docs/react-api.html#transitions"&gt;Transitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;클라이언트와 서버에서 사용할 수 있는 새로운 렌더링 API
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://reactjs.org/docs/react-dom-client.html"&gt;React DOM Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reactjs.org/docs/react-dom-server.html"&gt;React DOM Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;신규 Hooks (&lt;a href="https://reactjs.org/docs/hooks-reference.html#useid"&gt;useId&lt;/a&gt;, &lt;a href="https://reactjs.org/docs/hooks-reference.html#usetransition"&gt;useTransition&lt;/a&gt;, &lt;a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue"&gt;useDeferredValue&lt;/a&gt;, &lt;a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore"&gt;useSyncExternalStore&lt;/a&gt;, &lt;a href="https://reactjs.org/docs/hooks-reference.html#useinsertioneffect"&gt;useInsertionEffect&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;관심을 모았던 &lt;a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html"&gt;Server Components&lt;/a&gt;는 아직 개발중(실험적) 상태로, 차기 마이너 릴리스 &lt;code&gt;v18.x&lt;/code&gt;를 통해 초기 버전을 공개하는 것이 목표라고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 다음 글은 v18 alpha 버전 기준이나, 주요 변경 사항들을 확인해 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/naver-place-dev/react-18%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EC%84%B8%EC%9A%94-8603c36ddb25"&gt;React 18을 준비하세요&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://hacks.mozilla.org/2022/03/a-new-year-a-new-mdn/"&gt;A New Year, A New MDN&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;최근 &lt;a href="https://developer.mozilla.org/ko/"&gt;MDN&lt;/a&gt; 웹사이트가 개편되었다. MDN은 웹 개발자라면 매일 들어가는 웹사이트라고 해도 과언이 아닐 것이다.&lt;/p&gt;
&lt;p&gt;MDN은 16년 동안 45,000명 이상의 기여자들과 많은 변화를 겪으면서 사용자 경험에 있어서 다소 일관성을 잃었다고 해도 큰 문제는 아닌 것으로 보인다.&lt;/p&gt;
&lt;p&gt;이번 개편은 2021년 중순부터 작업이 시작되었으며 전체적으로 일관된 사용자 경험을 제공할 수 있도록 설계했고 44,000개의 글을 쉽게 검색할 수 있도록 만들었다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 지난 &lt;a href="https://github.com/naver/fe-news/blob/master/issues/2021-07.md#mdn-plus"&gt;FE News '21/7월 소식&lt;/a&gt;을 통해 공유되었던 것처럼, 유료 서비스인 &lt;a href="https://hacks.mozilla.org/2022/03/introducing-mdn-plus-make-mdn-your-own/"&gt;MDN Plus&lt;/a&gt;도 정식 공개되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/"&gt;A Proposal For Type Syntax in JavaScript&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;마이크로소프트(MS)에서 JavaScript에서 타입 구문을 도입하는 &lt;a href="https://github.com/tc39/proposal-type-annotations/"&gt;1단계 제안서&lt;/a&gt;를 &lt;a href="https://tc39.es/"&gt;TC39&lt;/a&gt;에 제출했다.&lt;/p&gt;
&lt;p&gt;MS 팀에서 파악한 JavaScript 생태계의 최근 트렌드 중 하나는 빠른 이터레이션 주기와 빌드 단계의 간소화에 대한 수요였다. 더 빠르고 더 간단하게 만들고자 하는 트렌드 속에서 타입스크립트 컴파일 과정이 좋은 개발자 경험을 방해할 수 있다고 판단하고 해당 제안서를 제출했다.&lt;/p&gt;
&lt;p&gt;이 제안의 핵심 아이디어는 제안서의 제목인 &lt;strong&gt;주석으로서의 타입&lt;/strong&gt;처럼 런타임에서는 완전히 무시하지만, 타입스크립트와 같은 도구가 사용할 수 있는 타입 구문을 JavaScript에서 사용할 수 있다는 것이다. 이로써 빌드 단계는 제거되고 타입 검사와 같은 타입스크립트의 장점을 그대로 가져갈 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 빠르게 읽고 싶다면 &lt;a href="https://velog.io/@eunbinn/A-Proposal-For-Type-Syntax-in-JavaScript"&gt;번역글&lt;/a&gt;을 참고하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/explain-the-first-10-lines-of-twitter-source-code/"&gt;Explain the First 10 Lines of Twitter's Source Code to Me&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 글은 트위터 HTML 소스코드의 상위 10개 라인을 분석해서 설명하는 글이다. 저자는 프론트엔드 기초 지식의 깊이를 파악하기 위해 인터뷰에서 해당 질문을 한다고 언급했다. (인터뷰로서 좋은 질문인지는 다른 이야기인듯하다.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;html&lt;/code&gt;과 &lt;code&gt;meta&lt;/code&gt; 태그의 여러 속성에 관해 설명하고 있으니 플랫폼 간의 일관성과 SEO를 위해서 한 번쯤 읽어보면 좋을 것이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://lexoral.com/blog/you-dont-need-js/"&gt;Five Things You Don't Need JavaScript for&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript로 많은 것을 할 수 있지만 사용하지 않아도 되는 상황까지 사용하는 경우가 가끔 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 굳이 JavaScript를 사용하지 않고 HTML과 CSS를 사용해 구현할 수 있는 5가지 예시(사이드바, 아코디언 메뉴, 다크모드 등)를 Svelte 코드와 함께 보여준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://leafletjs.com/index.html"&gt;🇺🇦 Leaflet Project Appeals to JS Developers for Ukraine&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://github.com/Leaflet/Leaflet"&gt;Leaflet&lt;/a&gt;은 우크라이나인 개발자가 만든 유명한 지도 자바스크립트 라이브러리다.&lt;/p&gt;
&lt;p&gt;Leaflet 팀은 Leaflet 라이브러리 공식 웹사이트에서 최근 벌어지고 있는 전쟁과 우리가 어떻게 도울 수 있는지에 대해 공유하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jott.live/markdown/new_js"&gt;The Most Modern JavaScript I Know (in One Script)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;이 글에서는 짧은 코드에 여러 가지 모던 JavaScript 개념을 포함한다. 짧은 글로 가볍게 읽어보며 모던 JavaScript 개념을 훑을 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.zhenghao.io/posts/memo-or-not"&gt;Preemptive Memoization In React Is Probably Not Evil (Yet)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;React에서 값에 대한 메모이제이션을 하기 위해 대체로 &lt;code&gt;useMemo&lt;/code&gt; 또는 &lt;code&gt;useCallback&lt;/code&gt; hook을 사용해 접근하며,
보통 반복적 수행에 따른 계산 값을 위한 최적화, 그리고 재 렌더링에 따라 발생될 수 있는 객체의 변화에 대한 안정화를 위한 목적을 위해 사용된다.&lt;/p&gt;
&lt;p&gt;이 글은 두 번째 목적에 집중해 재 렌더링 시, React의 semi-functional 프로그래밍 모델과 impure 한 JavaScript 언어의 불일치에 따른 객체의 안정성 측면에 대해 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[참고] 성능 최적화를 위한 선제적 최적화를 위한 기법으로 메모이제이션은 사용은 권장되지 않는 이유가 궁금하다면 다음 링크를 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://royi-codes.vercel.app/thousand-usecallbacks/"&gt;Death by a thousand useCallbacks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://velog.io/@teo/oop"&gt;객체지향 프로그래밍과 Javascript (약간의 역사를 곁들인...)&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;객체지향 프로그래밍이 꼭 정답일까?&lt;/p&gt;
&lt;p&gt;함수형 언어도 객체지향 언어도 아니지만, 또 함수형 언어이기도 하고 객체지향 언어이기도 한 JavaScript로 객체지향 프로그래밍을 해야 할까?&lt;/p&gt;
&lt;p&gt;이 글은 객체지향이 갖는 특징이 무엇이고 어떻게 등장했는지 상세히 설명한다.
동시에 JavaScript는 그것을 어떻게 표방했는지 비교하며, 결국엔 객체지향 프로그래밍도 문제점을 해결하기 위한 하나의 관점이자 방법론일 뿐 객체지향의 여러 장점을 취하면서 Javascript의 고유한 특성을 가지고 어떻게 하면 더 좋은 설계를 할 수 있을지 고민하는 것이 더 올바른 방향임을 이야기하고 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://tympanus.net/codrops/2022/03/04/creating-native-web-components/"&gt;Creating Native Web Components&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://minze.dev/"&gt;Minze&lt;/a&gt;는 React, Vue.js, Angular와 같이 복잡한 UI를 만들거나 SPA를 만드는 프레임워크가 아니고
캡슐화되고 재사용 가능한 네이티브 웹 컴포넌트를 만들 때 사용하는 JavaScript 프레임워크다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Minze를 사용해 아코디언, 스위치, 카드 등 컴포넌트를 직접 만들어보며 네이티브 웹 컴포넌트를 만드는 방법에 대해 배워본다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://web.dev/building-a-loading-bar-component/"&gt;Building a loading bar component&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=TD1QxlGgIPk&amp;amp;list=PLNYkxOF6rcIAaV1wwI9540OC_3XoIzMjQ&amp;amp;index=1"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/argyleink/gui-challenges"&gt;GUI Challenges&lt;/a&gt;는 인터페이스에 대해 먼저 작성해 보고 피드백을 받은 다른 사람들의 방법도 공유한다.&lt;/p&gt;
&lt;p&gt;이번에는 &lt;code&gt;로딩 바 컴포넌트&lt;/code&gt;의 구현을 제공하는데, 이 과정에서 웹 접근성과 호환성을 위해 고려한 점들을 배울 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://play.inginf.units.it/"&gt;RegexPlay&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;자신의 정규 표현식 실력이 어느 정도인지 궁금하지 않은가? 정규 표현식은 자주 쓰이는 문법이 아니다 보니 생소한 개발자들이 많을 것이다.&lt;/p&gt;
&lt;p&gt;RegexPlay에서 정규 표현식 퀴즈를 풀고, 자신의 점수와 백분위를 확인해 보자.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://revealjs.com/"&gt;Reveal.js: An HTML Presentation Framework&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Reveal.js는 HTML을 사용해 브라우저 내에서 프레젠테이션을 만들 수 있는 프레임워크다.&lt;/p&gt;
&lt;p&gt;CSS로 프레젠테이션의 스타일을 변경할 수 있고, Reveal.js에서 제공하는 &lt;a href="https://revealjs.com/api/"&gt;JavaScript API&lt;/a&gt;를 사용해 특정 액션을 추가할 수도 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://webtoon.github.io/psd/"&gt;PSD: A Zero-Dependency Photoshop Parser&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://webtoonscorp.com/"&gt;네이버 웹툰&lt;/a&gt;에서 개발한 포토샵 파일을 파싱할 수 있는 JavaScript 라이브러리다.&lt;/p&gt;
&lt;p&gt;포토샵 파일 확장자인 PSD 혹은 PSB 파일을 지원하며 각 레이어의 정보(사이즈, 오프셋, 이미지 등)를 파싱할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.ladle.dev/blog/introducing-ladle/"&gt;Introducing Ladle&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Ladle은 React 컴포넌트를 온전히 고립된 환경에서 개발과 테스트를 할 수 있게 하는 도구로, Storybook의 Component Style Format을 지원하며, 별도의 수정 없이 기존 Storybook을 대체(drop-in replacement) 하기 위해 개발되었다.&lt;/p&gt;
&lt;p&gt;Uber 개발자 플랫폼 소속의 &lt;a href="https://twitter.com/vmiksu"&gt;Vojtech Miksu&lt;/a&gt;가 개발한 Ladle은 vite를 사용해 빌드 하기 때문에, 각 컴포넌트들이 번들링 될 필요 없이 네이티브 ESM으로 서빙되기 때문에 훨씬 빠르게 동작한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://github.com/vadimdemedes/ink"&gt;Ink: React for interactive command-line apps&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Ink는 React를 사용해 컴포넌트 기반의 CLI를 만들 수 있는 라이브러리다. React를 사용하던 개발자라면 Ink를 사용해 쉽게 CLI를 개발할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;또한, 해당 오픈소스 메인테이너는 다음과 같은 Ink와 관련된 많은 유틸 라이브러리를 개발해 제공하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/vadimdemedes/create-ink-app"&gt;create-ink-app&lt;/a&gt; - Ink 기반 프로젝트 생성 CLI&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vadimdemedes/ink-testing-library"&gt;ink-testing-library&lt;/a&gt; - Ink 테스팅 유틸 라이브러리&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vadimdemedes/ink-spinner"&gt;ink-spinner&lt;/a&gt; - Ink Spinner 컴포넌트&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vadimdemedes/ink-text-input"&gt;ink-text-input&lt;/a&gt; - Ink Text Input 컴포넌트&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음 코드와 데모 예시를 보면 어떤 식으로 동작하는지 간단히 파악할 수 있을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;import React, { useState, useEffect } from &amp;quot;react&amp;quot;;
import { render, Text } from &amp;quot;ink&amp;quot;;

const Counter = () =&amp;gt; {
  const [counter, setCounter] = useState(0);

  useEffect(() =&amp;gt; {
    const timer = setInterval(() =&amp;gt; {
      setCounter((previousCounter) =&amp;gt; previousCounter + 1);
    }, 100);

    return () =&amp;gt; {
      clearInterval(timer);
    };
  }, []);

  return &amp;lt;Text color=&amp;quot;green&amp;quot;&amp;gt;{counter} tests passed&amp;lt;/Text&amp;gt;;
};

render(&amp;lt;Counter /&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://userinyerface.com/"&gt;User Inyerface&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;벨기에 디지털 제품 에이전시 회사인 &lt;a href="https://www.bagaar.be/"&gt;BAGAAR&lt;/a&gt;가 개발한 사용자 인터페이스 체험(?) 게임으로, 왜 좋은 사용자 인터페이스가 필요한지를 알려주기 위해 역설적이게도 가장 최악의 사용자 인터페이스로 구성된 회원가입 페이지를 통해 직접 체험해 볼 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;무사히(?) 회원가입을 도전해 보기 바란다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Tip] 처음 시작을 위해 헤맬 수도 있는데, 다음 페이지로 이동하기 위해선 제일 하단의 &lt;code&gt;HERE&lt;/code&gt; 부분을 클릭해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
</content></entry><entry><title>2020-07</title><id>https://github.com/naver/fe-news/blob/master/issues/2020-07.md</id><updated>2020-07-07T02:04:03+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2020-07.md" rel="alternate"/><published>2020-07-01T02:06:30+00:00</published><content type="html">&lt;h1&gt;2020-07 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://css-tricks.com/off-the-main-thread/"&gt;Off The Main Thread&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;JavaScript는 &amp;quot;단일 스레드&amp;quot;로 실행되며, 이는 곧 한 개의 콜 스택(call stack)과 한 개의 메모리 힙(memory heap)이 존재함을 의미한다.&lt;/p&gt;
&lt;p&gt;모든 작업이 메인 스레드에서 실행된다는 것은 마치 도시로 향하는 단 하나의 길을 통해 모든 차량들이 그곳으로 가기 위해 길 위에서 기다리고 있는 모습으로 비유될 수 있다. 이러한 병목현상 문제를 해결하는 방법은 무엇일까?&lt;/p&gt;
&lt;p&gt;바로 모든 작업을 메인 스레드에서 실행하지 않는 것이다. UI 관련 작업이 아니라면, 네이티브 표준 API인 &amp;quot;Web Workers&amp;quot;를 사용해 메인 스레드 밖에서 JavaScript를 실행하고, 가능한 한 모든 상황에서 이를 적용하는 것에 대한 필요성을 언급하는 내용의 글이다.&lt;/p&gt;
&lt;h2&gt;JavaScript Visualized&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;다음의 7개 주제로 구분된 이 시리즈는 시각적 이미지와 애니메이션을 사용해 JavaScript의 언어적 특성과 함께 핵심적인 개념들을 쉽게 이해할 수 있도록 도와준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif"&gt;Event Loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-hoisting-478h"&gt;Hoisting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-scope-chain-13pd"&gt;Scope (Chain)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-the-javascript-engine-4cdf"&gt;JavaScript 엔진&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co"&gt;Prototypal Inheritance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-generators-and-iterators-e36"&gt;Generators and Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke"&gt;Promises &amp;amp; Async/Await&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://d2.naver.com/helloworld/7804182"&gt;어서와, SSR은 처음이지? - 도입 편&lt;/a&gt; (1/3 진행 중)&lt;/h2&gt;
&lt;p&gt;네이버 블로그 서비스에 Node.js 기반의 SSR을 도입한 경험기를 소개하는 첫번째 글이다.&lt;/p&gt;
&lt;p&gt;이 글은 총 3편 중 첫번째 &amp;quot;도입 편&amp;quot;으로 Node.js 기반의 SSR을 블로그 서비스에 도입한 이유와 배경에 관한 글이다.&lt;/p&gt;
&lt;p&gt;angular.js를 선택하고, Full Stack Developer를 지향했던 개발팀이 왜? React를 선택하고, FE 전문 인력을 육성하게 되었는지를 설명하고 있다.&lt;/p&gt;
&lt;p&gt;이후 다룰 &amp;quot;개발편&amp;quot;, &amp;quot;운영편&amp;quot;에서는 대한민국 국민들이 모두 사용하는 블로그의 트래픽을 준비한 경험과 운영했던 내용을 다룰 예정이라 다음 편이 더 기대되는 글이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://addyosmani.com/blog/profiling-react-js/"&gt;Profiling React.js Performance&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;리액트의 Profiler API와 Interaction Tracing API, 그리고 브라우저의 User Timing API을 이용하여 영화 앱의 랜더링 속도와 인터랙션 속도를 어떻게 측정할 수 있는지 설명하고 있다.&lt;/p&gt;
&lt;p&gt;이 글에서 다루는 API를 이용하면 훌륭한 클라이언트 랜더링 모니터링 툴도 충분히 구축 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kentcdodds.com/blog/react-production-performance-monitoring"&gt;React Production Performance Monitoring&lt;/a&gt; 에서는 이를 이용한 Performance Monitoring 툴 구축 아이디어를 언급하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://wit.nts-corp.com/2020/06/05/6134"&gt;CSS 애니메이션의 성능 아는 만큼 좋아져요!&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome DevTools을 통해 애니메이션시 적용하는 CSS 속성에 따라 애니메이션이 어떻게 성능 차이가 나는지를 예제를 통해 보여주는 글이다.&lt;/p&gt;
&lt;p&gt;이 글을 통해 간접적으로나마 Chrome DevTools에서 성능을 측정하교 비교하는 방법을 배울 수 있다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;리액트 훅 MVVM 시리즈 글 (진행 중)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.bsidesoft.com/8267"&gt;리액트 훅 MVVM #1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bsidesoft.com/8280"&gt;리액트 훅 MVVM #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bsidesoft.com/8289"&gt;리액트 훅 MVVM #3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bsidesoft.com/8304"&gt;리액트 훅 MVVM #4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적인 리액트 훅을 이용한 개발 튜토리얼이기보다는 리액트의 모델-렌더 시스템을 이해하고 이를 이용하여 MVVM 모델로 구축해보는 튜토리얼 성격의 글이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1부에서는 리액트의 모델-렌더 시스템과 증분 랜더링 소개를 시작으로 리액트 훅의 개념을 설명하고 있다.&lt;/li&gt;
&lt;li&gt;2부에서는 MVVM 모델의 바인더를 리액트 state를 통해 구현하고 커맨드의 구조를 만들어 가는 것을 설명하고 있다.&lt;/li&gt;
&lt;li&gt;3 ~ 4 부에서는 todo 앱을 만들어 보면서 리액트 훅의 미묘한 차이점을 살펴본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;재미있는 점은 이 글에서는 리액트 함수형 컴포넌트와 훅 사용으로 인해 발생하는 미묘한 차이를 저자의 독특한 시각과 방법으로 해결하고 있다.
리액트를 이용하여 MVVM을 구현하는 것보다 이 튜토리얼을 통해 리액트를 더 잘 이해할 수 있는 계기가 되면 좋겠다.&lt;/p&gt;
&lt;p&gt;이 글 외에 리액트 훅에 대한 자세한 내용을 알고 싶다면 다음 글을 참조해 보길 바란다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Complete Guide to useEffect &lt;a href="https://overreacted.io/ko/a-complete-guide-to-useeffect/"&gt;[한국어]&lt;/a&gt; [&lt;a href="https://overreacted.io/a-complete-guide-to-useeffect/"&gt;영어&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leontrolski.github.io/33-line-react.html"&gt;33 line React&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;API 공통화 관련 글&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리액트 앱에서의 중앙 집중식 API 에러 핸들링 [&lt;a href="https://ui.toast.com/weekly-pick/ko_20200623/"&gt;한국어&lt;/a&gt;] [&lt;a href="https://itnext.io/centralizing-api-error-handling-in-react-apps-810b2be1d39d?gi=9de019662e0c"&gt;영어&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/swlh/usefetch-a-custom-react-hook-36d5f5819d8"&gt;useFetch — A Custom React Hook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;첫번째 글은 &amp;quot;API 오류를 어떻게 중앙에서 관리하는가?&amp;quot;에 대한 문제를 중심으로 풀어가는 글이라면 두번째 글은 &amp;quot;React Custom Hook을 어떻게 만드는가?&amp;quot;에 대한 글이다.&lt;br /&gt;
두 글의 목적이 다르지만 API를 공통화해가는 과정은 두 글 모두 인상 깊다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://morioh.com/p/a76bc7d72226"&gt;127 Useful JavaScript Snippets You can understand in 30 seconds&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;127 개의 유용한 JavaScript 코드 조각 모음.&lt;br /&gt;
127 개라 긴 글일거라 생각하겠지만. 쉽게 이해 할 수 있는 요긴하고 간단한 코드 조각들이다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://codepen.io/anniebombanie/pen/pojmNzN?__cf_chl_jschl_tk__=71de61593b16a5028cd8b9ae58a10111bf587d1c-1591055028-0-ATDH36t3q8LbU3cZgW28qQcbIcWRru4XfaWNQchgM8IcwSMs8kGFf9aC-pj8_NLur2_KvBf4a9la1eojybUQRq09ItOPayABj0M6cAXpABEXrjyY3vvhROMPWLlf_dw1Bg8fNMqEVAkf-OA3auDTTPuv8JZ_nQhkNlGjKDP5hkxplNPMxn5enH7TmVLNatpPCSBbwdAqZQNiDO0R2LqA_s-OlN9bdlIMKJ4wTvpBzChZF5dSh"&gt;One Div iPad Pro&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CSS만으로 그린 iPad Pro 예제 코드&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://audiomass.co/"&gt;audiomass.co&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;서버 기술 없이 브라우저 웹 기술만으로 음성을 편집할 수 있는 웹 음성 편집기.&lt;br /&gt;
Web Audio API와 WebAssembly를 이용하여 오디오 효과 적용과 편집을 구현하고 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2&gt;&lt;a href="https://woowacourse.github.io/javable/"&gt;우아한테크코스 코드 리뷰 모음 블로그&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;우아한 형제들의 &amp;quot;우아한테크코스&amp;quot; 코드리뷰 내용을 정리하여 공개한 사이트.&lt;br /&gt;
FrontEnd와 직접 적인 관련은 없지만 코드를 바라보는 개발자로서 참고하면 좋은 이야기들로 가득하다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio"&gt;Draw.io VS Code Integration&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;다이어그램을 그리고 쉽게 공유할 수 있는 도구인 draw.io의 VS Code Extension.&lt;br /&gt;
개발과 함께 설계도 이제 VS Code 내에서 자유롭게 사용할 수 있다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
</content></entry><entry><title>2021-10</title><id>https://github.com/naver/fe-news/blob/master/issues/2021-10.md</id><updated>2021-10-06T05:09:13+00:00</updated><link href="https://github.com/naver/fe-news/blob/master/issues/2021-10.md" rel="alternate"/><published>2021-10-06T04:47:40+00:00</published><content type="html">&lt;h1&gt;2021-10 &lt;!-- raw HTML omitted --&gt;&lt;/h1&gt;
&lt;h1&gt;링크 &amp;amp; 읽을거리&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://trekhleb.dev/blog/2021/self-parking-car-evolution/"&gt;SELF-PARKING CAR IN 500 LINES OF CODE&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a href="https://github.com/trekhleb/self-parking-car-evolution"&gt;Self-Parking Car Evolution&lt;/a&gt; 프로젝트는 유전 알고리즘(&lt;a href="https://en.wikipedia.org/wiki/Genetic_algorithm"&gt;Genetic Algorithm&lt;/a&gt;)의 기본 작동 원리를 학습하기 위한 목적의 프로젝트다. 이를 위해 자동차의 자율 주차 학습 과정을 통해 접근하며, 이 글은 500 라인의 코드를 통해 자율주차 학습 과정을 단계별로 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://trekhleb.dev/self-parking-car-evolution/"&gt;Self-Parking Car Evolution 시뮬레이터&lt;/a&gt;를 통해 브라우저에서 과정을 시뮬레이션 해 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://www.gatsbyjs.com/gatsby-4/"&gt;Gatsby 4 Beta released&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Gatsby는 리액트와 GraphQL 기반의 정적 웹사이트를 생성할 수 있는 프레임워크로 4.0 베타 버전이 릴리즈되었다.&lt;/p&gt;
&lt;p&gt;다음과 같은 기능들이 추가되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server side rendering: 이제 Gatsby에서도 런타임에 데이터를 요청하고 렌더 할 수 있다.&lt;/li&gt;
&lt;li&gt;Deferred static generation: 모든 페이지를 빌드 타임에 생성하지 않고, 어떤 페이지는 빌드 타임에, 어떤 페이지는 런타임에 생성되도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;Parallel processing: 멀티프로세싱을 함으로써 SSG(Static site generation) 빌드 시간을 획기적으로 줄였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href="https://www.smashingmagazine.com/2021/09/interactive-learning-tools-front-end-developers/"&gt;Interactive Learning Tools For Front-End Developers&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;CSS, JavaScript, 리액트, 정규표현식, SQL 등을 게임같이 재밌게 학습할 수 있는 웹사이트들을 모아두었다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://ui.toast.com/weekly-pick/ko_20210812"&gt;React 상태 관리 라이브러리 Zustand의 코드를 파헤쳐보자&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;TOAST UI Calendar에서 애플리케이션의 상태를 효과적으로 다루는 상태 관리 도구를 만들어 보려는 과정에서 찾게 된 Zustand에 대해서 상세히 알려준다.
왜 Zustand를 선택하게 되었고, 그리고 내부 동작원리까지 잘 설명해 주고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jbee.io/react/stop-using-atomic-design/"&gt;Stop Using Atomic Design&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;컴포넌트 기반의 웹 개발을 하면서 많은 이야기가 이루어지고 사용되는 개념 중에 &lt;a href="https://atomicdesign.bradfrost.com/table-of-contents/"&gt;Atomic Design&lt;/a&gt;이 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 상대적으로 순수하지 않고, 유용하지 않다는 Atomic Design의 단점을 설명하면서 변경에 유연하게 대응할 수 있도록 컴포넌트를 설계해야 한다고 말하고 있다. 다음 글인 &lt;a href="#%EB%B3%80%EA%B2%BD%EC%97%90-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8"&gt;변경에 유연한 컴포넌트&lt;/a&gt;로 이어진다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://jbee.io/web/components-should-be-flexible/"&gt;변경에 유연한 컴포넌트&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;우리가 작성하는 소프트웨어는 지속 가능해야 한다. 작성하는 코드는 예상할 수 없는 변경에 그나마 유연하게 대응할 수 있어야 한다.&lt;/p&gt;
&lt;p&gt;이 글에서는 다음과 같은 변경에 유연한 컴포넌트를 개발하기 위한 방법론을 제시한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴포넌트는 &lt;strong&gt;데이터&lt;/strong&gt;와 &lt;strong&gt;역할&lt;/strong&gt;을 중심으로 추상화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일반적인 인터페이스&lt;/strong&gt;로 컴포넌트를 설계한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="https://blog.sentry.io/2021/08/31/guest-post-performance-monitoring-in-graphql"&gt;Performance Monitoring in GraphQL&lt;/a&gt; - Sentry, Apollo Server&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;BFF에서 GraphQL의 사용을 위해 많은 오픈 소스 중 하나인 &lt;a href="https://www.apollographql.com/docs/apollo-server/"&gt;Apollo Server&lt;/a&gt;를 많이 선택한다.
또, &lt;a href="https://sentry.io/"&gt;Sentry&lt;/a&gt;는 에러 트래킹 서비스로 FE의 모니터링뿐만 아니라 BE의 모니터링도 가능하다.
이 글에서는 &lt;a href="https://www.apollographql.com/docs/apollo-server/v2/integrations/plugins/"&gt;Apollo Server의 Plugin 기능&lt;/a&gt;을 이용해 Sentry를 통해 resolver 단위로 성능을 측정할 수 있는 방법을 안내해 준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://medium.com/arctouch/how-to-study-design-patterns-as-a-web-developer-e54284958e48"&gt;How To Study Design Patterns as a Web Developer&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;대부분 디자인 패턴의 내용은 OOP 기반 언어에 영향을 많이 받아 그 아이디어에 많이 젖어있다. 그렇기 때문에 다른 언어 개발자에 비해 class 사용이 적은 프론트엔드 개발자는 거의 대부분 OOP 기반으로 작성된 문서들이 어색하게 느껴질 수 있다.
이에 대해 저자는 클래스와 객체는 도구일 뿐이며 디자인 패턴은 문제와 솔루션을 설명한다는 것 그 자체임을 강조하면서, 패턴을 적용하고 함수형으로 발전시키는 과정을 예시로 상세하게 보여준다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://bytefish.medium.com/does-for-loop-nesting-order-affect-performance-dbc677217e66"&gt;Does for-loop Nesting Order Affect Performance?&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;중첩 for loop에서 순서에 따라 성능이 달라질 수 있을까? 결론부터 말하면 loop 횟수가 많은 for loop를 안쪽에 위치시킬수록 성능이 좋다고 한다.
실무에서는 이런 경우가 거의 발생하진 않겠지만 참고용으로 봐두면 좋을 듯하다.&lt;/p&gt;
&lt;h1&gt;튜토리얼&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/jamiebuilds/the-super-tiny-compiler"&gt;The Super Tiny Compiler&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;읽기 쉬운 JavaScript로 작성된 현대 컴파일러의 주요 부분들에 대해 매우 간단하게 작성된 예제다. 코드와 코드 내의 주석을 통해 현대 컴파일러가 어떻게 동작하는지 학습할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;준비가 되었다면, &lt;a href="https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js"&gt;1k 라인의 코드&lt;/a&gt;를 통해 학습을 시작할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/hg-pyun/the-super-tiny-compiler-kr"&gt;[참고]한글 번역&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://prateeksurana.me/blog/javascript-developer-guide-to-browser-cookies/"&gt;A JavaScript developer’s guide to browser cookies&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;브라우저에서 쿠키 작동 방식, 클라이언트와 서버에서 쿠키에 액세스하고 조작할 수 있는 방법, 브라우저의 속성을 사용하여 쿠키의 가시성을 제어하고 쿠키를 보다 안전하게 만드는 방법에 대해 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://devtrium.com/posts/how-use-react-context-pro"&gt;How to use React Context like a pro&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;리액트의 내장 Context API는 현재 매우 유용하게 쓰이고 있다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Context API를 프로처럼 사용할 수 있는 여러 패턴을 코드와 함께 설명한다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.freecodecamp.org/news/event-propagation-event-bubbling-event-catching-beginners-guide/"&gt;Event Bubbling and Event Catching in JavaScript and React – A Beginner's Guide&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 튜토리얼은 JavaScript와 리액트에서 이벤트 전파가 어떻게 이루어지는지 이해하기 쉽게 설명한 글이다.&lt;/p&gt;
&lt;h1&gt;코드와 도구&lt;/h1&gt;
&lt;h2&gt;&lt;a href="https://github.com/BuilderIO/partytown"&gt;Partytown&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;실험적 도구인 Partytown은 AngularJS를 개발했던 &lt;a href="http://misko.hevery.com/about/"&gt;Miško Hevery&lt;/a&gt;가 CTO로 일하고 있는 &lt;a href="https://www.builder.io/"&gt;Builder.io&lt;/a&gt;에서 개발한 lazy 로딩되는 6kb의 라이브러리로, 리소스를 많이 사용하는 스크립트(또는 서드파티)를 web worker에 재배치해 메인 스레드 부담을 덜어주고 여러분의 코드가 빠르게 실행될 수 있도록 만들어 줄 수 있다.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://github.com/BuilderIO/partytown/tree/v0.0.3#how-does-it-work"&gt;어떻게 동작할까?&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;스크립트들은 메인 스레드에서 실행되지 않도록 &lt;code&gt;type=&amp;quot;text/partytown&amp;quot;&lt;/code&gt;으로 설정&lt;/li&gt;
&lt;li&gt;Service Worker의 &lt;code&gt;onfetch&lt;/code&gt; 핸들러 설정을 통해 특정 요청을 가로채게 한다.&lt;/li&gt;
&lt;li&gt;Worker 스레드 내에서 실행될 스크립트가 Web Worker에게 전달&lt;/li&gt;
&lt;li&gt;Web Worker는 JavaScript &lt;a href="https://github.com/BuilderIO/partytown/blob/9e8b10d4db995153d5dec74650486b2306ad0473/src/lib/web-worker/worker-proxy.ts#L212"&gt;Proxy들을 생성&lt;/a&gt;해 메인 스레드 API(DOM 조작 등의) 호출을 복제하고 전달한다.&lt;/li&gt;
&lt;li&gt;JS 프록시에 대한 요청은 &lt;a href="https://github.com/BuilderIO/partytown/blob/9e8b10d4db995153d5dec74650486b2306ad0473/src/lib/service-worker/sync-send-message-to-main-sw.ts#L9"&gt;동기 XHR 호출&lt;/a&gt;을 사용&lt;/li&gt;
&lt;li&gt;Service Worker는 요청을 가로챈 다음, 메인 스레드와 비동기 통신을 한다.&lt;/li&gt;
&lt;li&gt;이후, Service Worker가 메인 스레드로부터 결과를 전달받아 Web Worker 요청에 응답한다.&lt;/li&gt;
&lt;li&gt;Web Worker에서 실행되는 코드 관점에서 본다면, 모든 것은 동기화되었고, 그리고 각각의 document 호출은 차단되었다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;보다 자세한 내용은 다음 링크들을 참고하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/adamdbradley/introducing-partytown-run-third-party-scripts-from-a-web-worker-2cnp"&gt;Introducing Partytown: Run Third-Party Scripts From a Web Worker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/zqOnySYnGrQ?t=115"&gt;Miško Hevery가 설명하는 Partytown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/ariaminaei/theatre"&gt;Theatre.js&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;웹에서 사용할 수 있는 모션 디자인 에디터로 프로그램적으로 또는 시각적 도구를 통해 편집할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://theatrejs-demo.netlify.app/"&gt;온라인 데모&lt;/a&gt;
좌측 하단의 버튼을 클릭해 비주얼 편집 도구를 열 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href="https://github.com/electerious/Ackee"&gt;Ackee: A Self-Hosted, Node-Based Web Analytics Tool&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Ackee는 Node.js 기반의 웹사이트의 트래픽을 분석하고 유용한 통계를 제공해주는 도구다.&lt;/p&gt;
&lt;p&gt;직접 호스팅할 수 있으며 여러 환경에서 설치할 수 있는 가이드를 제공하고 있다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/privatenumber/tasuku"&gt;Tasuku (タスク): A Minimal Task Runner for Node&lt;/a&gt;&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Tasuku는 Node.js를 위한 태스크 러너다.&lt;/p&gt;
&lt;p&gt;태스크를 라벨링 할 수 있고, 성공, 실패, 로딩 중 등의 상태를 터미널에 표시할 수 있다.&lt;/p&gt;
</content></entry></feed>